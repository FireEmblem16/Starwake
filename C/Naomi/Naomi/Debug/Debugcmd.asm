; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\Users\The Science Guy\Documents\Visual Studio 2008\Projects\Naomi\Naomi\Debugcmd.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?currentDir@@3PADA				; currentDir
_BSS	SEGMENT
?currentDir@@3PADA DB 0400H DUP (?)			; currentDir
_BSS	ENDS
PUBLIC	??_C@_03GGMBOIKO@a?3?1?$AA@			; `string'
PUBLIC	??_C@_0DE@IHDDEGIG@Naomi?5OS?5debug?5command?5prompt?5?9?5@ ; `string'
PUBLIC	?DebugcmdStart@@YAXXZ				; DebugcmdStart
EXTRN	?strcpy@@YAPADPADPBD@Z:PROC			; strcpy
EXTRN	?DebugPuts@@YAXPAD@Z:PROC			; DebugPuts
;	COMDAT ??_C@_03GGMBOIKO@a?3?1?$AA@
; File c:\users\the science guy\documents\visual studio 2008\projects\naomi\naomi\debugcmd.cpp
CONST	SEGMENT
??_C@_03GGMBOIKO@a?3?1?$AA@ DB 'a:/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IHDDEGIG@Naomi?5OS?5debug?5command?5prompt?5?9?5@
CONST	SEGMENT
??_C@_0DE@IHDDEGIG@Naomi?5OS?5debug?5command?5prompt?5?9?5@ DB 'Naomi OS '
	DB	'debug command prompt - 2010 Omacron-LURYI', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?DebugcmdStart@@YAXXZ
_TEXT	SEGMENT
?DebugcmdStart@@YAXXZ PROC				; DebugcmdStart, COMDAT

; 28   : 	DebugPuts("Naomi OS debug command prompt - 2010 Omacron-LURYI\n");

	push	OFFSET ??_C@_0DE@IHDDEGIG@Naomi?5OS?5debug?5command?5prompt?5?9?5@
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 29   : 	strcpy(currentDir,"a:/");

	push	OFFSET ??_C@_03GGMBOIKO@a?3?1?$AA@
	push	OFFSET ?currentDir@@3PADA		; currentDir
	call	?strcpy@@YAPADPADPBD@Z			; strcpy
	add	esp, 12					; 0000000cH

; 30   : 	currentDir[3] = '\0';

	mov	BYTE PTR ?currentDir@@3PADA+3, 0

; 31   : 
; 32   : 	return;
; 33   : }

	ret	0
?DebugcmdStart@@YAXXZ ENDP				; DebugcmdStart
_TEXT	ENDS
PUBLIC	??_C@_02LLMPMKNF@?$DO?5?$AA@			; `string'
PUBLIC	?DebugcmdPrompt@@YAXXZ				; DebugcmdPrompt
;	COMDAT ??_C@_02LLMPMKNF@?$DO?5?$AA@
CONST	SEGMENT
??_C@_02LLMPMKNF@?$DO?5?$AA@ DB '> ', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?DebugcmdPrompt@@YAXXZ
_TEXT	SEGMENT
?DebugcmdPrompt@@YAXXZ PROC				; DebugcmdPrompt, COMDAT

; 37   : 	DebugPuts(currentDir);

	push	OFFSET ?currentDir@@3PADA		; currentDir
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 38   : 	DebugPuts("> ");

	push	OFFSET ??_C@_02LLMPMKNF@?$DO?5?$AA@
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 8

; 39   : 
; 40   : 	return;
; 41   : }

	ret	0
?DebugcmdPrompt@@YAXXZ ENDP				; DebugcmdPrompt
_TEXT	ENDS
PUBLIC	??_C@_02DLFOHOMG@?3?1?$AA@			; `string'
PUBLIC	??_C@_02DJGKEECL@?4?4?$AA@			; `string'
PUBLIC	?DebugValidateParsePath@@YA_NPAD@Z		; DebugValidateParsePath
EXTRN	?strlen@@YAIPBD@Z:PROC				; strlen
EXTRN	?volOpenFile@@YA?AU_FILE@@PBD@Z:PROC		; volOpenFile
EXTRN	?strrem@@YAXPADI@Z:PROC				; strrem
EXTRN	?strchr@@YAPADPAD0D@Z:PROC			; strchr
EXTRN	?strchr@@YAPADPAD0@Z:PROC			; strchr
EXTRN	?strchr@@YAPADPADD@Z:PROC			; strchr
;	COMDAT ??_C@_02DLFOHOMG@?3?1?$AA@
CONST	SEGMENT
??_C@_02DLFOHOMG@?3?1?$AA@ DB ':/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DJGKEECL@?4?4?$AA@
CONST	SEGMENT
??_C@_02DJGKEECL@?4?4?$AA@ DB '..', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?DebugValidateParsePath@@YA_NPAD@Z
_TEXT	SEGMENT
_file$ = -1144						; size = 60
$T3259 = -1084						; size = 60
_buf$ = -1024						; size = 1024
_path$ = 8						; size = 4
?DebugValidateParsePath@@YA_NPAD@Z PROC			; DebugValidateParsePath, COMDAT

; 44   : {

	sub	esp, 1144				; 00000478H
	push	ebx
	push	ebp

; 45   : 	char buf[1024];
; 46   : 	strcpy(buf,path);

	mov	ebp, DWORD PTR _path$[esp+1148]
	push	esi
	lea	eax, DWORD PTR _buf$[esp+1156]
	push	ebp
	push	eax
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 47   : 
; 48   : 	if(*(strchr(buf,'\0') - 1) == '/' && *(strchr(buf,'\0') - 2) != ':')

	lea	ecx, DWORD PTR _buf$[esp+1164]
	push	0
	push	ecx
	call	?strchr@@YAPADPADD@Z			; strchr
	mov	ebx, 47					; 0000002fH
	add	esp, 16					; 00000010H
	cmp	BYTE PTR [eax-1], bl
	jne	SHORT $LN10@DebugValid
	lea	edx, DWORD PTR _buf$[esp+1156]
	push	0
	push	edx
	call	?strchr@@YAPADPADD@Z			; strchr
	add	esp, 8
	cmp	BYTE PTR [eax-2], 58			; 0000003aH
	je	SHORT $LN10@DebugValid

; 49   : 		*(strchr(buf,'\0') - 1) = '\0';

	lea	eax, DWORD PTR _buf$[esp+1156]
	push	0
	push	eax
	call	?strchr@@YAPADPADD@Z			; strchr
	add	esp, 8
	mov	BYTE PTR [eax-1], 0
$LN10@DebugValid:

; 50   : 
; 51   : 	for(char* p = buf;strchr(p,"..");)

	lea	ecx, DWORD PTR _buf$[esp+1156]
	push	OFFSET ??_C@_02DJGKEECL@?4?4?$AA@
	push	ecx
	call	?strchr@@YAPADPAD0@Z			; strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@DebugValid
$LL9@DebugValid:

; 52   : 	{
; 53   : 		char* x = strchr(p,"..");

	lea	edx, DWORD PTR _buf$[esp+1156]
	push	OFFSET ??_C@_02DJGKEECL@?4?4?$AA@
	push	edx
	call	?strchr@@YAPADPAD0@Z			; strchr
	mov	esi, eax

; 54   : 		
; 55   : 		if(*(x-2) == ':')

	lea	eax, DWORD PTR [esi-2]
	add	esp, 8
	cmp	BYTE PTR [eax], 58			; 0000003aH
	je	$LN15@DebugValid

; 58   : 			return false;
; 59   : 		}
; 60   : 
; 61   : 		if(*(x-1) != '/' || *(x+2) != '/' && *(x+3) != '\0')

	cmp	BYTE PTR [esi-1], bl
	jne	SHORT $LN3@DebugValid
	cmp	BYTE PTR [esi+2], bl
	je	SHORT $LN6@DebugValid
	cmp	BYTE PTR [esi+3], 0
	jne	SHORT $LN3@DebugValid
$LN6@DebugValid:

; 62   : 			continue;
; 63   : 
; 64   : 		char* y = strchr(buf,(x-2),'/');

	push	ebx
	push	eax
	lea	eax, DWORD PTR _buf$[esp+1164]
	push	eax
	call	?strchr@@YAPADPAD0D@Z			; strchr
	add	esp, 12					; 0000000cH

; 65   : 		
; 66   : 		if(*(x+3) == '\0')

	cmp	BYTE PTR [esi+3], 0
	jne	SHORT $LN4@DebugValid

; 67   : 			strrem(y + 1,(uint32_t)(x + 1 - y));

	sub	esi, eax
	inc	esi
	inc	eax

; 68   : 		else

	jmp	SHORT $LN16@DebugValid
$LN4@DebugValid:

; 69   : 			strrem(y,(uint32_t)(x + 2 - y));

	sub	esi, eax
	add	esi, 2
$LN16@DebugValid:
	push	esi
	push	eax
	call	?strrem@@YAXPADI@Z			; strrem
	add	esp, 8
$LN3@DebugValid:
	lea	ecx, DWORD PTR _buf$[esp+1156]
	push	OFFSET ??_C@_02DJGKEECL@?4?4?$AA@
	push	ecx
	call	?strchr@@YAPADPAD0@Z			; strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL9@DebugValid
$LN8@DebugValid:
	push	edi

; 70   : 	}
; 71   : 
; 72   : 	strcpy(path,buf);

	lea	eax, DWORD PTR _buf$[esp+1160]
	push	eax
	push	ebp
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 73   : 	FILE file = volOpenFile(path);

	lea	ecx, DWORD PTR $T3259[esp+1168]
	push	ebp
	push	ecx
	call	?volOpenFile@@YA?AU_FILE@@PBD@Z		; volOpenFile
	mov	ecx, 15					; 0000000fH
	mov	esi, eax
	lea	edi, DWORD PTR _file$[esp+1176]
	add	esp, 16					; 00000010H
	rep movsd

; 74   : 
; 75   : 	if(file.flags == FS_DIRECTORY)

	cmp	DWORD PTR _file$[esp+1192], 1
	pop	edi
	jne	SHORT $LN2@DebugValid
$LN17@DebugValid:
	pop	esi
	pop	ebp

; 76   : 		return true;

	mov	al, 1
	pop	ebx

; 82   : }

	add	esp, 1144				; 00000478H
	ret	0
$LN15@DebugValid:

; 56   : 		{
; 57   : 			strcpy(path,buf);

	lea	edx, DWORD PTR _buf$[esp+1156]
	push	edx
	push	ebp
	call	?strcpy@@YAPADPADPBD@Z			; strcpy
	add	esp, 8
	pop	esi
	pop	ebp

; 80   : 
; 81   : 	return false;

	xor	al, al
	pop	ebx

; 82   : }

	add	esp, 1144				; 00000478H
	ret	0
$LN2@DebugValid:

; 77   : 
; 78   : 	if(strchr(path,":/") && strlen(path) == 4)

	push	OFFSET ??_C@_02DLFOHOMG@?3?1?$AA@
	push	ebp
	call	?strchr@@YAPADPAD0@Z			; strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@DebugValid
	push	ebp
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	cmp	eax, 4

; 79   : 		return true;

	je	SHORT $LN17@DebugValid
$LN1@DebugValid:
	pop	esi
	pop	ebp

; 80   : 
; 81   : 	return false;

	xor	al, al
	pop	ebx

; 82   : }

	add	esp, 1144				; 00000478H
	ret	0
?DebugValidateParsePath@@YA_NPAD@Z ENDP			; DebugValidateParsePath
_TEXT	ENDS
PUBLIC	??_C@_0BO@LDGEPHDD@?6?6Press?5any?5key?5to?5continue?6?6?$AA@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	?DebugReadFile@@YA_NPAD@Z			; DebugReadFile
EXTRN	?getchar@@YADXZ:PROC				; getchar
EXTRN	?DebugPutc@@YAXE@Z:PROC				; DebugPutc
EXTRN	?volReadFile@@YAXPAU_FILE@@PAEI@Z:PROC		; volReadFile
;	COMDAT ??_C@_0BO@LDGEPHDD@?6?6Press?5any?5key?5to?5continue?6?6?$AA@
CONST	SEGMENT
??_C@_0BO@LDGEPHDD@?6?6Press?5any?5key?5to?5continue?6?6?$AA@ DB 0aH, 0aH
	DB	'Press any key to continue', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?DebugReadFile@@YA_NPAD@Z
_TEXT	SEGMENT
_file$ = -1144						; size = 60
$T3268 = -1084						; size = 60
_buf$3137 = -1024					; size = 512
_buf$3128 = -1024					; size = 1024
_path$ = 8						; size = 4
?DebugReadFile@@YA_NPAD@Z PROC				; DebugReadFile, COMDAT

; 156  : {

	sub	esp, 1144				; 00000478H
	push	esi

; 157  : 	if(!strchr(path,':'))

	mov	esi, DWORD PTR _path$[esp+1144]
	push	58					; 0000003aH
	push	esi
	call	?strchr@@YAPADPADD@Z			; strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@DebugReadF

; 158  : 	{
; 159  : 		char buf[1024];
; 160  : 		strcpy(buf,currentDir);

	lea	eax, DWORD PTR _buf$3128[esp+1148]
	push	OFFSET ?currentDir@@3PADA		; currentDir
	push	eax
	call	?strcpy@@YAPADPADPBD@Z			; strcpy
	add	esp, 8

; 161  : 		strcpy((char*)(buf + strlen(buf) - 1),path);

	lea	ecx, DWORD PTR _buf$3128[esp+1148]
	push	esi
	push	ecx
	call	?strlen@@YAIPBD@Z			; strlen
	lea	edx, DWORD PTR _buf$3128[esp+1156]
	dec	edx
	add	eax, edx
	add	esp, 4
	push	eax
	call	?strcpy@@YAPADPADPBD@Z			; strcpy
	add	esp, 8

; 162  : 		path = buf;

	lea	esi, DWORD PTR _buf$3128[esp+1148]
$LN11@DebugReadF:
	push	edi

; 163  : 	}
; 164  : 
; 165  : 	FILE file = volOpenFile(path);

	lea	eax, DWORD PTR $T3268[esp+1152]
	push	esi
	push	eax
	call	?volOpenFile@@YA?AU_FILE@@PBD@Z		; volOpenFile
	mov	esi, eax
	mov	ecx, 15					; 0000000fH
	lea	edi, DWORD PTR _file$[esp+1160]
	rep movsd

; 166  : 
; 167  : 	if(file.flags == FS_INVALID)

	mov	eax, DWORD PTR _file$[esp+1192]
	add	esp, 8
	pop	edi
	cmp	eax, 2
	jne	SHORT $LN10@DebugReadF
$LN19@DebugReadF:

; 168  : 		return false;

	xor	al, al
	pop	esi

; 192  : }

	add	esp, 1144				; 00000478H
	ret	0
$LN10@DebugReadF:

; 169  : 
; 170  : 	if((file.flags & FS_DIRECTORY) == FS_DIRECTORY)

	test	al, 1

; 171  : 		return false;

	jne	SHORT $LN19@DebugReadF

; 172  : 
; 173  : 	DebugPuts("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 4

; 174  : 
; 175  : 	while(!file.eof)

	cmp	DWORD PTR _file$[esp+1192], 0
	jne	SHORT $LN18@DebugReadF
	npad	4
$LL8@DebugReadF:

; 176  : 	{
; 177  : 		unsigned char buf[512];
; 178  : 
; 179  : 		volReadFile(&file,buf,512);

	push	512					; 00000200H
	lea	ecx, DWORD PTR _buf$3137[esp+1152]
	push	ecx
	lea	edx, DWORD PTR _file$[esp+1156]
	push	edx
	call	?volReadFile@@YAXPAU_FILE@@PAEI@Z	; volReadFile
	add	esp, 12					; 0000000cH

; 180  : 
; 181  : 		for(int i = 0;i < 512;i++)

	xor	esi, esi
	npad	4
$LL6@DebugReadF:

; 182  : 			DebugPutc(buf[i]);

	movzx	eax, BYTE PTR _buf$3137[esp+esi+1148]
	push	eax
	call	?DebugPutc@@YAXE@Z			; DebugPutc
	inc	esi
	add	esp, 4
	cmp	esi, 512				; 00000200H
	jl	SHORT $LL6@DebugReadF

; 183  : 
; 184  : 		if(!file.eof)

	cmp	DWORD PTR _file$[esp+1192], 0
	jne	SHORT $LN18@DebugReadF

; 185  : 		{
; 186  : 			DebugPuts("\n\nPress any key to continue\n\n");

	push	OFFSET ??_C@_0BO@LDGEPHDD@?6?6Press?5any?5key?5to?5continue?6?6?$AA@
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 4
	npad	5
$LL2@DebugReadF:

; 187  : 			while(getchar() == 0);

	call	?getchar@@YADXZ				; getchar
	test	al, al
	je	SHORT $LL2@DebugReadF

; 174  : 
; 175  : 	while(!file.eof)

	cmp	DWORD PTR _file$[esp+1192], 0
	je	SHORT $LL8@DebugReadF
$LN18@DebugReadF:

; 188  : 		}
; 189  : 	}
; 190  : 
; 191  : 	return true;

	mov	al, 1
	pop	esi

; 192  : }

	add	esp, 1144				; 00000478H
	ret	0
?DebugReadFile@@YA_NPAD@Z ENDP				; DebugReadFile
_TEXT	ENDS
PUBLIC	?DebugGetNextCommand@@YAXPADI@Z			; DebugGetNextCommand
EXTRN	?kybrd_key_to_ascii@@YADW4KEYCODE@@@Z:PROC	; kybrd_key_to_ascii
EXTRN	?DebugGetHorz@@YAHXZ:PROC			; DebugGetHorz
EXTRN	?DebugGotoXY@@YAXII@Z:PROC			; DebugGotoXY
EXTRN	?DebugGetXY@@YAXPAI0@Z:PROC			; DebugGetXY
EXTRN	?getkey@@YA?AW4KEYCODE@@XZ:PROC			; getkey
; Function compile flags: /Ogtpy
;	COMDAT ?DebugGetNextCommand@@YAXPADI@Z
_TEXT	SEGMENT
_c$3168 = -4						; size = 1
_x$3163 = 8						; size = 4
_buf$ = 8						; size = 4
_y$3164 = 12						; size = 4
_len$ = 12						; size = 4
?DebugGetNextCommand@@YAXPADI@Z PROC			; DebugGetNextCommand, COMDAT

; 195  : {

	push	ecx
	push	ebp

; 196  : 	KEYCODE key = KEY_UNKNOWN;
; 197  : 	bool BufChar;
; 198  : 
; 199  : 	uint32_t i = 0;
; 200  : 	while(i < len)

	mov	ebp, DWORD PTR _len$[esp+4]
	push	esi
	xor	esi, esi
	push	edi
	mov	edi, DWORD PTR _buf$[esp+12]
	test	ebp, ebp
	jbe	$LN17@DebugGetNe
	push	ebx
$LL12@DebugGetNe:

; 201  : 	{
; 202  : 		key = getkey();

	call	?getkey@@YA?AW4KEYCODE@@XZ		; getkey

; 203  : 		BufChar = true;
; 204  : 
; 205  : 		while(key == KEY_UNKNOWN)

	cmp	eax, 16425				; 00004029H
	jne	SHORT $LN9@DebugGetNe
$LL10@DebugGetNe:

; 206  : 			key = getkey();

	call	?getkey@@YA?AW4KEYCODE@@XZ		; getkey
	cmp	eax, 16425				; 00004029H
	je	SHORT $LL10@DebugGetNe
$LN9@DebugGetNe:

; 207  : 
; 208  : 		if(key == KEY_RETURN || key == KEY_KP_ENTER)

	cmp	eax, 13					; 0000000dH
	je	$LN22@DebugGetNe
	cmp	eax, 12304				; 00003010H
	je	$LN22@DebugGetNe

; 209  : 			break;
; 210  : 
; 211  : 		if(key == KEY_BACKSPACE)

	cmp	eax, 8
	jne	SHORT $LN19@DebugGetNe

; 212  : 		{
; 213  : 			BufChar = false;
; 214  : 
; 215  : 			if(i > 0)

	test	esi, esi
	jbe	SHORT $LN20@DebugGetNe

; 216  : 			{
; 217  : 				unsigned int x,y;
; 218  : 				DebugGetXY(&x,&y);

	lea	eax, DWORD PTR _y$3164[esp+16]
	push	eax
	lea	ecx, DWORD PTR _x$3163[esp+20]
	push	ecx
	call	?DebugGetXY@@YAXPAI0@Z			; DebugGetXY

; 219  : 
; 220  : 				if(x > 0)

	mov	eax, DWORD PTR _x$3163[esp+24]
	add	esp, 8
	test	eax, eax
	jbe	SHORT $LN4@DebugGetNe

; 221  : 					DebugGotoXY(--x,y);

	mov	edx, DWORD PTR _y$3164[esp+16]
	dec	eax
	push	edx
	push	eax
	mov	DWORD PTR _x$3163[esp+24], eax
	call	?DebugGotoXY@@YAXII@Z			; DebugGotoXY
	add	esp, 8

; 222  : 				else

	jmp	SHORT $LN3@DebugGetNe
$LN4@DebugGetNe:

; 223  : 				{
; 224  : 					y--;

	dec	DWORD PTR _y$3164[esp+16]

; 225  : 					x = DebugGetHorz() - 1;

	call	?DebugGetHorz@@YAHXZ			; DebugGetHorz
	dec	eax
	mov	DWORD PTR _x$3163[esp+16], eax
$LN3@DebugGetNe:

; 226  : 				}
; 227  : 
; 228  : 				DebugPutc(' ');

	push	32					; 00000020H
	call	?DebugPutc@@YAXE@Z			; DebugPutc

; 229  : 				DebugGotoXY(x,y);

	mov	eax, DWORD PTR _y$3164[esp+20]
	mov	ecx, DWORD PTR _x$3163[esp+20]
	push	eax
	push	ecx
	call	?DebugGotoXY@@YAXII@Z			; DebugGotoXY
	add	esp, 12					; 0000000cH

; 230  : 				i--;

	dec	esi

; 231  : 			}
; 232  : 		}
; 233  : 
; 234  : 		if(BufChar)

	jmp	SHORT $LN20@DebugGetNe
$LN19@DebugGetNe:

; 235  : 		{
; 236  : 			char c = kybrd_key_to_ascii(key);

	push	eax
	call	?kybrd_key_to_ascii@@YADW4KEYCODE@@@Z	; kybrd_key_to_ascii
	mov	bl, al
	add	esp, 4
	mov	BYTE PTR _c$3168[esp+20], bl

; 237  : 
; 238  : 			if(c)

	test	bl, bl
	je	SHORT $LN20@DebugGetNe

; 239  : 			{
; 240  : 				DebugPutc(c);

	mov	edx, DWORD PTR _c$3168[esp+20]
	push	edx
	call	?DebugPutc@@YAXE@Z			; DebugPutc
	add	esp, 4

; 241  : 				buf[i++] = c;

	mov	BYTE PTR [esi+edi], bl
	inc	esi
$LN20@DebugGetNe:

; 196  : 	KEYCODE key = KEY_UNKNOWN;
; 197  : 	bool BufChar;
; 198  : 
; 199  : 	uint32_t i = 0;
; 200  : 	while(i < len)

	cmp	esi, ebp
	jb	$LL12@DebugGetNe
$LN22@DebugGetNe:
	pop	ebx
$LN17@DebugGetNe:

; 242  : 			}
; 243  : 		}
; 244  : 	}
; 245  : 
; 246  : 	buf[i] = '\0';
; 247  : 	DebugPutc('\n');

	push	10					; 0000000aH
	mov	BYTE PTR [esi+edi], 0
	call	?DebugPutc@@YAXE@Z			; DebugPutc
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp

; 248  : 
; 249  : 	return;
; 250  : }

	pop	ecx
	ret	0
?DebugGetNextCommand@@YAXPADI@Z ENDP			; DebugGetNextCommand
_TEXT	ENDS
PUBLIC	??_C@_0BK@ENBPKOMO@?6?$CFs?5is?5not?5a?5valid?5path?4?6?$AA@ ; `string'
PUBLIC	??_C@_02EMOMLIEG@?6?$DO?$AA@			; `string'
PUBLIC	?DebugSetCD@@YAXXZ				; DebugSetCD
EXTRN	?DebugPrintf@@YAHPBDZZ:PROC			; DebugPrintf
;	COMDAT ??_C@_0BK@ENBPKOMO@?6?$CFs?5is?5not?5a?5valid?5path?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@ENBPKOMO@?6?$CFs?5is?5not?5a?5valid?5path?4?6?$AA@ DB 0aH, '%s '
	DB	'is not a valid path.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02EMOMLIEG@?6?$DO?$AA@
CONST	SEGMENT
??_C@_02EMOMLIEG@?6?$DO?$AA@ DB 0aH, '>', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?DebugSetCD@@YAXXZ
_TEXT	SEGMENT
_buf$ = -2048						; size = 1024
_buff$3090 = -1024					; size = 1024
?DebugSetCD@@YAXXZ PROC					; DebugSetCD, COMDAT

; 85   : {

	sub	esp, 2048				; 00000800H

; 86   : 	char buf[1024];
; 87   : 	DebugPuts("\n>");

	push	OFFSET ??_C@_02EMOMLIEG@?6?$DO?$AA@
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 88   : 	DebugGetNextCommand(buf,1024);

	lea	eax, DWORD PTR _buf$[esp+2052]
	push	1024					; 00000400H
	push	eax
	call	?DebugGetNextCommand@@YAXPADI@Z		; DebugGetNextCommand

; 89   : 
; 90   : 	if(!strchr(buf,':'))

	lea	ecx, DWORD PTR _buf$[esp+2060]
	push	58					; 0000003aH
	push	ecx
	call	?strchr@@YAPADPADD@Z			; strchr
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN4@DebugSetCD

; 91   : 	{
; 92   : 		char buff[1024];
; 93   : 		strcpy(buff,currentDir);

	lea	edx, DWORD PTR _buff$3090[esp+2048]
	push	OFFSET ?currentDir@@3PADA		; currentDir
	push	edx
	call	?strcpy@@YAPADPADPBD@Z			; strcpy
	add	esp, 8

; 94   : 		strcpy((char*)(buff + strlen(buff) - 1),buf);

	lea	eax, DWORD PTR _buf$[esp+2048]
	push	eax
	lea	ecx, DWORD PTR _buff$3090[esp+2052]
	push	ecx
	call	?strlen@@YAIPBD@Z			; strlen
	lea	edx, DWORD PTR _buff$3090[esp+eax+2055]
	add	esp, 4
	push	edx
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 95   : 		strcpy(buf,buff);

	lea	eax, DWORD PTR _buff$3090[esp+2056]
	push	eax
	lea	ecx, DWORD PTR _buf$[esp+2060]
	push	ecx
	call	?strcpy@@YAPADPADPBD@Z			; strcpy
	add	esp, 16					; 00000010H
$LN4@DebugSetCD:

; 96   : 	}
; 97   : 	
; 98   : 	if(DebugValidateParsePath(buf))

	lea	edx, DWORD PTR _buf$[esp+2048]
	push	edx
	call	?DebugValidateParsePath@@YA_NPAD@Z	; DebugValidateParsePath
	add	esp, 4
	test	al, al
	je	SHORT $LN3@DebugSetCD

; 99   : 		strcpy(currentDir,buf);

	lea	eax, DWORD PTR _buf$[esp+2048]
	push	eax
	push	OFFSET ?currentDir@@3PADA		; currentDir
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 103  : 		return;
; 104  : 	}
; 105  : 
; 106  : 	char* temp = strchr(currentDir,'\0');

	push	0
	push	OFFSET ?currentDir@@3PADA		; currentDir
	call	?strchr@@YAPADPADD@Z			; strchr
	add	esp, 16					; 00000010H

; 107  : 
; 108  : 	if(*(temp - 1) != '/')

	cmp	BYTE PTR [eax-1], 47			; 0000002fH
	je	SHORT $LN1@DebugSetCD

; 109  : 	{
; 110  : 		*temp = '/';

	mov	BYTE PTR [eax], 47			; 0000002fH

; 111  : 		*(temp + 1) = '\0';

	mov	BYTE PTR [eax+1], 0

; 112  : 	}
; 113  : 
; 114  : 	return;
; 115  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN3@DebugSetCD:

; 100  : 	else
; 101  : 	{
; 102  : 		DebugPrintf("\n%s is not a valid path.\n",buf);

	lea	ecx, DWORD PTR _buf$[esp+2048]
	push	ecx
	push	OFFSET ??_C@_0BK@ENBPKOMO@?6?$CFs?5is?5not?5a?5valid?5path?4?6?$AA@
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf
	add	esp, 8
$LN1@DebugSetCD:

; 112  : 	}
; 113  : 
; 114  : 	return;
; 115  : }

	add	esp, 2048				; 00000800H
	ret	0
?DebugSetCD@@YAXXZ ENDP					; DebugSetCD
_TEXT	ENDS
PUBLIC	??_C@_0BL@GLNBAAPK@?6Error?5reading?5foppy?5disk?4?$AA@ ; `string'
PUBLIC	??_C@_05ODCCPGFJ@0x?$CFX?5?$AA@			; `string'
PUBLIC	??_C@_0BH@LNAGKPNN@Sector?3?5?$CFi?5Contains?3?6?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@HEJAOKNI@?6Enter?5the?5sector?5to?5be?5read?$DO?$AA@ ; `string'
PUBLIC	?DebugReadSector@@YAXXZ				; DebugReadSector
EXTRN	?flpydsk_read_sector@@YAPAEH@Z:PROC		; flpydsk_read_sector
EXTRN	?atoi@@YAHPBD@Z:PROC				; atoi
;	COMDAT ??_C@_0BL@GLNBAAPK@?6Error?5reading?5foppy?5disk?4?$AA@
CONST	SEGMENT
??_C@_0BL@GLNBAAPK@?6Error?5reading?5foppy?5disk?4?$AA@ DB 0aH, 'Error re'
	DB	'ading foppy disk.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05ODCCPGFJ@0x?$CFX?5?$AA@
CONST	SEGMENT
??_C@_05ODCCPGFJ@0x?$CFX?5?$AA@ DB '0x%X ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LNAGKPNN@Sector?3?5?$CFi?5Contains?3?6?6?$AA@
CONST	SEGMENT
??_C@_0BH@LNAGKPNN@Sector?3?5?$CFi?5Contains?3?6?6?$AA@ DB 'Sector: %i Co'
	DB	'ntains:', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HEJAOKNI@?6Enter?5the?5sector?5to?5be?5read?$DO?$AA@
CONST	SEGMENT
??_C@_0BO@HEJAOKNI@?6Enter?5the?5sector?5to?5be?5read?$DO?$AA@ DB 0aH, 'E'
	DB	'nter the sector to be read>', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?DebugReadSector@@YAXXZ
_TEXT	SEGMENT
_sectornumbuf$ = -8					; size = 6
?DebugReadSector@@YAXXZ PROC				; DebugReadSector, COMDAT

; 118  : {

	sub	esp, 8
	push	esi

; 119  : 	uint32_t sectornum = 0;
; 120  : 	char sectornumbuf[6];
; 121  : 	uint8_t* sector = 0;
; 122  : 
; 123  : 	DebugPrintf("\nEnter the sector to be read>");

	push	OFFSET ??_C@_0BO@HEJAOKNI@?6Enter?5the?5sector?5to?5be?5read?$DO?$AA@
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf

; 124  : 	DebugGetNextCommand(sectornumbuf,5);

	lea	eax, DWORD PTR _sectornumbuf$[esp+16]
	push	5
	push	eax
	call	?DebugGetNextCommand@@YAXPADI@Z		; DebugGetNextCommand

; 125  : 	sectornum = atoi(sectornumbuf);

	lea	ecx, DWORD PTR _sectornumbuf$[esp+24]
	push	ecx
	call	?atoi@@YAHPBD@Z				; atoi
	mov	esi, eax

; 126  : 
; 127  : 	DebugPrintf("Sector: %i Contains:\n\n",sectornum);

	push	esi
	push	OFFSET ??_C@_0BH@LNAGKPNN@Sector?3?5?$CFi?5Contains?3?6?6?$AA@
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf

; 128  : 
; 129  : 	sector = flpydsk_read_sector(sectornum);

	push	esi
	call	?flpydsk_read_sector@@YAPAEH@Z		; flpydsk_read_sector
	add	esp, 28					; 0000001cH

; 130  : 
; 131  : 	if(sector != 0)

	test	eax, eax
	je	SHORT $LN12@DebugReadS
	push	ebx
	push	edi

; 132  : 	{
; 133  : 		for(int c = 0,i = 0;c < 4;c++,i += 128)

	xor	ebx, ebx
	mov	edi, eax
$LL11@DebugReadS:

; 134  : 		{
; 135  : 			for(int j = 0;j < 128;j++)

	xor	esi, esi
$LL8@DebugReadS:

; 136  : 				DebugPrintf("0x%X ",sector[i+j]);

	movzx	edx, BYTE PTR [edi+esi]
	push	edx
	push	OFFSET ??_C@_05ODCCPGFJ@0x?$CFX?5?$AA@
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf
	inc	esi
	add	esp, 8
	cmp	esi, 128				; 00000080H
	jl	SHORT $LL8@DebugReadS

; 137  : 
; 138  : 			if(c < 3)

	cmp	ebx, 3
	jge	SHORT $LN5@DebugReadS

; 139  : 			{
; 140  : 				DebugPuts("\n\nPress any key to continue\n\n");

	push	OFFSET ??_C@_0BO@LDGEPHDD@?6?6Press?5any?5key?5to?5continue?6?6?$AA@
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 4
$LL4@DebugReadS:

; 141  : 				while(getchar() == 0);

	call	?getchar@@YADXZ				; getchar
	test	al, al
	je	SHORT $LL4@DebugReadS

; 142  : 			}
; 143  : 			else

	jmp	SHORT $LN10@DebugReadS
$LN5@DebugReadS:

; 144  : 				DebugPutc('\n');

	push	10					; 0000000aH
	call	?DebugPutc@@YAXE@Z			; DebugPutc
	add	esp, 4
$LN10@DebugReadS:
	inc	ebx
	sub	edi, -128				; ffffff80H
	cmp	ebx, 4
	jl	SHORT $LL11@DebugReadS
	pop	edi
	pop	ebx

; 149  : 
; 150  : 	DebugPrintf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf
	add	esp, 4
	pop	esi

; 151  : 
; 152  : 	return;
; 153  : }

	add	esp, 8
	ret	0
$LN12@DebugReadS:

; 145  : 		}
; 146  : 	}
; 147  : 	else
; 148  : 		DebugPrintf("\nError reading foppy disk.");

	push	OFFSET ??_C@_0BL@GLNBAAPK@?6Error?5reading?5foppy?5disk?4?$AA@
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf
	add	esp, 4

; 149  : 
; 150  : 	DebugPrintf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf
	add	esp, 4
	pop	esi

; 151  : 
; 152  : 	return;
; 153  : }

	add	esp, 8
	ret	0
?DebugReadSector@@YAXXZ ENDP				; DebugReadSector
_TEXT	ENDS
PUBLIC	??_C@_0BJ@KDIJCELF@No?5such?5file?5was?5found?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@MJNKKBLH@?6?6?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9EOF?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	??_C@_07HLHKOGJG@readsec?$AA@			; `string'
PUBLIC	??_C@_05CFMALAOA@reset?$AA@			; `string'
PUBLIC	??_C@_02PHMGELLB@?6?6?$AA@			; `string'
PUBLIC	??_C@_0CF@HPDNMG@?6exit?5?5?5?5?9?5Exits?5the?5command?5pro@ ; `string'
PUBLIC	??_C@_0CA@LKKCPFKB@?6reset?5?5?5?9?5Resets?5the?5computer?4?$AA@ ; `string'
PUBLIC	??_C@_0EI@JNABAENF@?6readsec?5?9?5Reads?5a?5sector?5from?5t@ ; `string'
PUBLIC	??_C@_0DI@EBLKOIL@?6help?5?5?5?5?9?5Displays?5the?5list?5of?5@ ; `string'
PUBLIC	??_C@_0CM@OKABKEK@?6cls?5?5?5?5?5?9?5Clears?5the?5screen?5of?5@ ; `string'
PUBLIC	??_C@_0CI@EALPGAAC@cd?5?5?5?5?5?5?5?5?9?5Sets?5the?5current?5dir@ ; `string'
PUBLIC	??_C@_04PCJFHION@help?$AA@			; `string'
PUBLIC	??_C@_03LCPHGAHP@cls?$AA@			; `string'
PUBLIC	??_C@_02ELLOPNDH@cd?$AA@			; `string'
PUBLIC	??_C@_04MKNBDEPB@exit?$AA@			; `string'
PUBLIC	?DebugRunCommand@@YA_NPAD@Z			; DebugRunCommand
EXTRN	?kybrd_reset_system@@YAXXZ:PROC			; kybrd_reset_system
EXTRN	?DebugClrScr@@YAXG@Z:PROC			; DebugClrScr
EXTRN	?strcmp@@YAHPBD0@Z:PROC				; strcmp
;	COMDAT ??_C@_0BJ@KDIJCELF@No?5such?5file?5was?5found?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@KDIJCELF@No?5such?5file?5was?5found?4?6?$AA@ DB 'No such file w'
	DB	'as found.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MJNKKBLH@?6?6?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9EOF?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT
??_C@_0CF@MJNKKBLH@?6?6?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9EOF?9?9?9?9?9?9?9?9?9?9?9?9@ DB 0aH
	DB	0aH, '---------------EOF---------------', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HLHKOGJG@readsec?$AA@
CONST	SEGMENT
??_C@_07HLHKOGJG@readsec?$AA@ DB 'readsec', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFMALAOA@reset?$AA@
CONST	SEGMENT
??_C@_05CFMALAOA@reset?$AA@ DB 'reset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02PHMGELLB@?6?6?$AA@
CONST	SEGMENT
??_C@_02PHMGELLB@?6?6?$AA@ DB 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HPDNMG@?6exit?5?5?5?5?9?5Exits?5the?5command?5pro@
CONST	SEGMENT
??_C@_0CF@HPDNMG@?6exit?5?5?5?5?9?5Exits?5the?5command?5pro@ DB 0aH, 'exi'
	DB	't    - Exits the command prompt.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LKKCPFKB@?6reset?5?5?5?9?5Resets?5the?5computer?4?$AA@
CONST	SEGMENT
??_C@_0CA@LKKCPFKB@?6reset?5?5?5?9?5Resets?5the?5computer?4?$AA@ DB 0aH, 'r'
	DB	'eset   - Resets the computer.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@JNABAENF@?6readsec?5?9?5Reads?5a?5sector?5from?5t@
CONST	SEGMENT
??_C@_0EI@JNABAENF@?6readsec?5?9?5Reads?5a?5sector?5from?5t@ DB 0aH, 'rea'
	DB	'dsec - Reads a sector from the floppy drive and displays it i'
	DB	'n hex.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@EBLKOIL@?6help?5?5?5?5?9?5Displays?5the?5list?5of?5@
CONST	SEGMENT
??_C@_0DI@EBLKOIL@?6help?5?5?5?5?9?5Displays?5the?5list?5of?5@ DB 0aH, 'h'
	DB	'elp    - Displays the list of all supported commands.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OKABKEK@?6cls?5?5?5?5?5?9?5Clears?5the?5screen?5of?5@
CONST	SEGMENT
??_C@_0CM@OKABKEK@?6cls?5?5?5?5?5?9?5Clears?5the?5screen?5of?5@ DB 0aH, 'c'
	DB	'ls     - Clears the screen of all output.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EALPGAAC@cd?5?5?5?5?5?5?5?5?9?5Sets?5the?5current?5dir@
CONST	SEGMENT
??_C@_0CI@EALPGAAC@cd?5?5?5?5?5?5?5?5?9?5Sets?5the?5current?5dir@ DB 'cd '
	DB	'       - Sets the current directory.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJFHION@help?$AA@
CONST	SEGMENT
??_C@_04PCJFHION@help?$AA@ DB 'help', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LCPHGAHP@cls?$AA@
CONST	SEGMENT
??_C@_03LCPHGAHP@cls?$AA@ DB 'cls', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ELLOPNDH@cd?$AA@
CONST	SEGMENT
??_C@_02ELLOPNDH@cd?$AA@ DB 'cd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKNBDEPB@exit?$AA@
CONST	SEGMENT
??_C@_04MKNBDEPB@exit?$AA@ DB 'exit', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?DebugRunCommand@@YA_NPAD@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
?DebugRunCommand@@YA_NPAD@Z PROC			; DebugRunCommand, COMDAT

; 253  : {

	push	esi

; 254  : 	if(strcmp(buf,"exit") == 0)

	mov	esi, DWORD PTR _buf$[esp]
	push	OFFSET ??_C@_04MKNBDEPB@exit?$AA@
	push	esi
	call	?strcmp@@YAHPBD0@Z			; strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@DebugRunCo

; 255  : 		return true;

	mov	al, 1
	pop	esi

; 280  : }

	ret	0
$LN14@DebugRunCo:

; 256  : 	else if(strcmp(buf,"cd") == 0)

	push	OFFSET ??_C@_02ELLOPNDH@cd?$AA@
	push	esi
	call	?strcmp@@YAHPBD0@Z			; strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@DebugRunCo

; 257  : 		DebugSetCD();

	call	?DebugSetCD@@YAXXZ			; DebugSetCD

; 278  : 
; 279  : 	return false;

	xor	al, al
	pop	esi

; 280  : }

	ret	0
$LN12@DebugRunCo:

; 258  : 	else if(strcmp(buf,"cls") == 0)

	push	OFFSET ??_C@_03LCPHGAHP@cls?$AA@
	push	esi
	call	?strcmp@@YAHPBD0@Z			; strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@DebugRunCo

; 259  : 		DebugClrScr(33);

	push	33					; 00000021H
	call	?DebugClrScr@@YAXG@Z			; DebugClrScr

; 276  : 	else
; 277  : 		DebugPuts("No such file was found.\n");

	add	esp, 4

; 278  : 
; 279  : 	return false;

	xor	al, al
	pop	esi

; 280  : }

	ret	0
$LN10@DebugRunCo:

; 260  : 	else if(strcmp(buf,"help") == 0)

	push	OFFSET ??_C@_04PCJFHION@help?$AA@
	push	esi
	call	?strcmp@@YAHPBD0@Z			; strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@DebugRunCo

; 261  : 	{
; 262  : 		DebugPuts("cd        - Sets the current directory.");

	push	OFFSET ??_C@_0CI@EALPGAAC@cd?5?5?5?5?5?5?5?5?9?5Sets?5the?5current?5dir@
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 263  : 		DebugPuts("\ncls     - Clears the screen of all output.");

	push	OFFSET ??_C@_0CM@OKABKEK@?6cls?5?5?5?5?5?9?5Clears?5the?5screen?5of?5@
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 264  : 		DebugPuts("\nhelp    - Displays the list of all supported commands.");

	push	OFFSET ??_C@_0DI@EBLKOIL@?6help?5?5?5?5?9?5Displays?5the?5list?5of?5@
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 265  : 		DebugPuts("\nreadsec - Reads a sector from the floppy drive and displays it in hex.");

	push	OFFSET ??_C@_0EI@JNABAENF@?6readsec?5?9?5Reads?5a?5sector?5from?5t@
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 266  : 		DebugPuts("\nreset   - Resets the computer.");

	push	OFFSET ??_C@_0CA@LKKCPFKB@?6reset?5?5?5?9?5Resets?5the?5computer?4?$AA@
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 267  : 		DebugPuts("\nexit    - Exits the command prompt.");

	push	OFFSET ??_C@_0CF@HPDNMG@?6exit?5?5?5?5?9?5Exits?5the?5command?5pro@
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 268  : 		DebugPuts("\n\n");

	push	OFFSET ??_C@_02PHMGELLB@?6?6?$AA@
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 28					; 0000001cH

; 278  : 
; 279  : 	return false;

	xor	al, al
	pop	esi

; 280  : }

	ret	0
$LN8@DebugRunCo:

; 269  : 	}
; 270  : 	else if(strcmp(buf,"reset") == 0)

	push	OFFSET ??_C@_05CFMALAOA@reset?$AA@
	push	esi
	call	?strcmp@@YAHPBD0@Z			; strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@DebugRunCo

; 271  : 		kybrd_reset_system();

	call	?kybrd_reset_system@@YAXXZ		; kybrd_reset_system

; 278  : 
; 279  : 	return false;

	xor	al, al
	pop	esi

; 280  : }

	ret	0
$LN6@DebugRunCo:

; 272  : 	else if(strcmp(buf,"readsec") == 0)

	push	OFFSET ??_C@_07HLHKOGJG@readsec?$AA@
	push	esi
	call	?strcmp@@YAHPBD0@Z			; strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@DebugRunCo

; 273  : 		DebugReadSector();

	call	?DebugReadSector@@YAXXZ			; DebugReadSector

; 278  : 
; 279  : 	return false;

	xor	al, al
	pop	esi

; 280  : }

	ret	0
$LN4@DebugRunCo:

; 274  : 	else if(DebugReadFile(buf))

	push	esi
	call	?DebugReadFile@@YA_NPAD@Z		; DebugReadFile
	add	esp, 4
	test	al, al
	je	SHORT $LN2@DebugRunCo

; 275  : 		DebugPuts("\n\n---------------EOF---------------\n");

	push	OFFSET ??_C@_0CF@MJNKKBLH@?6?6?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9EOF?9?9?9?9?9?9?9?9?9?9?9?9@

; 276  : 	else
; 277  : 		DebugPuts("No such file was found.\n");

	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 4

; 278  : 
; 279  : 	return false;

	xor	al, al
	pop	esi

; 280  : }

	ret	0
$LN2@DebugRunCo:

; 276  : 	else
; 277  : 		DebugPuts("No such file was found.\n");

	push	OFFSET ??_C@_0BJ@KDIJCELF@No?5such?5file?5was?5found?4?6?$AA@
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 4

; 278  : 
; 279  : 	return false;

	xor	al, al
	pop	esi

; 280  : }

	ret	0
?DebugRunCommand@@YA_NPAD@Z ENDP			; DebugRunCommand
_TEXT	ENDS
PUBLIC	?DebugRuncmd@@YAXXZ				; DebugRuncmd
; Function compile flags: /Ogtpy
;	COMDAT ?DebugRuncmd@@YAXXZ
_TEXT	SEGMENT
_cmd_buf$ = -1024					; size = 1024
?DebugRuncmd@@YAXXZ PROC				; DebugRuncmd, COMDAT

; 283  : {

	sub	esp, 1024				; 00000400H

; 284  : 	char cmd_buf[1024];
; 285  : 	DebugcmdStart();

	push	OFFSET ??_C@_0DE@IHDDEGIG@Naomi?5OS?5debug?5command?5prompt?5?9?5@
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	push	OFFSET ??_C@_03GGMBOIKO@a?3?1?$AA@
	push	OFFSET ?currentDir@@3PADA		; currentDir
	call	?strcpy@@YAPADPADPBD@Z			; strcpy
	add	esp, 12					; 0000000cH
	mov	BYTE PTR ?currentDir@@3PADA+3, 0
	npad	7
$LL3@DebugRuncm:

; 286  : 
; 287  : 	while(true)
; 288  : 	{
; 289  : 		DebugcmdPrompt();

	push	OFFSET ?currentDir@@3PADA		; currentDir
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	push	OFFSET ??_C@_02LLMPMKNF@?$DO?5?$AA@
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 290  : 		DebugGetNextCommand(cmd_buf,1022);

	lea	eax, DWORD PTR _cmd_buf$[esp+1032]
	push	1022					; 000003feH
	push	eax
	call	?DebugGetNextCommand@@YAXPADI@Z		; DebugGetNextCommand

; 291  : 
; 292  : 		if(DebugRunCommand(cmd_buf))

	lea	ecx, DWORD PTR _cmd_buf$[esp+1040]
	push	ecx
	call	?DebugRunCommand@@YA_NPAD@Z		; DebugRunCommand
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LL3@DebugRuncm

; 293  : 			break;
; 294  : 	}
; 295  : 
; 296  : 	return;
; 297  : }

	add	esp, 1024				; 00000400H
	ret	0
?DebugRuncmd@@YAXXZ ENDP				; DebugRuncmd
_TEXT	ENDS
END
