; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\Users\The Science Guy\Documents\Visual Studio 2008\Projects\Naomi\Naomi\DebugDisplay.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?tbuf@@3PADA					; tbuf
PUBLIC	?video_memory@@3PAGA				; video_memory
PUBLIC	?cursor_x@@3EA					; cursor_x
PUBLIC	?cursor_y@@3EA					; cursor_y
PUBLIC	?_color@@3EA					; _color
PUBLIC	?bchars@@3PADA					; bchars
_BSS	SEGMENT
?tbuf@@3PADA DB	020H DUP (?)				; tbuf
?cursor_x@@3EA DB 01H DUP (?)				; cursor_x
	ALIGN	4

?cursor_y@@3EA DB 01H DUP (?)				; cursor_y
	ALIGN	4

?_color@@3EA DB	01H DUP (?)				; _color
_BSS	ENDS
_DATA	SEGMENT
?video_memory@@3PAGA DD 0b8000H				; video_memory
?bchars@@3PADA DB 030H					; bchars
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
_DATA	ENDS
PUBLIC	?DebugUpdateCur@@YAXHH@Z			; DebugUpdateCur
EXTRN	?outportb@@YAXGE@Z:PROC				; outportb
; Function compile flags: /Ogtpy
; File c:\users\the science guy\documents\visual studio 2008\projects\naomi\naomi\debugdisplay.cpp
;	COMDAT ?DebugUpdateCur@@YAXHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?DebugUpdateCur@@YAXHH@Z PROC				; DebugUpdateCur, COMDAT

; 25   : 	uint16_t cursorLocation = x + 80 * y;

	mov	eax, DWORD PTR _y$[esp-4]
	lea	eax, DWORD PTR [eax+eax*4]
	push	esi
	shl	eax, 4
	add	eax, DWORD PTR _x$[esp]

; 26   : 
; 27   : 	outportb(0x3D4,14);

	push	14					; 0000000eH
	push	980					; 000003d4H
	movzx	esi, ax
	call	?outportb@@YAXGE@Z			; outportb

; 28   : 	outportb(0x3D5,cursorLocation >> 8);

	mov	ecx, esi
	shr	ecx, 8
	push	ecx
	push	981					; 000003d5H
	call	?outportb@@YAXGE@Z			; outportb

; 29   : 	outportb(0x3D4,15);

	push	15					; 0000000fH
	push	980					; 000003d4H
	call	?outportb@@YAXGE@Z			; outportb

; 30   : 	outportb(0x3D5,cursorLocation);

	push	esi
	push	981					; 000003d5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 32					; 00000020H
	pop	esi

; 31   : 
; 32   : 	return;
; 33   : }

	ret	0
?DebugUpdateCur@@YAXHH@Z ENDP				; DebugUpdateCur
_TEXT	ENDS
PUBLIC	?Scroll@@YAXXZ					; Scroll
; Function compile flags: /Ogtpy
;	COMDAT ?Scroll@@YAXXZ
_TEXT	SEGMENT
?Scroll@@YAXXZ PROC					; Scroll, COMDAT

; 37   : 	uint16_t attribute = _color << 8;

	movzx	ax, BYTE PTR ?_color@@3EA		; _color
	shl	ax, 8
	movzx	edx, ax
	xor	eax, eax
	push	esi
$LL6@Scroll:

; 38   : 
; 39   : 	for(uint32_t i = 0;i < 24 * 80;i++)
; 40   : 		video_memory[i] = video_memory[i+80];

	mov	ecx, DWORD PTR ?video_memory@@3PAGA	; video_memory
	mov	si, WORD PTR [eax+ecx+160]
	mov	WORD PTR [eax+ecx], si
	add	eax, 2
	cmp	eax, 3840				; 00000f00H
	jb	SHORT $LL6@Scroll
	mov	ecx, edx
	or	ecx, 32					; 00000020H

; 41   : 
; 42   : 	for(uint32_t i = 24 * 80;i < 25 * 80;i++)

	mov	eax, 3840				; 00000f00H
	pop	esi
	npad	7
$LL3@Scroll:

; 43   : 		video_memory[i] = ' ' | attribute;

	mov	edx, DWORD PTR ?video_memory@@3PAGA	; video_memory
	mov	WORD PTR [eax+edx], cx
	add	eax, 2
	cmp	eax, 4000				; 00000fa0H
	jb	SHORT $LL3@Scroll

; 44   : 
; 45   : 	return;
; 46   : }

	ret	0
?Scroll@@YAXXZ ENDP					; Scroll
_TEXT	ENDS
PUBLIC	?DebugPutc@@YAXE@Z				; DebugPutc
; Function compile flags: /Ogtpy
;	COMDAT ?DebugPutc@@YAXE@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
?DebugPutc@@YAXE@Z PROC					; DebugPutc, COMDAT

; 50   : 	uint16_t attribute = _color << 8;

	movzx	ax, BYTE PTR ?_color@@3EA		; _color
	shl	ax, 8
	movzx	ecx, ax

; 51   : 
; 52   : 	if(c == 0x08 && cursor_x)

	mov	al, BYTE PTR _c$[esp-4]
	cmp	al, 8
	jne	SHORT $LN16@DebugPutc
	mov	al, BYTE PTR ?cursor_x@@3EA		; cursor_x
	test	al, al
	je	SHORT $LN3@DebugPutc

; 53   : 		cursor_x--;

	dec	al
	mov	BYTE PTR ?cursor_x@@3EA, al		; cursor_x
	jmp	SHORT $LN3@DebugPutc
$LN16@DebugPutc:

; 54   : 	else if(c == 0x09)

	cmp	al, 9
	jne	SHORT $LL11@DebugPutc

; 55   : 		cursor_x = (cursor_x+8) & ~(8-1);

	mov	al, BYTE PTR ?cursor_x@@3EA		; cursor_x
	add	al, 8
	and	al, 248					; 000000f8H
	mov	BYTE PTR ?cursor_x@@3EA, al		; cursor_x
	jmp	SHORT $LN3@DebugPutc
	npad	3
$LL11@DebugPutc:

; 56   : 	else if(c == '\t')
; 57   : 	{
; 58   : 		for(uint16_t i = 0;i < 3;i++)
; 59   : 			DebugPutc(' ');
; 60   : 	}
; 61   : 	else if(c == '\r')

	cmp	al, 13					; 0000000dH
	jne	SHORT $LN7@DebugPutc

; 62   : 		cursor_x = 0;

	xor	al, al
	jmp	SHORT $LN25@DebugPutc
$LN7@DebugPutc:

; 63   : 	else if(c == '\n')

	cmp	al, 10					; 0000000aH

; 64   : 	{
; 65   : 		cursor_x = 0;
; 66   : 		cursor_y++;

	je	SHORT $LN26@DebugPutc

; 67   : 	}
; 68   : 	else if(c >= ' ')

	cmp	al, 32					; 00000020H
	jb	SHORT $LN23@DebugPutc

; 69   : 	{
; 70   :         uint16_t* location = video_memory + (cursor_y * 80 + cursor_x);
; 71   : 		*location = c | attribute;

	movzx	dx, al
	movzx	eax, BYTE PTR ?cursor_y@@3EA		; cursor_y
	or	dx, cx
	movzx	ecx, BYTE PTR ?cursor_x@@3EA		; cursor_x
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 4
	add	eax, ecx
	mov	ecx, DWORD PTR ?video_memory@@3PAGA	; video_memory
	mov	WORD PTR [ecx+eax*2], dx

; 72   : 		cursor_x++;

	mov	al, BYTE PTR ?cursor_x@@3EA		; cursor_x
	inc	al
	mov	BYTE PTR ?cursor_x@@3EA, al		; cursor_x
	jmp	SHORT $LN3@DebugPutc
$LN23@DebugPutc:
	mov	al, BYTE PTR ?cursor_x@@3EA		; cursor_x
$LN3@DebugPutc:

; 73   : 	}
; 74   : 
; 75   : 	if (cursor_x >= 80)

	cmp	al, 80					; 00000050H
	jb	SHORT $LN24@DebugPutc
$LN26@DebugPutc:

; 76   : 	{
; 77   : 		cursor_x = 0;

	xor	al, al

; 78   : 		cursor_y++;

	inc	BYTE PTR ?cursor_y@@3EA			; cursor_y
$LN25@DebugPutc:

; 76   : 	{
; 77   : 		cursor_x = 0;

	mov	BYTE PTR ?cursor_x@@3EA, al		; cursor_x
$LN24@DebugPutc:

; 79   : 	}
; 80   : 
; 81   : 	if(cursor_y > 24)

	mov	cl, 24					; 00000018H
	cmp	BYTE PTR ?cursor_y@@3EA, cl		; cursor_y
	jbe	SHORT $LN1@DebugPutc

; 82   : 	{
; 83   : 		cursor_y = 24;

	mov	BYTE PTR ?cursor_y@@3EA, cl		; cursor_y

; 84   : 		Scroll();

	call	?Scroll@@YAXXZ				; Scroll
	mov	al, BYTE PTR ?cursor_x@@3EA		; cursor_x
$LN1@DebugPutc:

; 85   : 	}
; 86   : 
; 87   : 	DebugUpdateCur(cursor_x,cursor_y);

	movzx	dx, BYTE PTR ?cursor_y@@3EA		; cursor_y
	imul	dx, 80					; 00000050H
	push	esi
	movzx	ax, al
	add	dx, ax
	push	14					; 0000000eH
	push	980					; 000003d4H
	movzx	esi, dx
	call	?outportb@@YAXGE@Z			; outportb
	mov	ecx, esi
	shr	ecx, 8
	push	ecx
	push	981					; 000003d5H
	call	?outportb@@YAXGE@Z			; outportb
	push	15					; 0000000fH
	push	980					; 000003d4H
	call	?outportb@@YAXGE@Z			; outportb
	push	esi
	push	981					; 000003d5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 32					; 00000020H
	pop	esi

; 88   : }

	ret	0
?DebugPutc@@YAXE@Z ENDP					; DebugPutc
_TEXT	ENDS
PUBLIC	?itoa@@YAXIIPAD@Z				; itoa
; Function compile flags: /Ogtpy
;	COMDAT ?itoa@@YAXIIPAD@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_base$ = 12						; size = 4
_buf$ = 16						; size = 4
?itoa@@YAXIIPAD@Z PROC					; itoa, COMDAT

; 95   : 	int pos = 0;
; 96   : 	int opos = 0;
; 97   : 	int top = 0;
; 98   : 
; 99   : 	if(i == 0 || base > 16)

	mov	eax, DWORD PTR _i$[esp-4]
	xor	ecx, ecx
	push	esi
	test	eax, eax
	je	SHORT $LN6@itoa
	mov	esi, DWORD PTR _base$[esp]
	cmp	esi, 16					; 00000010H
	ja	SHORT $LN6@itoa
$LL5@itoa:

; 103  : 		return;
; 104  : 	}
; 105  : 
; 106  : 	while(i != 0)
; 107  : 	{
; 108  : 		tbuf[pos++] = bchars[i % base];

	xor	edx, edx
	div	esi
	inc	ecx
	mov	dl, BYTE PTR ?bchars@@3PADA[edx]
	mov	BYTE PTR ?tbuf@@3PADA[ecx-1], dl
	test	eax, eax
	jne	SHORT $LL5@itoa

; 109  : 		i /= base;
; 110  : 	}
; 111  :    
; 112  : 	top = pos--;

	mov	esi, ecx
	dec	ecx
	push	edi

; 113  : 
; 114  : 	for(opos = 0;opos < top;pos--,opos++)

	mov	edi, DWORD PTR _buf$[esp+4]
	test	esi, esi
	jle	SHORT $LN1@itoa

; 109  : 		i /= base;
; 110  : 	}
; 111  :    
; 112  : 	top = pos--;

	lea	ecx, DWORD PTR ?tbuf@@3PADA[ecx]
	npad	5
$LL3@itoa:

; 115  : 		buf[opos] = tbuf[pos];

	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+edi], dl
	inc	eax
	dec	ecx
	cmp	eax, esi
	jl	SHORT $LL3@itoa
$LN1@itoa:

; 116  : 
; 117  : 	buf[opos] = 0;

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi

; 118  : 
; 119  : 	return;
; 120  : }

	ret	0
$LN6@itoa:

; 100  : 		{
; 101  : 		buf[0] = '0';

	mov	eax, DWORD PTR _buf$[esp]
	mov	BYTE PTR [eax], 48			; 00000030H

; 102  : 		buf[1] = '\0';

	mov	BYTE PTR [eax+1], cl
	pop	esi

; 118  : 
; 119  : 	return;
; 120  : }

	ret	0
?itoa@@YAXIIPAD@Z ENDP					; itoa
_TEXT	ENDS
PUBLIC	?itoa_s@@YAXHIPAD@Z				; itoa_s
; Function compile flags: /Ogtpy
;	COMDAT ?itoa_s@@YAXHIPAD@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_base$ = 12						; size = 4
_buf$ = 16						; size = 4
?itoa_s@@YAXHIPAD@Z PROC				; itoa_s, COMDAT

; 124  : 	if(base > 16)

	mov	edx, DWORD PTR _base$[esp-4]
	cmp	edx, 16					; 00000010H
	ja	SHORT $LN3@itoa_s

; 125  : 		return;
; 126  : 
; 127  : 	if(i < 0)

	mov	eax, DWORD PTR _i$[esp-4]

; 128  : 	{
; 129  : 		*buf++ = '-';

	mov	ecx, DWORD PTR _buf$[esp-4]
	test	eax, eax
	jge	SHORT $LN1@itoa_s
	mov	BYTE PTR [ecx], 45			; 0000002dH
	inc	ecx

; 130  : 		i *= -1;

	neg	eax
$LN1@itoa_s:

; 131  : 	}
; 132  :    
; 133  : 	itoa(i,base,buf);

	mov	DWORD PTR _buf$[esp-4], ecx
	mov	DWORD PTR _base$[esp-4], edx
	mov	DWORD PTR _i$[esp-4], eax
	jmp	?itoa@@YAXIIPAD@Z			; itoa
$LN3@itoa_s:

; 134  : 	
; 135  : 	return;
; 136  : }

	ret	0
?itoa_s@@YAXHIPAD@Z ENDP				; itoa_s
_TEXT	ENDS
PUBLIC	?DebugSetColor@@YAII@Z				; DebugSetColor
; Function compile flags: /Ogtpy
;	COMDAT ?DebugSetColor@@YAII@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
?DebugSetColor@@YAII@Z PROC				; DebugSetColor, COMDAT

; 140  : 	unsigned t = _color;
; 141  : 	_color = c;

	mov	cl, BYTE PTR _c$[esp-4]
	movzx	eax, BYTE PTR ?_color@@3EA		; _color
	mov	BYTE PTR ?_color@@3EA, cl		; _color

; 142  : 	return t;
; 143  : }

	ret	0
?DebugSetColor@@YAII@Z ENDP				; DebugSetColor
_TEXT	ENDS
PUBLIC	?DebugGotoXY@@YAXII@Z				; DebugGotoXY
; Function compile flags: /Ogtpy
;	COMDAT ?DebugGotoXY@@YAXII@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?DebugGotoXY@@YAXII@Z PROC				; DebugGotoXY, COMDAT

; 147  : 	if(cursor_x <= 80)

	mov	cl, BYTE PTR ?cursor_x@@3EA		; cursor_x
	cmp	cl, 80					; 00000050H
	ja	SHORT $LN2@DebugGotoX

; 148  : 		cursor_x = x;

	mov	cl, BYTE PTR _x$[esp-4]
	mov	BYTE PTR ?cursor_x@@3EA, cl		; cursor_x
$LN2@DebugGotoX:

; 149  : 
; 150  : 	if(cursor_y <= 25)

	mov	al, BYTE PTR ?cursor_y@@3EA		; cursor_y
	cmp	al, 25					; 00000019H
	ja	SHORT $LN1@DebugGotoX

; 151  : 		cursor_y = y;

	mov	al, BYTE PTR _y$[esp-4]
	mov	BYTE PTR ?cursor_y@@3EA, al		; cursor_y
$LN1@DebugGotoX:

; 152  : 
; 153  : 	DebugUpdateCur(cursor_x,cursor_y);

	movzx	ax, al
	imul	ax, 80					; 00000050H
	push	esi
	movzx	cx, cl
	add	ax, cx
	push	14					; 0000000eH
	push	980					; 000003d4H
	movzx	esi, ax
	call	?outportb@@YAXGE@Z			; outportb
	mov	edx, esi
	shr	edx, 8
	push	edx
	push	981					; 000003d5H
	call	?outportb@@YAXGE@Z			; outportb
	push	15					; 0000000fH
	push	980					; 000003d4H
	call	?outportb@@YAXGE@Z			; outportb
	push	esi
	push	981					; 000003d5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 32					; 00000020H
	pop	esi

; 154  : }

	ret	0
?DebugGotoXY@@YAXII@Z ENDP				; DebugGotoXY
_TEXT	ENDS
PUBLIC	?DebugGetXY@@YAXPAI0@Z				; DebugGetXY
; Function compile flags: /Ogtpy
;	COMDAT ?DebugGetXY@@YAXPAI0@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?DebugGetXY@@YAXPAI0@Z PROC				; DebugGetXY, COMDAT

; 158  : 	if(x == 0 || y == 0)

	mov	ecx, DWORD PTR _x$[esp-4]
	test	ecx, ecx
	je	SHORT $LN1@DebugGetXY
	mov	eax, DWORD PTR _y$[esp-4]
	test	eax, eax
	je	SHORT $LN1@DebugGetXY

; 159  : 		return;
; 160  : 
; 161  : 	*x = cursor_x;

	movzx	edx, BYTE PTR ?cursor_x@@3EA		; cursor_x
	mov	DWORD PTR [ecx], edx

; 162  : 	*y = cursor_y;

	movzx	ecx, BYTE PTR ?cursor_y@@3EA		; cursor_y
	mov	DWORD PTR [eax], ecx
$LN1@DebugGetXY:

; 163  : 
; 164  : 	return;
; 165  : }

	ret	0
?DebugGetXY@@YAXPAI0@Z ENDP				; DebugGetXY
_TEXT	ENDS
PUBLIC	?DebugGetHorz@@YAHXZ				; DebugGetHorz
; Function compile flags: /Ogtpy
;	COMDAT ?DebugGetHorz@@YAHXZ
_TEXT	SEGMENT
?DebugGetHorz@@YAHXZ PROC				; DebugGetHorz, COMDAT

; 169  : 	return 80;

	mov	eax, 80					; 00000050H

; 170  : }

	ret	0
?DebugGetHorz@@YAHXZ ENDP				; DebugGetHorz
_TEXT	ENDS
PUBLIC	?DebugGetVert@@YAHXZ				; DebugGetVert
; Function compile flags: /Ogtpy
;	COMDAT ?DebugGetVert@@YAHXZ
_TEXT	SEGMENT
?DebugGetVert@@YAHXZ PROC				; DebugGetVert, COMDAT

; 174  : 	return 25;

	mov	eax, 25					; 00000019H

; 175  : }

	ret	0
?DebugGetVert@@YAHXZ ENDP				; DebugGetVert
_TEXT	ENDS
PUBLIC	?DebugClrScr@@YAXG@Z				; DebugClrScr
; Function compile flags: /Ogtpy
;	COMDAT ?DebugClrScr@@YAXG@Z
_TEXT	SEGMENT
_c$ = 8							; size = 2
?DebugClrScr@@YAXG@Z PROC				; DebugClrScr, COMDAT

; 178  : {

	mov	ecx, DWORD PTR _c$[esp-4]
	shl	ecx, 8
	or	ecx, 32					; 00000020H

; 179  : 	for(int i = 0;i < 80 * 25;i++)

	xor	eax, eax
	npad	4
$LL3@DebugClrSc:

; 180  : 		video_memory[i] = ' ' | (c << 8);

	mov	edx, DWORD PTR ?video_memory@@3PAGA	; video_memory
	mov	WORD PTR [eax+edx], cx
	add	eax, 2
	cmp	eax, 4000				; 00000fa0H
	jl	SHORT $LL3@DebugClrSc

; 181  : 
; 182  : 	DebugGotoXY(0,0);

	push	0
	push	0
	call	?DebugGotoXY@@YAXII@Z			; DebugGotoXY
	add	esp, 8

; 183  : }

	ret	0
?DebugClrScr@@YAXG@Z ENDP				; DebugClrScr
_TEXT	ENDS
PUBLIC	?DebugPuts@@YAXPAD@Z				; DebugPuts
EXTRN	?strlen@@YAIPBD@Z:PROC				; strlen
; Function compile flags: /Ogtpy
;	COMDAT ?DebugPuts@@YAXPAD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?DebugPuts@@YAXPAD@Z PROC				; DebugPuts, COMDAT

; 186  : {

	push	edi

; 187  : 	if(!str)

	mov	edi, DWORD PTR _str$[esp]
	test	edi, edi
	je	SHORT $LN1@DebugPuts
	push	esi

; 188  : 		return;
; 189  : 
; 190  : 	for(unsigned int i = 0;i < strlen(str);i++)

	push	edi
	xor	esi, esi
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	test	eax, eax
	jbe	SHORT $LN9@DebugPuts
	npad	7
$LL3@DebugPuts:

; 191  : 		DebugPutc(str[i]);

	movzx	eax, BYTE PTR [esi+edi]
	push	eax
	call	?DebugPutc@@YAXE@Z			; DebugPutc
	push	edi
	inc	esi
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 8
	cmp	esi, eax
	jb	SHORT $LL3@DebugPuts
$LN9@DebugPuts:
	pop	esi
$LN1@DebugPuts:
	pop	edi

; 192  : }

	ret	0
?DebugPuts@@YAXPAD@Z ENDP				; DebugPuts
_TEXT	ENDS
PUBLIC	?DebugPrintf@@YAHPBDZZ				; DebugPrintf
; Function compile flags: /Ogtpy
;	COMDAT ?DebugPrintf@@YAHPBDZZ
_TEXT	SEGMENT
_i$ = -36						; size = 4
_str$2979 = -32						; size = 32
_str$2969 = -32						; size = 32
_str$2959 = -32						; size = 32
_str$2949 = -32						; size = 32
_str$2939 = -32						; size = 32
_str$2929 = -32						; size = 32
_str$2919 = -32						; size = 32
_str$ = 8						; size = 4
?DebugPrintf@@YAHPBDZZ PROC				; DebugPrintf, COMDAT

; 195  : {

	sub	esp, 36					; 00000024H
	push	ebx

; 196  : 	if(!str)

	mov	ebx, DWORD PTR _str$[esp+36]
	test	ebx, ebx
	jne	SHORT $LN21@DebugPrint

; 197  : 		return 0;

	xor	eax, eax
	pop	ebx

; 333  : }

	add	esp, 36					; 00000024H
	ret	0
$LN21@DebugPrint:
	push	ebp
	push	esi
	push	edi

; 201  : 
; 202  : 	size_t i;
; 203  : 
; 204  : 	for(i = 0;i<strlen(str);i++)

	xor	ebp, ebp
	push	ebx
	mov	DWORD PTR _i$[esp+56], ebp
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	test	eax, eax
	jbe	$LN18@DebugPrint

; 198  : 
; 199  : 	va_list	args;
; 200  : 	va_start(args,str);

	lea	edi, DWORD PTR _str$[esp+48]
$LL110@DebugPrint:

; 205  : 	{
; 206  : 		switch(str[i])

	movzx	eax, BYTE PTR [ebx+ebp]
	cmp	al, 37					; 00000025H
	je	SHORT $LN15@DebugPrint

; 321  : 			}
; 322  : 			}
; 323  : 			
; 324  : 			break;
; 325  : 		default:
; 326  : 			DebugPutc(str[i]);

	push	eax
	call	?DebugPutc@@YAXE@Z			; DebugPutc
	add	esp, 4

; 327  : 			break;

	jmp	$LN19@DebugPrint
$LN15@DebugPrint:

; 207  : 		{
; 208  : 		case '%':
; 209  : 			switch(str[i+1])

	movsx	eax, BYTE PTR [ebx+ebp+1]
	add	eax, -37				; ffffffdbH
	cmp	eax, 83					; 00000053H
	ja	$LN2@DebugPrint
	movzx	eax, BYTE PTR $LN108@DebugPrint[eax]
	jmp	DWORD PTR $LN115@DebugPrint[eax*4]
$LN12@DebugPrint:

; 210  : 			{
; 211  : 			/*** Character ***/
; 212  : 			case 'c':
; 213  : 			{
; 214  : 				char c = va_arg(args,char);
; 215  : 				DebugPutc(c);

	movzx	ecx, BYTE PTR [edi+4]
	add	edi, 4
	push	ecx
	call	?DebugPutc@@YAXE@Z			; DebugPutc
	add	esp, 4

; 216  : 				i++;
; 217  : 				break;

	jmp	$LN114@DebugPrint
$LN11@DebugPrint:

; 218  : 			}
; 219  : 
; 220  : 			/*** String ***/
; 221  : 			case 's':
; 222  : 			{
; 223  : 				char* c = va_arg(args,char*);
; 224  : 				DebugPuts(c);

	mov	edx, DWORD PTR [edi+4]
	add	edi, 4
	push	edx
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 4

; 225  : 				i++;
; 226  : 				break;

	jmp	$LN114@DebugPrint
$LN10@DebugPrint:

; 227  : 			}
; 228  : 
; 229  : 			/*** Address of Data ***/
; 230  : 			case 'a':
; 231  : 			{
; 232  : 				int c = (int&)va_arg(args,char);
; 233  : 				char str[32] = {0};
; 234  : 				itoa(c,16,str);

	mov	ecx, DWORD PTR [edi+4]
	xor	eax, eax
	mov	DWORD PTR _str$2919[esp+53], eax
	mov	DWORD PTR _str$2919[esp+57], eax
	mov	DWORD PTR _str$2919[esp+61], eax
	mov	DWORD PTR _str$2919[esp+65], eax
	mov	DWORD PTR _str$2919[esp+69], eax
	mov	DWORD PTR _str$2919[esp+73], eax
	mov	DWORD PTR _str$2919[esp+77], eax
	mov	WORD PTR _str$2919[esp+81], ax
	mov	BYTE PTR _str$2919[esp+83], al
	lea	eax, DWORD PTR _str$2919[esp+52]
	push	eax
	add	edi, 4
	push	16					; 00000010H
	push	ecx
	mov	BYTE PTR _str$2919[esp+64], 0
	call	?itoa@@YAXIIPAD@Z			; itoa

; 235  : 				DebugPuts(str);

	lea	edx, DWORD PTR _str$2919[esp+64]
	push	edx
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 16					; 00000010H

; 236  : 				i++;
; 237  : 				break;

	jmp	$LN114@DebugPrint
$LN9@DebugPrint:

; 238  : 			}
; 239  : 
; 240  : 			/*** Unsigned Binary ***/
; 241  : 			case 'B':
; 242  : 			{
; 243  : 				int c = va_arg(args,int);
; 244  : 				char str[32] = {0};
; 245  : 				itoa(c,2,str);

	mov	ecx, DWORD PTR [edi+4]
	xor	eax, eax
	mov	DWORD PTR _str$2929[esp+53], eax
	mov	DWORD PTR _str$2929[esp+57], eax
	mov	DWORD PTR _str$2929[esp+61], eax
	mov	DWORD PTR _str$2929[esp+65], eax
	mov	DWORD PTR _str$2929[esp+69], eax
	mov	DWORD PTR _str$2929[esp+73], eax
	mov	DWORD PTR _str$2929[esp+77], eax
	mov	WORD PTR _str$2929[esp+81], ax
	mov	BYTE PTR _str$2929[esp+83], al
	lea	eax, DWORD PTR _str$2929[esp+52]
	push	eax
	add	edi, 4
	push	2
	push	ecx
	mov	BYTE PTR _str$2929[esp+64], 0
	call	?itoa@@YAXIIPAD@Z			; itoa

; 246  : 				DebugPuts(str);

	lea	edx, DWORD PTR _str$2929[esp+64]
	push	edx
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 16					; 00000010H

; 247  : 				i++;
; 248  : 				break;

	jmp	$LN114@DebugPrint
$LN8@DebugPrint:

; 249  : 			}
; 250  : 
; 251  : 			/*** Signed Binary ***/
; 252  : 			case 'b':
; 253  : 			{
; 254  : 				int c = va_arg(args,int);
; 255  : 				char str[32] = {0};

	xor	eax, eax
	add	edi, 4
	mov	DWORD PTR _str$2939[esp+53], eax
	mov	DWORD PTR _str$2939[esp+57], eax
	mov	DWORD PTR _str$2939[esp+61], eax
	mov	DWORD PTR _str$2939[esp+65], eax
	mov	DWORD PTR _str$2939[esp+69], eax
	mov	DWORD PTR _str$2939[esp+73], eax
	mov	DWORD PTR _str$2939[esp+77], eax
	mov	WORD PTR _str$2939[esp+81], ax
	mov	BYTE PTR _str$2939[esp+83], al

; 256  : 				itoa_s(c,2,str);

	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR _str$2939[esp+52], 0
	lea	esi, DWORD PTR _str$2939[esp+52]
	test	eax, eax
	jge	SHORT $LN24@DebugPrint
	mov	BYTE PTR _str$2939[esp+52], 45		; 0000002dH
	lea	esi, DWORD PTR _str$2939[esp+53]
	neg	eax
$LN24@DebugPrint:
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN33@DebugPrint
	npad	5
$LL32@DebugPrint:
	mov	edx, eax
	and	edx, 1
	mov	dl, BYTE PTR ?bchars@@3PADA[edx]
	mov	BYTE PTR ?tbuf@@3PADA[ecx], dl
	inc	ecx
	shr	eax, 1
	jne	SHORT $LL32@DebugPrint
	mov	ebp, ecx
	dec	ecx
	xor	eax, eax
	test	ebp, ebp
	jle	SHORT $LN28@DebugPrint
	lea	ecx, DWORD PTR ?tbuf@@3PADA[ecx]
$LL30@DebugPrint:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+esi], dl
	inc	eax
	dec	ecx
	cmp	eax, ebp
	jl	SHORT $LL30@DebugPrint
$LN28@DebugPrint:
	mov	ebp, DWORD PTR _i$[esp+52]
	mov	ebx, DWORD PTR _str$[esp+48]
	mov	BYTE PTR [eax+esi], 0

; 257  : 				DebugPuts(str);

	lea	eax, DWORD PTR _str$2939[esp+52]
	push	eax
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 4

; 258  : 				i++;
; 259  : 				break;

	jmp	$LN114@DebugPrint

; 256  : 				itoa_s(c,2,str);

$LN33@DebugPrint:

; 257  : 				DebugPuts(str);

	lea	eax, DWORD PTR _str$2939[esp+52]
	push	eax
	mov	BYTE PTR [esi], 48			; 00000030H
	mov	BYTE PTR [esi+1], 0
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 4

; 258  : 				i++;
; 259  : 				break;

	jmp	$LN114@DebugPrint
$LN7@DebugPrint:

; 260  : 			}
; 261  : 
; 262  : 			/*** Unsigned Integers ***/
; 263  : 			case 'D':
; 264  : 			case 'I':
; 265  : 			{
; 266  : 				int c = va_arg(args,int);
; 267  : 				char str[32] = {0};
; 268  : 				itoa(c,10,str);

	mov	edx, DWORD PTR [edi+4]
	xor	eax, eax
	lea	ecx, DWORD PTR _str$2949[esp+52]
	push	ecx
	add	edi, 4
	push	10					; 0000000aH
	push	edx
	mov	BYTE PTR _str$2949[esp+64], 0
	mov	DWORD PTR _str$2949[esp+65], eax
	mov	DWORD PTR _str$2949[esp+69], eax
	mov	DWORD PTR _str$2949[esp+73], eax
	mov	DWORD PTR _str$2949[esp+77], eax
	mov	DWORD PTR _str$2949[esp+81], eax
	mov	DWORD PTR _str$2949[esp+85], eax
	mov	DWORD PTR _str$2949[esp+89], eax
	mov	WORD PTR _str$2949[esp+93], ax
	mov	BYTE PTR _str$2949[esp+95], al
	call	?itoa@@YAXIIPAD@Z			; itoa

; 269  : 				DebugPuts(str);

	lea	eax, DWORD PTR _str$2949[esp+64]
	push	eax
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 16					; 00000010H

; 270  : 				i++;
; 271  : 				break;

	jmp	$LN114@DebugPrint
$LN6@DebugPrint:

; 272  : 			}
; 273  : 
; 274  : 			/*** Signed Integers ***/
; 275  : 			case 'd':
; 276  : 			case 'i':
; 277  : 			{
; 278  : 				int c = va_arg(args,int);
; 279  : 				char str[32] = {0};
; 280  : 				itoa_s(c,10,str);

	mov	ecx, DWORD PTR [edi+4]
	xor	eax, eax
	add	edi, 4
	mov	BYTE PTR _str$2959[esp+52], 0
	mov	DWORD PTR _str$2959[esp+53], eax
	mov	DWORD PTR _str$2959[esp+57], eax
	mov	DWORD PTR _str$2959[esp+61], eax
	mov	DWORD PTR _str$2959[esp+65], eax
	mov	DWORD PTR _str$2959[esp+69], eax
	mov	DWORD PTR _str$2959[esp+73], eax
	mov	DWORD PTR _str$2959[esp+77], eax
	mov	WORD PTR _str$2959[esp+81], ax
	mov	BYTE PTR _str$2959[esp+83], al
	lea	ebx, DWORD PTR _str$2959[esp+52]
	test	ecx, ecx
	jge	SHORT $LN37@DebugPrint
	mov	BYTE PTR _str$2959[esp+52], 45		; 0000002dH
	lea	ebx, DWORD PTR _str$2959[esp+53]
	neg	ecx
$LN37@DebugPrint:
	xor	esi, esi
	test	ecx, ecx
	je	SHORT $LN46@DebugPrint
$LL45@DebugPrint:
	mov	eax, -858993459				; cccccccdH
	mul	ecx
	shr	edx, 3
	lea	eax, DWORD PTR [edx+edx*4]
	add	eax, eax
	sub	ecx, eax
	mov	cl, BYTE PTR ?bchars@@3PADA[ecx]
	mov	BYTE PTR ?tbuf@@3PADA[esi], cl
	mov	ecx, edx
	inc	esi
	test	ecx, ecx
	jne	SHORT $LL45@DebugPrint
	mov	ebp, esi
	dec	esi
	xor	eax, eax
	test	ebp, ebp
	jle	SHORT $LN41@DebugPrint
	lea	ecx, DWORD PTR ?tbuf@@3PADA[esi]
$LL43@DebugPrint:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+ebx], dl
	inc	eax
	dec	ecx
	cmp	eax, ebp
	jl	SHORT $LL43@DebugPrint
$LN41@DebugPrint:
	mov	ebp, DWORD PTR _i$[esp+52]
	mov	BYTE PTR [eax+ebx], 0

; 281  : 				DebugPuts(str);

	lea	eax, DWORD PTR _str$2959[esp+52]
	push	eax
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 282  : 				i++;
; 283  : 				break;

	mov	ebx, DWORD PTR _str$[esp+52]
	add	esp, 4
	jmp	$LN114@DebugPrint

; 272  : 			}
; 273  : 
; 274  : 			/*** Signed Integers ***/
; 275  : 			case 'd':
; 276  : 			case 'i':
; 277  : 			{
; 278  : 				int c = va_arg(args,int);
; 279  : 				char str[32] = {0};
; 280  : 				itoa_s(c,10,str);

$LN46@DebugPrint:

; 281  : 				DebugPuts(str);

	lea	eax, DWORD PTR _str$2959[esp+52]
	push	eax
	mov	BYTE PTR [ebx], 48			; 00000030H
	mov	BYTE PTR [ebx+1], 0
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 282  : 				i++;
; 283  : 				break;

	mov	ebx, DWORD PTR _str$[esp+52]
	add	esp, 4
	jmp	$LN114@DebugPrint
$LN5@DebugPrint:

; 284  : 			}
; 285  : 
; 286  : 			/*** Integers in Unsigned Hexadecimal ***/
; 287  : 			case 'X':
; 288  : 			{
; 289  : 				int c = va_arg(args,int);
; 290  : 				char str[32] = {0};
; 291  : 				itoa(c,16,str);

	mov	edx, DWORD PTR [edi+4]
	xor	eax, eax
	lea	ecx, DWORD PTR _str$2969[esp+52]
	push	ecx
	add	edi, 4
	push	16					; 00000010H
	push	edx
	mov	BYTE PTR _str$2969[esp+64], 0
	mov	DWORD PTR _str$2969[esp+65], eax
	mov	DWORD PTR _str$2969[esp+69], eax
	mov	DWORD PTR _str$2969[esp+73], eax
	mov	DWORD PTR _str$2969[esp+77], eax
	mov	DWORD PTR _str$2969[esp+81], eax
	mov	DWORD PTR _str$2969[esp+85], eax
	mov	DWORD PTR _str$2969[esp+89], eax
	mov	WORD PTR _str$2969[esp+93], ax
	mov	BYTE PTR _str$2969[esp+95], al
	call	?itoa@@YAXIIPAD@Z			; itoa

; 292  : 				DebugPuts(str);

	lea	eax, DWORD PTR _str$2969[esp+64]
	push	eax
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 16					; 00000010H

; 293  : 				i++;
; 294  : 				break;

	jmp	$LN114@DebugPrint
$LN4@DebugPrint:

; 295  : 			}
; 296  : 
; 297  : 			/*** Integers in Signed Hexadecimal ***/
; 298  : 			case 'x':
; 299  : 			{
; 300  : 				int c = va_arg(args,int);
; 301  : 				char str[32] = {0};

	xor	eax, eax
	add	edi, 4
	mov	DWORD PTR _str$2979[esp+53], eax
	mov	DWORD PTR _str$2979[esp+57], eax
	mov	DWORD PTR _str$2979[esp+61], eax
	mov	DWORD PTR _str$2979[esp+65], eax
	mov	DWORD PTR _str$2979[esp+69], eax
	mov	DWORD PTR _str$2979[esp+73], eax
	mov	DWORD PTR _str$2979[esp+77], eax
	mov	WORD PTR _str$2979[esp+81], ax
	mov	BYTE PTR _str$2979[esp+83], al

; 302  : 				itoa_s(c,16,str);

	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR _str$2979[esp+52], 0
	lea	ebp, DWORD PTR _str$2979[esp+52]
	test	eax, eax
	jge	SHORT $LN50@DebugPrint
	mov	BYTE PTR _str$2979[esp+52], 45		; 0000002dH
	lea	ebp, DWORD PTR _str$2979[esp+53]
	neg	eax
$LN50@DebugPrint:
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN59@DebugPrint
	npad	9
$LL58@DebugPrint:
	mov	edx, eax
	and	edx, 15					; 0000000fH
	mov	dl, BYTE PTR ?bchars@@3PADA[edx]
	mov	BYTE PTR ?tbuf@@3PADA[ecx], dl
	shr	eax, 4
	inc	ecx
	test	eax, eax
	jne	SHORT $LL58@DebugPrint
	mov	esi, ecx
	dec	ecx
	test	esi, esi
	jle	SHORT $LN54@DebugPrint
	lea	ecx, DWORD PTR ?tbuf@@3PADA[ecx]
$LL56@DebugPrint:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+ebp], dl
	inc	eax
	dec	ecx
	cmp	eax, esi
	jl	SHORT $LL56@DebugPrint
$LN54@DebugPrint:
	mov	BYTE PTR [eax+ebp], 0
	jmp	SHORT $LN61@DebugPrint
$LN59@DebugPrint:
	mov	BYTE PTR [ebp], 48			; 00000030H
	mov	BYTE PTR [ebp+1], 0
$LN61@DebugPrint:

; 303  : 				DebugPuts(str);

	lea	eax, DWORD PTR _str$2979[esp+52]
	push	eax
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 304  : 				i++;
; 305  : 				break;

	mov	ebx, DWORD PTR _str$[esp+52]
	add	esp, 4
	inc	DWORD PTR _i$[esp+52]
	mov	ebp, DWORD PTR _i$[esp+52]
	jmp	$LN19@DebugPrint
$LN3@DebugPrint:

; 306  : 			}
; 307  : 
; 308  : 			/*** Print the % Sign ***/
; 309  : 			case '%':
; 310  : 			{
; 311  : 				DebugPutc('%');

	movzx	eax, BYTE PTR ?cursor_y@@3EA		; cursor_y
	movzx	cx, BYTE PTR ?_color@@3EA		; _color
	lea	edx, DWORD PTR [eax+eax*4]
	movzx	eax, BYTE PTR ?cursor_x@@3EA		; cursor_x
	shl	edx, 4
	add	edx, eax
	mov	eax, DWORD PTR ?video_memory@@3PAGA	; video_memory
	shl	cx, 8
	or	cx, 37					; 00000025H
	mov	WORD PTR [eax+edx*2], cx
	mov	al, BYTE PTR ?cursor_x@@3EA		; cursor_x
	inc	al
	mov	BYTE PTR ?cursor_x@@3EA, al		; cursor_x
	cmp	al, 80					; 00000050H
	jb	SHORT $LN109@DebugPrint
	inc	BYTE PTR ?cursor_y@@3EA			; cursor_y
	mov	BYTE PTR ?cursor_x@@3EA, 0		; cursor_x
$LN109@DebugPrint:
	cmp	BYTE PTR ?cursor_y@@3EA, 24		; cursor_y, 00000018H
	jbe	SHORT $LN63@DebugPrint
	mov	BYTE PTR ?cursor_y@@3EA, 24		; cursor_y, 00000018H
	call	?Scroll@@YAXXZ				; Scroll
$LN63@DebugPrint:
	movzx	cx, BYTE PTR ?cursor_y@@3EA		; cursor_y
	movzx	dx, BYTE PTR ?cursor_x@@3EA		; cursor_x
	imul	cx, 80					; 00000050H
	add	cx, dx
	push	14					; 0000000eH
	push	980					; 000003d4H
	movzx	esi, cx
	call	?outportb@@YAXGE@Z			; outportb
	mov	eax, esi
	shr	eax, 8
	push	eax
	push	981					; 000003d5H
	call	?outportb@@YAXGE@Z			; outportb
	push	15					; 0000000fH
	push	980					; 000003d4H
	call	?outportb@@YAXGE@Z			; outportb
	push	esi
	push	981					; 000003d5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 32					; 00000020H
$LN114@DebugPrint:

; 312  : 				i++;

	inc	ebp
$LN19@DebugPrint:

; 201  : 
; 202  : 	size_t i;
; 203  : 
; 204  : 	for(i = 0;i<strlen(str);i++)

	inc	ebp
	push	ebx
	mov	DWORD PTR _i$[esp+56], ebp
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	cmp	ebp, eax
	jb	$LL110@DebugPrint
$LN18@DebugPrint:
	pop	edi
	pop	esi

; 328  : 		}
; 329  : 	}
; 330  : 
; 331  : 	va_end(args);
; 332  : 	return i;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 333  : }

	add	esp, 36					; 00000024H
	ret	0
$LN2@DebugPrint:
	pop	edi
	pop	esi
	pop	ebp

; 313  : 				break;
; 314  : 			}
; 315  : 
; 316  : 			/*** Bad Formating ***/
; 317  : 			default:
; 318  : 			{
; 319  : 				va_end(args);
; 320  : 				return 1;

	mov	eax, 1
	pop	ebx

; 333  : }

	add	esp, 36					; 00000024H
	ret	0
$LN115@DebugPrint:
	DD	$LN3@DebugPrint
	DD	$LN9@DebugPrint
	DD	$LN7@DebugPrint
	DD	$LN5@DebugPrint
	DD	$LN10@DebugPrint
	DD	$LN8@DebugPrint
	DD	$LN12@DebugPrint
	DD	$LN6@DebugPrint
	DD	$LN11@DebugPrint
	DD	$LN4@DebugPrint
	DD	$LN2@DebugPrint
$LN108@DebugPrint:
	DB	0
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	1
	DB	10					; 0000000aH
	DB	2
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	2
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	3
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	4
	DB	5
	DB	6
	DB	7
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	7
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	8
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	9
?DebugPrintf@@YAHPBDZZ ENDP				; DebugPrintf
_TEXT	ENDS
END
