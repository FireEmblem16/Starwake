; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\Users\FireEmblem16\Documents\Visual Studio 2008\Projects\Naomi\Naomi\string.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?strcpy@@YAPADPADPBD@Z				; strcpy
; Function compile flags: /Ogtpy
; File c:\users\fireemblem16\documents\visual studio 2008\projects\naomi\naomi\string.cpp
;	COMDAT ?strcpy@@YAPADPADPBD@Z
_TEXT	SEGMENT
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
?strcpy@@YAPADPADPBD@Z PROC				; strcpy, COMDAT

; 48   :     char *s1_p = s1;

	mov	edx, DWORD PTR _s1$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s2$[esp]
	mov	eax, edx
	npad	5
$LL2@strcpy:

; 49   :     while (*s1++ = *s2++);

	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [edx], cl
	inc	edx
	inc	esi
	test	cl, cl
	jne	SHORT $LL2@strcpy
	pop	esi

; 50   :     return s1_p;
; 51   : }

	ret	0
?strcpy@@YAPADPADPBD@Z ENDP				; strcpy
_TEXT	ENDS
PUBLIC	?strlen@@YAIPBD@Z				; strlen
; Function compile flags: /Ogtpy
;	COMDAT ?strlen@@YAIPBD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?strlen@@YAIPBD@Z PROC					; strlen, COMDAT

; 55   : 
; 56   : 	size_t	len=0;

	mov	ecx, DWORD PTR _str$[esp-4]
	xor	eax, eax
$LL2@strlen:

; 57   : 	while (str[len++]);

	mov	dl, BYTE PTR [eax+ecx]
	inc	eax
	test	dl, dl
	jne	SHORT $LL2@strlen

; 58   : 	return len;
; 59   : }

	ret	0
?strlen@@YAIPBD@Z ENDP					; strlen
_TEXT	ENDS
PUBLIC	?memcpy@@YAPAXPAXPBXI@Z				; memcpy
; Function compile flags: /Ogtpy
;	COMDAT ?memcpy@@YAPAXPAXPBXI@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_count$ = 16						; size = 4
?memcpy@@YAPAXPAXPBXI@Z PROC				; memcpy, COMDAT

; 64   :     const char *sp = (const char *)src;

	mov	ecx, DWORD PTR _src$[esp-4]
	push	esi

; 65   :     char *dp = (char *)dest;
; 66   :     for(; count != 0; count--) *dp++ = *sp++;

	mov	esi, DWORD PTR _count$[esp]
	test	esi, esi
	je	SHORT $LN8@memcpy
	push	edi
	mov	edi, DWORD PTR _dest$[esp+4]
	mov	edx, edi
	sub	edx, ecx
$LL3@memcpy:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx+ecx], al
	inc	ecx
	sub	esi, 1
	jne	SHORT $LL3@memcpy

; 67   :     return dest;

	mov	eax, edi
	pop	edi
	pop	esi

; 68   : }

	ret	0
$LN8@memcpy:

; 67   :     return dest;

	mov	eax, DWORD PTR _dest$[esp]
	pop	esi

; 68   : }

	ret	0
?memcpy@@YAPAXPAXPBXI@Z ENDP				; memcpy
_TEXT	ENDS
PUBLIC	?memset@@YAPAXPAXDI@Z				; memset
; Function compile flags: /Ogtpy
;	COMDAT ?memset@@YAPAXPAXDI@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_val$ = 12						; size = 1
_count$ = 16						; size = 4
?memset@@YAPAXPAXDI@Z PROC				; memset, COMDAT

; 73   :     unsigned char *temp = (unsigned char *)dest;
; 74   : 	for( ; count != 0; count--, temp[count] = val);

	mov	ecx, DWORD PTR _count$[esp-4]
	mov	eax, DWORD PTR _dest$[esp-4]
	test	ecx, ecx
	je	SHORT $LN1@memset
	mov	dl, BYTE PTR _val$[esp-4]
$LL3@memset:
	sub	ecx, 1
	mov	BYTE PTR [eax+ecx], dl
	jne	SHORT $LL3@memset
$LN1@memset:

; 75   : 	return dest;
; 76   : }

	ret	0
?memset@@YAPAXPAXDI@Z ENDP				; memset
_TEXT	ENDS
PUBLIC	?memsetw@@YAPAGPAGGI@Z				; memsetw
; Function compile flags: /Ogtpy
;	COMDAT ?memsetw@@YAPAGPAGGI@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_val$ = 12						; size = 2
_count$ = 16						; size = 4
?memsetw@@YAPAGPAGGI@Z PROC				; memsetw, COMDAT

; 81   :     unsigned short *temp = (unsigned short *)dest;
; 82   :     for( ; count != 0; count--)

	mov	ecx, DWORD PTR _count$[esp-4]
	test	ecx, ecx
	je	SHORT $LN8@memsetw
	mov	eax, DWORD PTR _val$[esp-4]
	mov	edx, DWORD PTR _dest$[esp-4]
	push	esi
	movzx	esi, ax
	mov	eax, esi
	shl	esi, 16					; 00000010H
	push	edi
	or	eax, esi
	shr	ecx, 1
	mov	edi, edx
	rep stosd
	adc	ecx, ecx
	rep stosw
	pop	edi

; 83   : 		*temp++ = val;
; 84   :     return dest;

	mov	eax, edx
	pop	esi

; 85   : }

	ret	0
$LN8@memsetw:

; 83   : 		*temp++ = val;
; 84   :     return dest;

	mov	eax, DWORD PTR _dest$[esp-4]

; 85   : }

	ret	0
?memsetw@@YAPAGPAGGI@Z ENDP				; memsetw
_TEXT	ENDS
END
