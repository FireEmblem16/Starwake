Code Design
Don Nye

Overview
	The code for this project contains a total of five hierarchies of the parent-child relationship as well as two groups of related classes. The five hierarchies are the Item hierarchy, the Behavior hierarchy (quite possibly misspelled), the Collision hierarchy, the Movement hierarchy, and the Probe hierarchy. The two groups of related classes consist of the simulation loader and container and the set of stream parsers. These classes have symbiotic relationship within their groups but do not derive from each other.
	The main reason for separating the three different types of behavior from each other and from the Behavior class is because it becomes much easier to alter the behavior of any item, change defaults etc... This is because we would expect Behavior to have n*m*o subclasses otherwise, where n is the number of different ways something can collide, m is the number of different ways something can move and o is the number of different ways something responds to a probe.

Simulation Containment
	This is one of the two groups of related classes. This one contains XMLParser, Simulation and Entry. XMLParser takes a configuration file and loads all of it's data into a simulation object. Simulation objects contain a vector of entries which in turn contain all items at a specific point on the grid.
	These three classes are separated from one another because they all serve very different purposes. Particularly the has-a relationship between Simulation and Entry. Entry objects provide a large amount of parse functions for information contained in a single tile on the grid. For example, entries will forbid two objects from occupying the same location because it can only hold one. It is however free to hold as many properties and ghost objects as it wants. In contrast to this, a Simulation object will spend its life managing the arrangement, augmentation and removal of items from the entire grid by interacting with entries. XMLParser is separated from the two entirely because formatting is a nightmare and eats up a lot of space and code which can easily lead to difficulties when attempting to find information on a class's functionality, notwithstanding initially coding the class.

Stream Parsing
	This is the second of the two groups of related classes. It contains MessageReader, Command and MoveInfo. ItemData is also included in this but it is little more than a struct with operator overloading. MessageReader will parse communications between a simulation program and robot brains which are operated by the MoveBehaviour hierarchy. Command contains a vector and limited information about what kind of command a robot brain has sent or is being sent. It is almost just a struct or vector but the functions it provides put it into a higher class. MoveInfo provides a huge number of functions that allow a robot to understand a move command it has been given including the infamous triangulate function which will allow it to determine its position, oddly the only absolute position it can not determine itself.
	Now for the relationship between the three. MessageReader reads from a stream into a Command object which it stores for later use. MessageReader can also output a command that has been generated externally with a single function call. MessageReader can also generate a MoveInfo object if it has read in a Command of a moving nature.
	Commands are separate from MessageReader to keep data sizes smaller and create ease of use. MoveInfo is separated from MessageReader as well because it deals with interpreting data instead of parsing it from a stream, both of which are quite complex tasks.

Item Hierarchy
This consists of all Objects and Properties capable of being in the simulation. Item is the parent of all such classes. The immediate children of Item consist of Object and Property which define the archetypical nature of an Object and a Property respectively. Also whenever a new type has been defined that needs another piece of data, such as the color of an Object, the new class will contain that data which will be available for all of its children. Immediately after Object comes the Rock parent, the Geometry parent, EnergyPill and Robot. The Rock parent is the parent of EarthRock and RumulanRock while Geometry is the parent of Ball and Block. The children of property are all the youngest in that branch and consist of Jammer (Jam), Lava, Hole, Mud and Water.
	The primary reason for the parent child hierarchy all the way to such things as EarthRock and RumulanRock are because most of the youngest children have subtle differences from one another. For example, EarthRock is probable, unmovable and stationary but RumulanRock is unprovable. Rather than add a nightmarishly large number of checks in the parent classes we simply create children that have different defaults. This also allows us to add new functions to classes such as Robot that need them.
	Now we note the relation between Items and Behaviors. Every item has a behavior. This behavior defines how the item will act in a simulation and is thus very important. Also since each item type has a different behavior we can not reference a static or global behavior. This method also allows there to be behavioral differences inside of a class as well. For example as rock that walks doesn't need a new class if we expect them to be created as a consequence of some action on the grid.
	The overarching purpose of any Item class is essentially to say “I exist, this is what I am, and this is what I do.” Much simpler to have these in object form then to have their data simply collected in an entry on the simulation grid. 

Behavior Hierarchy
	This is a small but important hierarchy. It consists of Behavior which defines what it means to be a behavior, PillAddict, Sentry and Tribot. Behaviors have three main member variables. These variables consist of one of each of the ___Behavior hierarchies. The default for these variables are HardPlace, Stationary and Probable as these are the more common characteristics. Behavior is also the default way all Items behave in a simulation grid. The other three classes are essentially the same except the redefine the way an object, particularly a robot, will move. PillAddict searches for pills. Sentry travels around the edge of the simulation grid. Tribot gathers objects of its own color. All three of the children have their own AI which is relatively complex to the rest of the code and easily warranted not only being separate from each other but from their parent class as well.

CollisionBehavior
	Consists of RollingPlace, HardPlace, SoftPlace and Consumable besides its parent class. These classes all have a function called Collide that returns a number that represents the outcome of a collision with it. Not surprisingly a HardPlace will not move and knock other things back and a SoftPlace will move out of the way opposite of the direction whatever collided with it came from. A Consumable will disappear if anything collides with it. A RollingPlace acts like a SoftPlace except it keeps moving in the same direction after the collision.
	These are separated from the rest of the code because they vastly reduce the amount of code, particularly tedious checks that must be made if we simply abstract out the nature of colliding with things. This is especially true because collisions do not depends on what initiated the collision, only where an item was collided from.

MoveBehavior
	Aside from its parent class consists of four classes and a closely related class. These are PillSeeker, Centurion, Gatherer and Stationary with the related class being Target. Target is simply a two dimensional vector with an extra integer for special data. The hierarchy has a function called Move which will determine the next course of action an item, particularly a robot, should take based on where it is in the simulation grid, what it can see and its purpose.
	PillSeekers generate the movement AI for PillAddicts, that is it prioritizes obtaining EnergyPills. A Centurion is the movement AI for a Sentry, moving about the perimeter of the grid and reversing direction after a full rotation. A Gatherer will attempt to horde items of the same color as itself on a particular side of the simulation grid. This is the movement AI for a Tribot.
	These classes are separated from all other code because they are huge, complex and would have to be rewritten several times if places, say as a new child of Robot for each one. Making a new Robot child for each movement AI would be a poor idea because it would ruin the extensibility or all the code by allowing movement only to robots unless many extra classes were added as children of other types, which would almost always contain a class called Stationary___.

ProbeBehavior
	Consists of two classes besides the parent called Probable and Unprobable. All three classes have a function called Probe which returns true if a probe can detect whatever the behavior is attached to and false otherwise. Pretty self-explainable and simple but for the sake of extensibility as well as reducing the amount of code that needs to be written these classes are separate from the other behaviors.
