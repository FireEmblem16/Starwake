; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\Program Files\The Game Creators\Dark GDK\Include\DBO Format\DBOBlock.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?g_bWriteAsText@@3_NA				; g_bWriteAsText
PUBLIC	?g_pBlockEnd@@3PADA				; g_pBlockEnd
PUBLIC	?g_dwVersion@@3KA				; g_dwVersion
_BSS	SEGMENT
?g_bWriteAsText@@3_NA DB 01H DUP (?)			; g_bWriteAsText
	ALIGN	4

?g_pBlockEnd@@3PADA DD 01H DUP (?)			; g_pBlockEnd
?g_dwVersion@@3KA DD 01H DUP (?)			; g_dwVersion
_BSS	ENDS
PUBLIC	?WriteCR@@YA_NPAPADPAK@Z			; WriteCR
; Function compile flags: /Odtp /ZI
; File c:\program files\the game creators\dark gdk\include\dbo format\dboblock.cpp
;	COMDAT ?WriteCR@@YA_NPAPADPAK@Z
_TEXT	SEGMENT
_ppBlock$ = 8						; size = 4
_pdwSize$ = 12						; size = 4
?WriteCR@@YA_NPAPADPAK@Z PROC				; WriteCR, COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 29   : 	if ( g_bWriteAsText )

	movzx	eax, BYTE PTR ?g_bWriteAsText@@3_NA	; g_bWriteAsText
	test	eax, eax
	je	SHORT $LN2@WriteCR

; 30   : 	{
; 31   : 		if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN1@WriteCR

; 32   : 		{
; 33   : 			*(BYTE*)*ppBlock = 13;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx], 13			; 0000000dH

; 34   : 			*ppBlock += 1;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx

; 35   : 			*(BYTE*)*ppBlock = 10;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx], 10			; 0000000aH

; 36   : 			*ppBlock += 1;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@WriteCR:

; 37   : 		}
; 38   : 		*pdwSize += 2;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@WriteCR:

; 39   : 	}
; 40   : 	return true;

	mov	al, 1

; 41   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteCR@@YA_NPAPADPAK@Z ENDP				; WriteCR
_TEXT	ENDS
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
PUBLIC	?WriteComma@@YA_NPAPADPAK@Z			; WriteComma
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_strcpy:PROC
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?WriteComma@@YA_NPAPADPAK@Z
_TEXT	SEGMENT
_dwLen$ = -8						; size = 4
_pCommaStr$ = -4					; size = 2
_ppBlock$ = 8						; size = 4
_pdwSize$ = 12						; size = 4
?WriteComma@@YA_NPAPADPAK@Z PROC			; WriteComma, COMDAT

; 44   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 45   : 	char pCommaStr[2];
; 46   : 	strcpy(pCommaStr,",");

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	eax, DWORD PTR _pCommaStr$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 47   : 	DWORD dwLen = strlen(pCommaStr);

	lea	eax, DWORD PTR _pCommaStr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _dwLen$[ebp], eax

; 48   : 	if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN1@WriteComma

; 49   : 	{
; 50   : 		memcpy ( *ppBlock, pCommaStr, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pCommaStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 51   : 		*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@WriteComma:

; 52   : 	}
; 53   : 	*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx

; 54   : 	return true;

	mov	al, 1

; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteComma@@YA_NPAPADPAK@Z ENDP			; WriteComma
_TEXT	ENDS
PUBLIC	?WriteSpeechmark@@YA_NPAPADPAK@Z		; WriteSpeechmark
; Function compile flags: /Odtp /ZI
;	COMDAT ?WriteSpeechmark@@YA_NPAPADPAK@Z
_TEXT	SEGMENT
_dwLen$ = -8						; size = 4
_pMarkStr$ = -4						; size = 2
_ppBlock$ = 8						; size = 4
_pdwSize$ = 12						; size = 4
?WriteSpeechmark@@YA_NPAPADPAK@Z PROC			; WriteSpeechmark, COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 59   : 	char pMarkStr[2];
; 60   : 	pMarkStr[0]='"';

	mov	BYTE PTR _pMarkStr$[ebp], 34		; 00000022H

; 61   : 	pMarkStr[1]=0;

	mov	BYTE PTR _pMarkStr$[ebp+1], 0

; 62   : 	DWORD dwLen = strlen(pMarkStr);

	lea	eax, DWORD PTR _pMarkStr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _dwLen$[ebp], eax

; 63   : 	if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN1@WriteSpeec

; 64   : 	{
; 65   : 		memcpy ( *ppBlock, pMarkStr, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pMarkStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 66   : 		*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@WriteSpeec:

; 67   : 	}
; 68   : 	*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx

; 69   : 	return true;

	mov	al, 1

; 70   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteSpeechmark@@YA_NPAPADPAK@Z ENDP			; WriteSpeechmark
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?WriteBYTE@@YA_NEPAPADPAK@Z			; WriteBYTE
EXTRN	__itoa:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ?WriteBYTE@@YA_NEPAPADPAK@Z
_TEXT	SEGMENT
_pNumberStr$56818 = -264				; size = 256
_dwLen$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_bNumber$ = 8						; size = 1
_ppBlock$ = 12						; size = 4
_pdwSize$ = 16						; size = 4
?WriteBYTE@@YA_NEPAPADPAK@Z PROC			; WriteBYTE, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 74   : 	DWORD dwLen = 1;

	mov	DWORD PTR _dwLen$[ebp], 1

; 75   : 	if ( g_bWriteAsText )

	movzx	eax, BYTE PTR ?g_bWriteAsText@@3_NA	; g_bWriteAsText
	test	eax, eax
	je	SHORT $LN4@WriteBYTE

; 76   : 	{
; 77   : 		// make text value
; 78   : 		char pNumberStr[256];
; 79   : 		_itoa(bNumber, pNumberStr, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _pNumberStr$56818[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bNumber$[ebp]
	push	ecx
	call	__itoa
	add	esp, 12					; 0000000cH

; 80   : 		dwLen = strlen(pNumberStr);

	lea	eax, DWORD PTR _pNumberStr$56818[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _dwLen$[ebp], eax

; 81   : 		if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN3@WriteBYTE

; 82   : 		{
; 83   : 			memcpy ( *ppBlock, pNumberStr, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pNumberStr$56818[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 84   : 			*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@WriteBYTE:

; 85   : 		}
; 86   : 		*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx

; 87   : 
; 88   : 		// make text comma
; 89   : 		WriteComma ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteComma@@YA_NPAPADPAK@Z		; WriteComma
	add	esp, 8

; 90   : 	}
; 91   : 	else

	jmp	SHORT $LN2@WriteBYTE
$LN4@WriteBYTE:

; 92   : 	{
; 93   : 		if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN1@WriteBYTE

; 94   : 		{
; 95   : 			*(BYTE*)*ppBlock = bNumber;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR _bNumber$[ebp]
	mov	BYTE PTR [ecx], dl

; 96   : 			*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@WriteBYTE:

; 97   : 		}
; 98   : 		*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@WriteBYTE:

; 99   : 	}
; 100  : 	return true;

	mov	al, 1

; 101  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteBYTE@@YA_NEPAPADPAK@Z ENDP			; WriteBYTE
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?WriteDWORD@@YA_NKPAPADPAK@Z			; WriteDWORD
; Function compile flags: /Odtp /ZI
;	COMDAT ?WriteDWORD@@YA_NKPAPADPAK@Z
_TEXT	SEGMENT
_pNumberStr$56830 = -264				; size = 256
_dwLen$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_dwNumber$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
_pdwSize$ = 16						; size = 4
?WriteDWORD@@YA_NKPAPADPAK@Z PROC			; WriteDWORD, COMDAT

; 104  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 105  : 	DWORD dwLen = 4;

	mov	DWORD PTR _dwLen$[ebp], 4

; 106  : 	if ( g_bWriteAsText )

	movzx	eax, BYTE PTR ?g_bWriteAsText@@3_NA	; g_bWriteAsText
	test	eax, eax
	je	SHORT $LN4@WriteDWORD

; 107  : 	{
; 108  : 		// make text value
; 109  : 		char pNumberStr[256];
; 110  : 		_itoa(dwNumber, pNumberStr, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _pNumberStr$56830[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwNumber$[ebp]
	push	ecx
	call	__itoa
	add	esp, 12					; 0000000cH

; 111  : 		dwLen = strlen(pNumberStr);

	lea	eax, DWORD PTR _pNumberStr$56830[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _dwLen$[ebp], eax

; 112  : 		if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN3@WriteDWORD

; 113  : 		{
; 114  : 			memcpy ( *ppBlock, pNumberStr, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pNumberStr$56830[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 115  : 			*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@WriteDWORD:

; 116  : 		}
; 117  : 		*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx

; 118  : 
; 119  : 		// make text comma
; 120  : 		WriteComma ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteComma@@YA_NPAPADPAK@Z		; WriteComma
	add	esp, 8

; 121  : 	}
; 122  : 	else

	jmp	SHORT $LN2@WriteDWORD
$LN4@WriteDWORD:

; 123  : 	{
; 124  : 		if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN1@WriteDWORD

; 125  : 		{
; 126  : 			*(DWORD*)*ppBlock = dwNumber;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _dwNumber$[ebp]
	mov	DWORD PTR [ecx], edx

; 127  : 			*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@WriteDWORD:

; 128  : 		}
; 129  : 		*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@WriteDWORD:

; 130  : 	}
; 131  : 	return true;

	mov	al, 1

; 132  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteDWORD@@YA_NKPAPADPAK@Z ENDP			; WriteDWORD
_TEXT	ENDS
PUBLIC	?Write2BYTE@@YA_NKEPAPADPAK@Z			; Write2BYTE
; Function compile flags: /Odtp /ZI
;	COMDAT ?Write2BYTE@@YA_NKEPAPADPAK@Z
_TEXT	SEGMENT
_dwNumber1$ = 8						; size = 4
_bNumber2$ = 12						; size = 1
_ppBlock$ = 16						; size = 4
_pdwSize$ = 20						; size = 4
?Write2BYTE@@YA_NKEPAPADPAK@Z PROC			; Write2BYTE, COMDAT

; 135  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 136  : 	WriteDWORD ( dwNumber1, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwNumber1$[ebp]
	push	edx
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 137  : 	WriteBYTE ( bNumber2, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bNumber2$[ebp]
	push	edx
	call	?WriteBYTE@@YA_NEPAPADPAK@Z		; WriteBYTE
	add	esp, 12					; 0000000cH

; 138  : 	return true;

	mov	al, 1

; 139  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Write2BYTE@@YA_NKEPAPADPAK@Z ENDP			; Write2BYTE
_TEXT	ENDS
PUBLIC	?Write2DWORD@@YA_NKKPAPADPAK@Z			; Write2DWORD
; Function compile flags: /Odtp /ZI
;	COMDAT ?Write2DWORD@@YA_NKKPAPADPAK@Z
_TEXT	SEGMENT
_dwNumber1$ = 8						; size = 4
_dwNumber2$ = 12					; size = 4
_ppBlock$ = 16						; size = 4
_pdwSize$ = 20						; size = 4
?Write2DWORD@@YA_NKKPAPADPAK@Z PROC			; Write2DWORD, COMDAT

; 142  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 143  : 	WriteDWORD ( dwNumber1, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwNumber1$[ebp]
	push	edx
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 144  : 	WriteDWORD ( dwNumber2, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwNumber2$[ebp]
	push	edx
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 145  : 	return true;

	mov	al, 1

; 146  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Write2DWORD@@YA_NKKPAPADPAK@Z ENDP			; Write2DWORD
_TEXT	ENDS
PUBLIC	?WriteCODE@@YA_NKKPAPADPAK@Z			; WriteCODE
; Function compile flags: /Odtp /ZI
;	COMDAT ?WriteCODE@@YA_NKKPAPADPAK@Z
_TEXT	SEGMENT
_dwCode$ = 8						; size = 4
_dwCodeSize$ = 12					; size = 4
_ppBlock$ = 16						; size = 4
_pdwSize$ = 20						; size = 4
?WriteCODE@@YA_NKKPAPADPAK@Z PROC			; WriteCODE, COMDAT

; 149  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 150  : 	WriteDWORD ( dwCode, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 151  : 	WriteDWORD ( dwCodeSize, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwCodeSize$[ebp]
	push	edx
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 152  : 	return true;

	mov	al, 1

; 153  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteCODE@@YA_NKKPAPADPAK@Z ENDP			; WriteCODE
_TEXT	ENDS
PUBLIC	??_C@_02NJPGOMH@?$CFf?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?WriteVECTOR@@YA_NUD3DXVECTOR3@@PAPADPAK@Z	; WriteVECTOR
EXTRN	_sprintf:PROC
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_02NJPGOMH@?$CFf?$AA@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf?$AA@ DB '%f', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?WriteVECTOR@@YA_NUD3DXVECTOR3@@PAPADPAK@Z
_TEXT	SEGMENT
_pNumberStr$56864 = -268				; size = 256
_x$56860 = -12						; size = 4
_dwLen$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_vecVector$ = 8						; size = 12
_ppBlock$ = 20						; size = 4
_pdwSize$ = 24						; size = 4
?WriteVECTOR@@YA_NUD3DXVECTOR3@@PAPADPAK@Z PROC		; WriteVECTOR, COMDAT

; 156  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 157  : 	DWORD dwLen = sizeof(vecVector);

	mov	DWORD PTR _dwLen$[ebp], 12		; 0000000cH

; 158  : 	if ( g_bWriteAsText )

	movzx	eax, BYTE PTR ?g_bWriteAsText@@3_NA	; g_bWriteAsText
	test	eax, eax
	je	$LN7@WriteVECTO

; 159  : 	{
; 160  : 		for ( int x=0; x<3; x++)

	mov	DWORD PTR _x$56860[ebp], 0
	jmp	SHORT $LN6@WriteVECTO
$LN5@WriteVECTO:
	mov	eax, DWORD PTR _x$56860[ebp]
	add	eax, 1
	mov	DWORD PTR _x$56860[ebp], eax
$LN6@WriteVECTO:
	cmp	DWORD PTR _x$56860[ebp], 3
	jge	$LN4@WriteVECTO

; 161  : 		{
; 162  : 			// get matrix element
; 163  : 			char pNumberStr[256];
; 164  : 			sprintf ( pNumberStr, "%f", *(((float*)&vecVector)+x) );

	mov	eax, DWORD PTR _x$56860[ebp]
	fld	DWORD PTR _vecVector$[ebp+eax*4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	lea	ecx, DWORD PTR _pNumberStr$56864[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 165  : 
; 166  : 			// make text value
; 167  : 			dwLen = strlen(pNumberStr);

	lea	eax, DWORD PTR _pNumberStr$56864[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _dwLen$[ebp], eax

; 168  : 			if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN3@WriteVECTO

; 169  : 			{
; 170  : 				memcpy ( *ppBlock, pNumberStr, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pNumberStr$56864[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 171  : 				*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@WriteVECTO:

; 172  : 			}
; 173  : 			*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx

; 174  : 
; 175  : 			// make text comma
; 176  : 			WriteComma ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteComma@@YA_NPAPADPAK@Z		; WriteComma
	add	esp, 8

; 177  : 		}

	jmp	$LN5@WriteVECTO
$LN4@WriteVECTO:

; 178  : 	}
; 179  : 	else

	jmp	SHORT $LN2@WriteVECTO
$LN7@WriteVECTO:

; 180  : 	{
; 181  : 		if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN1@WriteVECTO

; 182  : 		{
; 183  : 			memcpy ( *ppBlock, &vecVector, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecVector$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 184  : 			*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@WriteVECTO:

; 185  : 		}
; 186  : 		*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@WriteVECTO:

; 187  : 	}
; 188  : 	return true;

	mov	al, 1

; 189  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteVECTOR@@YA_NUD3DXVECTOR3@@PAPADPAK@Z ENDP		; WriteVECTOR
_TEXT	ENDS
PUBLIC	??RD3DXMATRIX@@QAEAAMII@Z			; D3DXMATRIX::operator()
PUBLIC	__$ArrayPad$
PUBLIC	?WriteMATRIX@@YA_NUD3DXMATRIX@@PAPADPAK@Z	; WriteMATRIX
; Function compile flags: /Odtp /ZI
;	COMDAT ?WriteMATRIX@@YA_NUD3DXMATRIX@@PAPADPAK@Z
_TEXT	SEGMENT
_pNumberStr$56885 = -272				; size = 256
_x$56881 = -16						; size = 4
_y$56877 = -12						; size = 4
_dwLen$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_mMatrix$ = 8						; size = 64
_ppBlock$ = 72						; size = 4
_pdwSize$ = 76						; size = 4
?WriteMATRIX@@YA_NUD3DXMATRIX@@PAPADPAK@Z PROC		; WriteMATRIX, COMDAT

; 192  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 193  : 	DWORD dwLen = sizeof(mMatrix);

	mov	DWORD PTR _dwLen$[ebp], 64		; 00000040H

; 194  : 	if ( g_bWriteAsText )

	movzx	eax, BYTE PTR ?g_bWriteAsText@@3_NA	; g_bWriteAsText
	test	eax, eax
	je	$LN10@WriteMATRI

; 195  : 	{
; 196  : 		for ( int y=0; y<4; y++)

	mov	DWORD PTR _y$56877[ebp], 0
	jmp	SHORT $LN9@WriteMATRI
$LN8@WriteMATRI:
	mov	eax, DWORD PTR _y$56877[ebp]
	add	eax, 1
	mov	DWORD PTR _y$56877[ebp], eax
$LN9@WriteMATRI:
	cmp	DWORD PTR _y$56877[ebp], 4
	jge	$LN7@WriteMATRI

; 197  : 		{
; 198  : 			for ( int x=0; x<4; x++)

	mov	DWORD PTR _x$56881[ebp], 0
	jmp	SHORT $LN6@WriteMATRI
$LN5@WriteMATRI:
	mov	eax, DWORD PTR _x$56881[ebp]
	add	eax, 1
	mov	DWORD PTR _x$56881[ebp], eax
$LN6@WriteMATRI:
	cmp	DWORD PTR _x$56881[ebp], 4
	jge	$LN4@WriteMATRI

; 199  : 			{
; 200  : 				// get matrix element
; 201  : 				char pNumberStr[256];
; 202  : 				sprintf ( pNumberStr, "%f", mMatrix(x,y) );

	mov	eax, DWORD PTR _y$56877[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$56881[ebp]
	push	ecx
	lea	ecx, DWORD PTR _mMatrix$[ebp]
	call	??RD3DXMATRIX@@QAEAAMII@Z		; D3DXMATRIX::operator()
	fld	DWORD PTR [eax]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	lea	edx, DWORD PTR _pNumberStr$56885[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 203  : 
; 204  : 				// make text value
; 205  : 				dwLen = strlen(pNumberStr);

	lea	eax, DWORD PTR _pNumberStr$56885[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _dwLen$[ebp], eax

; 206  : 				if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN3@WriteMATRI

; 207  : 				{
; 208  : 					memcpy ( *ppBlock, pNumberStr, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pNumberStr$56885[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 209  : 					*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@WriteMATRI:

; 210  : 				}
; 211  : 				*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx

; 212  : 
; 213  : 				// make text comma
; 214  : 				WriteComma ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteComma@@YA_NPAPADPAK@Z		; WriteComma
	add	esp, 8

; 215  : 			}

	jmp	$LN5@WriteMATRI
$LN4@WriteMATRI:

; 216  : 		}

	jmp	$LN8@WriteMATRI
$LN7@WriteMATRI:

; 217  : 	}
; 218  : 	else

	jmp	SHORT $LN2@WriteMATRI
$LN10@WriteMATRI:

; 219  : 	{
; 220  : 		if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN1@WriteMATRI

; 221  : 		{
; 222  : 			memcpy ( *ppBlock, &mMatrix, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mMatrix$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 223  : 			*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@WriteMATRI:

; 224  : 		}
; 225  : 		*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@WriteMATRI:

; 226  : 	}
; 227  : 	return true;

	mov	al, 1

; 228  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteMATRIX@@YA_NUD3DXMATRIX@@PAPADPAK@Z ENDP		; WriteMATRIX
; Function compile flags: /Odtp /ZI
; File c:\program files\microsoft directx sdk (august 2007)\include\d3dx9math.inl
_TEXT	ENDS
;	COMDAT ??RD3DXMATRIX@@QAEAAMII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iRow$ = 8						; size = 4
_iCol$ = 12						; size = 4
??RD3DXMATRIX@@QAEAAMII@Z PROC				; D3DXMATRIX::operator(), COMDAT
; _this$ = ecx

; 788  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 789  :     return m[iRow][iCol];

	mov	eax, DWORD PTR _iRow$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iCol$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 790  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??RD3DXMATRIX@@QAEAAMII@Z ENDP				; D3DXMATRIX::operator()
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?WriteMATERIAL@@YA_NU_D3DMATERIAL9@@PAPADPAK@Z	; WriteMATERIAL
; Function compile flags: /Odtp /ZI
; File c:\program files\the game creators\dark gdk\include\dbo format\dboblock.cpp
;	COMDAT ?WriteMATERIAL@@YA_NU_D3DMATERIAL9@@PAPADPAK@Z
_TEXT	SEGMENT
_pNumberStr$56901 = -272				; size = 256
_i$56897 = -16						; size = 4
_dwBytes$56896 = -12					; size = 4
_dwLen$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_mMaterial$ = 8						; size = 68
_ppBlock$ = 76						; size = 4
_pdwSize$ = 80						; size = 4
?WriteMATERIAL@@YA_NU_D3DMATERIAL9@@PAPADPAK@Z PROC	; WriteMATERIAL, COMDAT

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 232  : 	DWORD dwLen = sizeof(mMaterial);

	mov	DWORD PTR _dwLen$[ebp], 68		; 00000044H

; 233  : 	if ( g_bWriteAsText )

	movzx	eax, BYTE PTR ?g_bWriteAsText@@3_NA	; g_bWriteAsText
	test	eax, eax
	je	$LN7@WriteMATER

; 234  : 	{
; 235  : 		DWORD dwBytes = sizeof(mMaterial);

	mov	DWORD PTR _dwBytes$56896[ebp], 68	; 00000044H

; 236  : 		for ( DWORD i=0; i<dwBytes; i++)

	mov	DWORD PTR _i$56897[ebp], 0
	jmp	SHORT $LN6@WriteMATER
$LN5@WriteMATER:
	mov	eax, DWORD PTR _i$56897[ebp]
	add	eax, 1
	mov	DWORD PTR _i$56897[ebp], eax
$LN6@WriteMATER:
	mov	eax, DWORD PTR _i$56897[ebp]
	cmp	eax, DWORD PTR _dwBytes$56896[ebp]
	jae	SHORT $LN4@WriteMATER

; 237  : 		{
; 238  : 			// byte from material
; 239  : 			char pNumberStr[256];
; 240  : 			_itoa ( *((BYTE*)&mMaterial+i) , pNumberStr, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _pNumberStr$56901[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$56897[ebp]
	movzx	edx, BYTE PTR _mMaterial$[ebp+ecx]
	push	edx
	call	__itoa
	add	esp, 12					; 0000000cH

; 241  : 
; 242  : 			// make text value
; 243  : 			dwLen = strlen(pNumberStr);

	lea	eax, DWORD PTR _pNumberStr$56901[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _dwLen$[ebp], eax

; 244  : 			if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN3@WriteMATER

; 245  : 			{
; 246  : 				memcpy ( *ppBlock, pNumberStr, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pNumberStr$56901[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 247  : 				*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@WriteMATER:

; 248  : 			}
; 249  : 			*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx

; 250  : 
; 251  : 			// make text comma
; 252  : 			WriteComma ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteComma@@YA_NPAPADPAK@Z		; WriteComma
	add	esp, 8

; 253  : 		}

	jmp	$LN5@WriteMATER
$LN4@WriteMATER:

; 254  : 	}
; 255  : 	else

	jmp	SHORT $LN2@WriteMATER
$LN7@WriteMATER:

; 256  : 	{
; 257  : 		if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN1@WriteMATER

; 258  : 		{
; 259  : 			memcpy ( *ppBlock, &mMaterial, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mMaterial$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 260  : 			*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@WriteMATER:

; 261  : 		}
; 262  : 		*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@WriteMATER:

; 263  : 	}
; 264  : 	return true;

	mov	al, 1

; 265  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteMATERIAL@@YA_NU_D3DMATERIAL9@@PAPADPAK@Z ENDP	; WriteMATERIAL
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?WriteMEMORY@@YA_NPAEKPAPADPAK@Z		; WriteMEMORY
; Function compile flags: /Odtp /ZI
;	COMDAT ?WriteMEMORY@@YA_NPAEKPAPADPAK@Z
_TEXT	SEGMENT
_dwLen$56918 = -268					; size = 4
_pNumberStr$56917 = -264				; size = 256
_i$56913 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pData$ = 8						; size = 4
_dwBytes$ = 12						; size = 4
_ppBlock$ = 16						; size = 4
_pdwSize$ = 20						; size = 4
?WriteMEMORY@@YA_NPAEKPAPADPAK@Z PROC			; WriteMEMORY, COMDAT

; 268  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 269  : 	if ( g_bWriteAsText )

	movzx	eax, BYTE PTR ?g_bWriteAsText@@3_NA	; g_bWriteAsText
	test	eax, eax
	je	$LN7@WriteMEMOR

; 270  : 	{
; 271  : 		for ( DWORD i=0; i<dwBytes; i++)

	mov	DWORD PTR _i$56913[ebp], 0
	jmp	SHORT $LN6@WriteMEMOR
$LN5@WriteMEMOR:
	mov	eax, DWORD PTR _i$56913[ebp]
	add	eax, 1
	mov	DWORD PTR _i$56913[ebp], eax
$LN6@WriteMEMOR:
	mov	eax, DWORD PTR _i$56913[ebp]
	cmp	eax, DWORD PTR _dwBytes$[ebp]
	jae	$LN4@WriteMEMOR

; 272  : 		{
; 273  : 			// byte from material
; 274  : 			char pNumberStr[256];
; 275  : 			_itoa ( *(pData+i) , pNumberStr, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _pNumberStr$56917[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	add	ecx, DWORD PTR _i$56913[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	__itoa
	add	esp, 12					; 0000000cH

; 276  : 
; 277  : 			// make text value
; 278  : 			DWORD dwLen = strlen(pNumberStr);

	lea	eax, DWORD PTR _pNumberStr$56917[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _dwLen$56918[ebp], eax

; 279  : 			if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN3@WriteMEMOR

; 280  : 			{
; 281  : 				memcpy ( *ppBlock, pNumberStr, dwLen );

	mov	eax, DWORD PTR _dwLen$56918[ebp]
	push	eax
	lea	ecx, DWORD PTR _pNumberStr$56917[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 282  : 				*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$56918[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@WriteMEMOR:

; 283  : 			}
; 284  : 			*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$56918[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx

; 285  : 
; 286  : 			// make text comma
; 287  : 			WriteComma ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteComma@@YA_NPAPADPAK@Z		; WriteComma
	add	esp, 8

; 288  : 		}

	jmp	$LN5@WriteMEMOR
$LN4@WriteMEMOR:

; 289  : 	}
; 290  : 	else

	jmp	SHORT $LN2@WriteMEMOR
$LN7@WriteMEMOR:

; 291  : 	{
; 292  : 		if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN1@WriteMEMOR

; 293  : 		{
; 294  : 			memcpy ( *ppBlock, pData, dwBytes );

	mov	eax, DWORD PTR _dwBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 295  : 			*ppBlock += dwBytes;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwBytes$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@WriteMEMOR:

; 296  : 		}
; 297  : 		*pdwSize += dwBytes;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwBytes$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@WriteMEMOR:

; 298  : 	}
; 299  : 	return true;

	mov	al, 1

; 300  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteMEMORY@@YA_NPAEKPAPADPAK@Z ENDP			; WriteMEMORY
_TEXT	ENDS
PUBLIC	?WriteString@@YA_NPADPAPADPAK@Z			; WriteString
; Function compile flags: /Odtp /ZI
;	COMDAT ?WriteString@@YA_NPADPAPADPAK@Z
_TEXT	SEGMENT
_dwLen$ = -4						; size = 4
_pString$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
_pdwSize$ = 16						; size = 4
?WriteString@@YA_NPADPAPADPAK@Z PROC			; WriteString, COMDAT

; 303  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 304  : 	DWORD dwLen = strlen(pString);

	mov	eax, DWORD PTR _pString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _dwLen$[ebp], eax

; 305  : 	if ( g_bWriteAsText )

	movzx	eax, BYTE PTR ?g_bWriteAsText@@3_NA	; g_bWriteAsText
	test	eax, eax
	je	SHORT $LN4@WriteStrin

; 306  : 	{
; 307  : 		// make text speechmark
; 308  : 		WriteSpeechmark ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteSpeechmark@@YA_NPAPADPAK@Z	; WriteSpeechmark
	add	esp, 8

; 309  : 
; 310  : 		// make text
; 311  : 		if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN3@WriteStrin

; 312  : 		{
; 313  : 			memcpy ( *ppBlock, pString, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 314  : 			*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@WriteStrin:

; 315  : 		}
; 316  : 		*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx

; 317  : 
; 318  : 		// make text speechmark
; 319  : 		WriteSpeechmark ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteSpeechmark@@YA_NPAPADPAK@Z	; WriteSpeechmark
	add	esp, 8

; 320  : 		WriteComma ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteComma@@YA_NPAPADPAK@Z		; WriteComma
	add	esp, 8

; 321  : 	}
; 322  : 	else

	jmp	SHORT $LN2@WriteStrin
$LN4@WriteStrin:

; 323  : 	{
; 324  : 		if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN1@WriteStrin

; 325  : 		{
; 326  : 			// string size
; 327  : 			*(DWORD*)*ppBlock = dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _dwLen$[ebp]
	mov	DWORD PTR [ecx], edx

; 328  : 			*ppBlock += 4;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx

; 329  : 
; 330  : 			// string data
; 331  : 			memcpy ( *ppBlock, pString, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 332  : 			*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@WriteStrin:

; 333  : 		}
; 334  : 		*pdwSize += 4 + dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _dwLen$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	mov	ecx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [ecx], eax
$LN2@WriteStrin:

; 335  : 	}
; 336  : 	return true;

	mov	al, 1

; 337  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteString@@YA_NPADPAPADPAK@Z ENDP			; WriteString
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?WriteVertexData@@YA_NPAEKKPAPADPAK@Z		; WriteVertexData
; Function compile flags: /Odtp /ZI
;	COMDAT ?WriteVertexData@@YA_NPAEKKPAPADPAK@Z
_TEXT	SEGMENT
_pNumberStr$56948 = -272				; size = 256
_i$56944 = -16						; size = 4
_dwBytes$56943 = -12					; size = 4
_dwLen$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pVertexData$ = 8					; size = 4
_dwFVFSize$ = 12					; size = 4
_dwVertexCount$ = 16					; size = 4
_ppBlock$ = 20						; size = 4
_pdwSize$ = 24						; size = 4
?WriteVertexData@@YA_NPAEKKPAPADPAK@Z PROC		; WriteVertexData, COMDAT

; 340  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 341  : 	// No vertex data
; 342  : 	if ( pVertexData==NULL )

	cmp	DWORD PTR _pVertexData$[ebp], 0
	jne	SHORT $LN8@WriteVerte

; 343  : 	{
; 344  : 		WriteDWORD ( 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 345  : 		return true;

	mov	al, 1
	jmp	$LN9@WriteVerte
$LN8@WriteVerte:

; 346  : 	}
; 347  : 
; 348  : 	DWORD dwLen = dwFVFSize * dwVertexCount;

	mov	eax, DWORD PTR _dwFVFSize$[ebp]
	imul	eax, DWORD PTR _dwVertexCount$[ebp]
	mov	DWORD PTR _dwLen$[ebp], eax

; 349  : 	if ( g_bWriteAsText )

	movzx	eax, BYTE PTR ?g_bWriteAsText@@3_NA	; g_bWriteAsText
	test	eax, eax
	je	$LN7@WriteVerte

; 350  : 	{
; 351  : 		DWORD dwBytes = dwVertexCount*dwFVFSize;

	mov	eax, DWORD PTR _dwVertexCount$[ebp]
	imul	eax, DWORD PTR _dwFVFSize$[ebp]
	mov	DWORD PTR _dwBytes$56943[ebp], eax

; 352  : 		for ( DWORD i=0; i<dwBytes; i++)

	mov	DWORD PTR _i$56944[ebp], 0
	jmp	SHORT $LN6@WriteVerte
$LN5@WriteVerte:
	mov	eax, DWORD PTR _i$56944[ebp]
	add	eax, 1
	mov	DWORD PTR _i$56944[ebp], eax
$LN6@WriteVerte:
	mov	eax, DWORD PTR _i$56944[ebp]
	cmp	eax, DWORD PTR _dwBytes$56943[ebp]
	jae	SHORT $LN4@WriteVerte

; 353  : 		{
; 354  : 			// byte from data
; 355  : 			char pNumberStr[256];
; 356  : 			_itoa ( *(pVertexData+i) , pNumberStr, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _pNumberStr$56948[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVertexData$[ebp]
	add	ecx, DWORD PTR _i$56944[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	__itoa
	add	esp, 12					; 0000000cH

; 357  : 
; 358  : 			// make text value
; 359  : 			dwLen = strlen(pNumberStr);

	lea	eax, DWORD PTR _pNumberStr$56948[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _dwLen$[ebp], eax

; 360  : 			if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN3@WriteVerte

; 361  : 			{
; 362  : 				memcpy ( *ppBlock, pNumberStr, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pNumberStr$56948[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 363  : 				*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@WriteVerte:

; 364  : 			}
; 365  : 			*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx

; 366  : 
; 367  : 			// make text comma
; 368  : 			WriteComma ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteComma@@YA_NPAPADPAK@Z		; WriteComma
	add	esp, 8

; 369  : 		}

	jmp	$LN5@WriteVerte
$LN4@WriteVerte:

; 370  : 	}
; 371  : 	else

	jmp	SHORT $LN2@WriteVerte
$LN7@WriteVerte:

; 372  : 	{
; 373  : 		if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN1@WriteVerte

; 374  : 		{
; 375  : 			memcpy ( *ppBlock, pVertexData, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVertexData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 376  : 			*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@WriteVerte:

; 377  : 		}
; 378  : 		*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@WriteVerte:

; 379  : 	}
; 380  : 
; 381  : 	// okay
; 382  : 	return true;

	mov	al, 1
$LN9@WriteVerte:

; 383  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteVertexData@@YA_NPAEKKPAPADPAK@Z ENDP		; WriteVertexData
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?WriteIndices@@YA_NPAGKPAPADPAK@Z		; WriteIndices
; Function compile flags: /Odtp /ZI
;	COMDAT ?WriteIndices@@YA_NPAGKPAPADPAK@Z
_TEXT	SEGMENT
_pNumberStr$56966 = -268				; size = 256
_i$56962 = -12						; size = 4
_dwLen$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pIndices$ = 8						; size = 4
_dwIndexCount$ = 12					; size = 4
_ppBlock$ = 16						; size = 4
_pdwSize$ = 20						; size = 4
?WriteIndices@@YA_NPAGKPAPADPAK@Z PROC			; WriteIndices, COMDAT

; 386  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 387  : 	// No indices
; 388  : 	if ( pIndices==NULL )

	cmp	DWORD PTR _pIndices$[ebp], 0
	jne	SHORT $LN8@WriteIndic

; 389  : 	{
; 390  : 		WriteDWORD ( 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 391  : 		return true;

	mov	al, 1
	jmp	$LN9@WriteIndic
$LN8@WriteIndic:

; 392  : 	}
; 393  : 	
; 394  : 	DWORD dwLen = dwIndexCount * sizeof(WORD);

	mov	eax, DWORD PTR _dwIndexCount$[ebp]
	shl	eax, 1
	mov	DWORD PTR _dwLen$[ebp], eax

; 395  : 	if ( g_bWriteAsText )

	movzx	eax, BYTE PTR ?g_bWriteAsText@@3_NA	; g_bWriteAsText
	test	eax, eax
	je	$LN7@WriteIndic

; 396  : 	{
; 397  : 		for ( DWORD i=0; i<dwIndexCount; i++)

	mov	DWORD PTR _i$56962[ebp], 0
	jmp	SHORT $LN6@WriteIndic
$LN5@WriteIndic:
	mov	eax, DWORD PTR _i$56962[ebp]
	add	eax, 1
	mov	DWORD PTR _i$56962[ebp], eax
$LN6@WriteIndic:
	mov	eax, DWORD PTR _i$56962[ebp]
	cmp	eax, DWORD PTR _dwIndexCount$[ebp]
	jae	SHORT $LN4@WriteIndic

; 398  : 		{
; 399  : 			// byte from data
; 400  : 			char pNumberStr[256];
; 401  : 			_itoa ( *((WORD*)pIndices+i) , pNumberStr, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _pNumberStr$56966[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$56962[ebp]
	mov	edx, DWORD PTR _pIndices$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2]
	push	eax
	call	__itoa
	add	esp, 12					; 0000000cH

; 402  : 
; 403  : 			// make text value
; 404  : 			dwLen = strlen(pNumberStr);

	lea	eax, DWORD PTR _pNumberStr$56966[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _dwLen$[ebp], eax

; 405  : 			if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN3@WriteIndic

; 406  : 			{
; 407  : 				memcpy ( *ppBlock, pNumberStr, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pNumberStr$56966[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 408  : 				*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@WriteIndic:

; 409  : 			}
; 410  : 			*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx

; 411  : 
; 412  : 			// make text comma
; 413  : 			WriteComma ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteComma@@YA_NPAPADPAK@Z		; WriteComma
	add	esp, 8

; 414  : 		}

	jmp	$LN5@WriteIndic
$LN4@WriteIndic:

; 415  : 	}
; 416  : 	else

	jmp	SHORT $LN2@WriteIndic
$LN7@WriteIndic:

; 417  : 	{
; 418  : 		if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN1@WriteIndic

; 419  : 		{
; 420  : 			memcpy ( *ppBlock, pIndices, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pIndices$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 421  : 			*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@WriteIndic:

; 422  : 		}
; 423  : 		*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@WriteIndic:

; 424  : 	}
; 425  : 
; 426  : 	// okay
; 427  : 	return true;

	mov	al, 1
$LN9@WriteIndic:

; 428  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteIndices@@YA_NPAGKPAPADPAK@Z ENDP			; WriteIndices
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?WriteOffsetList@@YA_NPAHKPAPADPAK@Z		; WriteOffsetList
; Function compile flags: /Odtp /ZI
;	COMDAT ?WriteOffsetList@@YA_NPAHKPAPADPAK@Z
_TEXT	SEGMENT
_pNumberStr$56985 = -268				; size = 256
_i$56981 = -12						; size = 4
_dwLen$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pIndices$ = 8						; size = 4
_dwIndexCount$ = 12					; size = 4
_ppBlock$ = 16						; size = 4
_pdwSize$ = 20						; size = 4
?WriteOffsetList@@YA_NPAHKPAPADPAK@Z PROC		; WriteOffsetList, COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 432  : 	// No indices
; 433  : 	if ( pIndices==NULL )

	cmp	DWORD PTR _pIndices$[ebp], 0
	jne	SHORT $LN8@WriteOffse

; 434  : 	{
; 435  : 		WriteDWORD ( 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 436  : 		return true;

	mov	al, 1
	jmp	$LN9@WriteOffse
$LN8@WriteOffse:

; 437  : 	}
; 438  : 	
; 439  : 	DWORD dwLen = dwIndexCount * sizeof(int);

	mov	eax, DWORD PTR _dwIndexCount$[ebp]
	shl	eax, 2
	mov	DWORD PTR _dwLen$[ebp], eax

; 440  : 	if ( g_bWriteAsText )

	movzx	eax, BYTE PTR ?g_bWriteAsText@@3_NA	; g_bWriteAsText
	test	eax, eax
	je	$LN7@WriteOffse

; 441  : 	{
; 442  : 		for ( DWORD i=0; i<dwIndexCount; i++)

	mov	DWORD PTR _i$56981[ebp], 0
	jmp	SHORT $LN6@WriteOffse
$LN5@WriteOffse:
	mov	eax, DWORD PTR _i$56981[ebp]
	add	eax, 1
	mov	DWORD PTR _i$56981[ebp], eax
$LN6@WriteOffse:
	mov	eax, DWORD PTR _i$56981[ebp]
	cmp	eax, DWORD PTR _dwIndexCount$[ebp]
	jae	SHORT $LN4@WriteOffse

; 443  : 		{
; 444  : 			// byte from data
; 445  : 			char pNumberStr[256];
; 446  : 			_itoa ( *((WORD*)pIndices+i) , pNumberStr, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _pNumberStr$56985[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$56981[ebp]
	mov	edx, DWORD PTR _pIndices$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2]
	push	eax
	call	__itoa
	add	esp, 12					; 0000000cH

; 447  : 
; 448  : 			// make text value
; 449  : 			dwLen = strlen(pNumberStr);

	lea	eax, DWORD PTR _pNumberStr$56985[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _dwLen$[ebp], eax

; 450  : 			if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN3@WriteOffse

; 451  : 			{
; 452  : 				memcpy ( *ppBlock, pNumberStr, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pNumberStr$56985[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 453  : 				*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@WriteOffse:

; 454  : 			}
; 455  : 			*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx

; 456  : 
; 457  : 			// make text comma
; 458  : 			WriteComma ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteComma@@YA_NPAPADPAK@Z		; WriteComma
	add	esp, 8

; 459  : 		}

	jmp	$LN5@WriteOffse
$LN4@WriteOffse:

; 460  : 	}
; 461  : 	else

	jmp	SHORT $LN2@WriteOffse
$LN7@WriteOffse:

; 462  : 	{
; 463  : 		if ( ppBlock )

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN1@WriteOffse

; 464  : 		{
; 465  : 			memcpy ( *ppBlock, pIndices, dwLen );

	mov	eax, DWORD PTR _dwLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pIndices$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 466  : 			*ppBlock += dwLen;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@WriteOffse:

; 467  : 		}
; 468  : 		*pdwSize += dwLen;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLen$[ebp]
	mov	edx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@WriteOffse:

; 469  : 	}
; 470  : 
; 471  : 	// okay
; 472  : 	return true;

	mov	al, 1
$LN9@WriteOffse:

; 473  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteOffsetList@@YA_NPAHKPAPADPAK@Z ENDP		; WriteOffsetList
_TEXT	ENDS
PUBLIC	?ReadBOOL@@YA_NPA_NPAPAD@Z			; ReadBOOL
; Function compile flags: /Odtp /ZI
;	COMDAT ?ReadBOOL@@YA_NPA_NPAPAD@Z
_TEXT	SEGMENT
_ppDest$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
?ReadBOOL@@YA_NPA_NPAPAD@Z PROC				; ReadBOOL, COMDAT

; 481  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 482  : 	// length of string
; 483  : 	if ( *(BYTE*)*ppBlock==0 )

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN2@ReadBOOL

; 484  : 		*(ppDest) = false;

	mov	eax, DWORD PTR _ppDest$[ebp]
	mov	BYTE PTR [eax], 0

; 485  : 	else

	jmp	SHORT $LN1@ReadBOOL
$LN2@ReadBOOL:

; 486  : 		*(ppDest) = true;

	mov	eax, DWORD PTR _ppDest$[ebp]
	mov	BYTE PTR [eax], 1
$LN1@ReadBOOL:

; 487  : 
; 488  : 	*ppBlock += 1;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx

; 489  : 
; 490  : 	// okay
; 491  : 	return true;

	mov	al, 1

; 492  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadBOOL@@YA_NPA_NPAPAD@Z ENDP				; ReadBOOL
_TEXT	ENDS
PUBLIC	?ReadDWORD@@YA_NPAKPAPAD@Z			; ReadDWORD
; Function compile flags: /Odtp /ZI
;	COMDAT ?ReadDWORD@@YA_NPAKPAPAD@Z
_TEXT	SEGMENT
_ppDest$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
?ReadDWORD@@YA_NPAKPAPAD@Z PROC				; ReadDWORD, COMDAT

; 495  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 496  : 	// length of string
; 497  : 	*(ppDest) = *(DWORD*)*ppBlock;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _ppDest$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 498  : 	*ppBlock += 4;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx

; 499  : 
; 500  : 	// okay
; 501  : 	return true;

	mov	al, 1

; 502  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadDWORD@@YA_NPAKPAPAD@Z ENDP				; ReadDWORD
_TEXT	ENDS
PUBLIC	?ReadCODE@@YA_NPAK0PAPAD@Z			; ReadCODE
; Function compile flags: /Odtp /ZI
;	COMDAT ?ReadCODE@@YA_NPAK0PAPAD@Z
_TEXT	SEGMENT
_pdwCode$ = 8						; size = 4
_pdwCodeSize$ = 12					; size = 4
_ppBlock$ = 16						; size = 4
?ReadCODE@@YA_NPAK0PAPAD@Z PROC				; ReadCODE, COMDAT

; 505  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 506  : 	// code and codesize
; 507  : 	*(pdwCode) = *(DWORD*)*ppBlock;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pdwCode$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 508  : 	*ppBlock += 4;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx

; 509  : 	*(pdwCodeSize) = *(DWORD*)*ppBlock;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pdwCodeSize$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 510  : 	*ppBlock += 4;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx

; 511  : 
; 512  : 	// okay
; 513  : 	return true;

	mov	al, 1

; 514  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadCODE@@YA_NPAK0PAPAD@Z ENDP				; ReadCODE
_TEXT	ENDS
PUBLIC	?ReadVector@@YA_NPAUD3DXVECTOR3@@PAPAD@Z	; ReadVector
; Function compile flags: /Odtp /ZI
;	COMDAT ?ReadVector@@YA_NPAUD3DXVECTOR3@@PAPAD@Z
_TEXT	SEGMENT
_dwLength$ = -4						; size = 4
_pVector$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
?ReadVector@@YA_NPAUD3DXVECTOR3@@PAPAD@Z PROC		; ReadVector, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 518  : 	DWORD dwLength = sizeof(D3DXVECTOR3);

	mov	DWORD PTR _dwLength$[ebp], 12		; 0000000cH

; 519  : 	memcpy ( pVector, *ppBlock, dwLength );

	mov	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pVector$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 520  : 	*ppBlock += dwLength;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLength$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx

; 521  : 	return true;

	mov	al, 1

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadVector@@YA_NPAUD3DXVECTOR3@@PAPAD@Z ENDP		; ReadVector
_TEXT	ENDS
PUBLIC	?ReadMatrix@@YA_NPAUD3DXMATRIX@@PAPAD@Z		; ReadMatrix
; Function compile flags: /Odtp /ZI
;	COMDAT ?ReadMatrix@@YA_NPAUD3DXMATRIX@@PAPAD@Z
_TEXT	SEGMENT
_dwLength$ = -4						; size = 4
_pMatrix$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
?ReadMatrix@@YA_NPAUD3DXMATRIX@@PAPAD@Z PROC		; ReadMatrix, COMDAT

; 525  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 526  : 	DWORD dwLength = sizeof(D3DXMATRIX);

	mov	DWORD PTR _dwLength$[ebp], 64		; 00000040H

; 527  : 	memcpy ( pMatrix, *ppBlock, dwLength );

	mov	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pMatrix$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 528  : 	*ppBlock += dwLength;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLength$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx

; 529  : 	return true;

	mov	al, 1

; 530  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadMatrix@@YA_NPAUD3DXMATRIX@@PAPAD@Z ENDP		; ReadMatrix
_TEXT	ENDS
PUBLIC	?ReadMaterial@@YA_NPAU_D3DMATERIAL9@@PAPAD@Z	; ReadMaterial
; Function compile flags: /Odtp /ZI
;	COMDAT ?ReadMaterial@@YA_NPAU_D3DMATERIAL9@@PAPAD@Z
_TEXT	SEGMENT
_dwLength$ = -4						; size = 4
_pMaterial$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
?ReadMaterial@@YA_NPAU_D3DMATERIAL9@@PAPAD@Z PROC	; ReadMaterial, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 534  : 	DWORD dwLength = sizeof(D3DMATERIAL9);

	mov	DWORD PTR _dwLength$[ebp], 68		; 00000044H

; 535  : 	memcpy ( pMaterial, *ppBlock, dwLength );

	mov	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pMaterial$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 536  : 	*ppBlock += dwLength;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLength$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx

; 537  : 	return true;

	mov	al, 1

; 538  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadMaterial@@YA_NPAU_D3DMATERIAL9@@PAPAD@Z ENDP	; ReadMaterial
_TEXT	ENDS
PUBLIC	?ReadMemory@@YA_NPAPAEKPAPAD@Z			; ReadMemory
EXTRN	??2@YAPAXI@Z:PROC				; operator new
; Function compile flags: /Odtp /ZI
;	COMDAT ?ReadMemory@@YA_NPAPAEKPAPAD@Z
_TEXT	SEGMENT
$T57993 = -68						; size = 4
_ppData$ = 8						; size = 4
_dwBytes$ = 12						; size = 4
_ppBlock$ = 16						; size = 4
?ReadMemory@@YA_NPAPAEKPAPAD@Z PROC			; ReadMemory, COMDAT

; 541  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 542  : 	if ( (*ppData)==NULL ) (*ppData) = (BYTE*)new char [ dwBytes ];

	mov	eax, DWORD PTR _ppData$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@ReadMemory
	mov	eax, DWORD PTR _dwBytes$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T57993[ebp], eax
	mov	ecx, DWORD PTR _ppData$[ebp]
	mov	edx, DWORD PTR $T57993[ebp]
	mov	DWORD PTR [ecx], edx
$LN1@ReadMemory:

; 543  : 	memcpy ( (*ppData), *ppBlock, dwBytes );

	mov	eax, DWORD PTR _dwBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _ppData$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 544  : 	*ppBlock += dwBytes;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwBytes$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx

; 545  : 	return true;

	mov	al, 1

; 546  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadMemory@@YA_NPAPAEKPAPAD@Z ENDP			; ReadMemory
_TEXT	ENDS
PUBLIC	?ReadIntoMemory@@YA_NPAEKPAPAD@Z		; ReadIntoMemory
; Function compile flags: /Odtp /ZI
;	COMDAT ?ReadIntoMemory@@YA_NPAEKPAPAD@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
_dwBytes$ = 12						; size = 4
_ppBlock$ = 16						; size = 4
?ReadIntoMemory@@YA_NPAEKPAPAD@Z PROC			; ReadIntoMemory, COMDAT

; 549  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 550  : 	memcpy ( pData, *ppBlock, dwBytes );

	mov	eax, DWORD PTR _dwBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pData$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 551  : 	*ppBlock += dwBytes;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwBytes$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx

; 552  : 	return true;

	mov	al, 1

; 553  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadIntoMemory@@YA_NPAEKPAPAD@Z ENDP			; ReadIntoMemory
_TEXT	ENDS
PUBLIC	?ReadString@@YA_NPADPAPAD@Z			; ReadString
; Function compile flags: /Odtp /ZI
;	COMDAT ?ReadString@@YA_NPADPAPAD@Z
_TEXT	SEGMENT
$T57998 = -76						; size = 4
_dwLength$ = -8						; size = 4
_dwFullLength$ = -4					; size = 4
_pString$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
?ReadString@@YA_NPADPAPAD@Z PROC			; ReadString, COMDAT

; 556  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 557  : 	// length of string
; 558  : 	DWORD dwFullLength = *(DWORD*)*ppBlock;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _dwFullLength$[ebp], edx

; 559  : 	*ppBlock += 4;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx

; 560  : 
; 561  : 	// limit string size
; 562  : 	DWORD dwLength = dwFullLength;

	mov	eax, DWORD PTR _dwFullLength$[ebp]
	mov	DWORD PTR _dwLength$[ebp], eax

; 563  : 	if ( dwLength > 255 ) dwLength=255;

	cmp	DWORD PTR _dwLength$[ebp], 255		; 000000ffH
	jbe	SHORT $LN3@ReadString
	mov	DWORD PTR _dwLength$[ebp], 255		; 000000ffH
$LN3@ReadString:

; 564  : 	if ( dwLength > 0 )

	cmp	DWORD PTR _dwLength$[ebp], 0
	jbe	SHORT $LN2@ReadString

; 565  : 	{
; 566  : 		// create if not present
; 567  : 		if ( pString==NULL ) pString = new char[dwLength+1];

	cmp	DWORD PTR _pString$[ebp], 0
	jne	SHORT $LN1@ReadString
	mov	eax, DWORD PTR _dwLength$[ebp]
	add	eax, 1
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T57998[ebp], eax
	mov	ecx, DWORD PTR $T57998[ebp]
	mov	DWORD PTR _pString$[ebp], ecx
$LN1@ReadString:

; 568  : 
; 569  : 		// copy string
; 570  : 		memcpy ( pString, *ppBlock, dwLength );

	mov	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pString$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 571  : 		pString [ dwLength ] = 0;

	mov	eax, DWORD PTR _pString$[ebp]
	add	eax, DWORD PTR _dwLength$[ebp]
	mov	BYTE PTR [eax], 0

; 572  : 		*ppBlock += dwFullLength;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwFullLength$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@ReadString:

; 573  : 	}
; 574  : 
; 575  : 	// okay
; 576  : 	return true;

	mov	al, 1

; 577  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadString@@YA_NPADPAPAD@Z ENDP			; ReadString
_TEXT	ENDS
PUBLIC	?ReadVertexData@@YA_NPAPAEKKPAPAD@Z		; ReadVertexData
; Function compile flags: /Odtp /ZI
;	COMDAT ?ReadVertexData@@YA_NPAPAEKKPAPAD@Z
_TEXT	SEGMENT
$T58001 = -72						; size = 4
_dwLength$ = -4						; size = 4
_pbVertexData$ = 8					; size = 4
_dwFVFSize$ = 12					; size = 4
_dwVertexCount$ = 16					; size = 4
_ppBlock$ = 20						; size = 4
?ReadVertexData@@YA_NPAPAEKKPAPAD@Z PROC		; ReadVertexData, COMDAT

; 580  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 581  : 	DWORD dwLength = dwFVFSize * dwVertexCount;

	mov	eax, DWORD PTR _dwFVFSize$[ebp]
	imul	eax, DWORD PTR _dwVertexCount$[ebp]
	mov	DWORD PTR _dwLength$[ebp], eax

; 582  : 	if ( dwLength > 0 )

	cmp	DWORD PTR _dwLength$[ebp], 0
	jbe	SHORT $LN1@ReadVertex

; 583  : 	{
; 584  : 		(*pbVertexData) = (BYTE*)new char [ dwLength ];

	mov	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58001[ebp], eax
	mov	ecx, DWORD PTR _pbVertexData$[ebp]
	mov	edx, DWORD PTR $T58001[ebp]
	mov	DWORD PTR [ecx], edx

; 585  : 		memcpy ( (*pbVertexData), *ppBlock, dwLength );

	mov	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pbVertexData$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 586  : 		*ppBlock += dwLength;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLength$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@ReadVertex:

; 587  : 	}
; 588  : 	return true;

	mov	al, 1

; 589  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadVertexData@@YA_NPAPAEKKPAPAD@Z ENDP		; ReadVertexData
_TEXT	ENDS
PUBLIC	?ReadIndexData@@YA_NPAPAGKPAPAD@Z		; ReadIndexData
; Function compile flags: /Odtp /ZI
;	COMDAT ?ReadIndexData@@YA_NPAPAGKPAPAD@Z
_TEXT	SEGMENT
$T58004 = -72						; size = 4
_dwLength$ = -4						; size = 4
_pwIndexData$ = 8					; size = 4
_dwIndexCount$ = 12					; size = 4
_ppBlock$ = 16						; size = 4
?ReadIndexData@@YA_NPAPAGKPAPAD@Z PROC			; ReadIndexData, COMDAT

; 592  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 593  : 	DWORD dwLength = sizeof(WORD) * dwIndexCount;

	mov	eax, DWORD PTR _dwIndexCount$[ebp]
	shl	eax, 1
	mov	DWORD PTR _dwLength$[ebp], eax

; 594  : 	if ( dwLength > 0 )

	je	SHORT $LN1@ReadIndexD

; 595  : 	{
; 596  : 		(*pwIndexData) = (WORD*)new char [ dwLength ];

	mov	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58004[ebp], eax
	mov	ecx, DWORD PTR _pwIndexData$[ebp]
	mov	edx, DWORD PTR $T58004[ebp]
	mov	DWORD PTR [ecx], edx

; 597  : 		memcpy ( (*pwIndexData), *ppBlock, dwLength );

	mov	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pwIndexData$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 598  : 		*ppBlock += dwLength;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLength$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@ReadIndexD:

; 599  : 	}
; 600  : 	return true;

	mov	al, 1

; 601  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadIndexData@@YA_NPAPAGKPAPAD@Z ENDP			; ReadIndexData
_TEXT	ENDS
PUBLIC	?ReadOffsetListData@@YA_NPAPAHKPAPAD@Z		; ReadOffsetListData
; Function compile flags: /Odtp /ZI
;	COMDAT ?ReadOffsetListData@@YA_NPAPAHKPAPAD@Z
_TEXT	SEGMENT
$T58007 = -72						; size = 4
_dwLength$ = -4						; size = 4
_pwIndexData$ = 8					; size = 4
_dwIndexCount$ = 12					; size = 4
_ppBlock$ = 16						; size = 4
?ReadOffsetListData@@YA_NPAPAHKPAPAD@Z PROC		; ReadOffsetListData, COMDAT

; 604  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 605  : 	DWORD dwLength = sizeof(int) * dwIndexCount;

	mov	eax, DWORD PTR _dwIndexCount$[ebp]
	shl	eax, 2
	mov	DWORD PTR _dwLength$[ebp], eax

; 606  : 	if ( dwLength > 0 )

	cmp	DWORD PTR _dwLength$[ebp], 0
	jbe	SHORT $LN1@ReadOffset

; 607  : 	{
; 608  : 		(*pwIndexData) = (int*)new char [ dwLength ];

	mov	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58007[ebp], eax
	mov	ecx, DWORD PTR _pwIndexData$[ebp]
	mov	edx, DWORD PTR $T58007[ebp]
	mov	DWORD PTR [ecx], edx

; 609  : 		memcpy ( (*pwIndexData), *ppBlock, dwLength );

	mov	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pwIndexData$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 610  : 		*ppBlock += dwLength;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLength$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@ReadOffset:

; 611  : 	}
; 612  : 	return true;

	mov	al, 1

; 613  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadOffsetListData@@YA_NPAPAHKPAPAD@Z ENDP		; ReadOffsetListData
_TEXT	ENDS
PUBLIC	?ScanBones@@YA_NPAUsBone@@KPAPADPAK@Z		; ScanBones
; Function compile flags: /Odtp /ZI
;	COMDAT ?ScanBones@@YA_NPAUsBone@@KPAPADPAK@Z
_TEXT	SEGMENT
_dwMemorySize$57102 = -16				; size = 4
_pCodeSizePtr$57098 = -12				; size = 4
_pBone$57097 = -8					; size = 4
_bi$57093 = -4						; size = 4
_pBoneArray$ = 8					; size = 4
_dwBoneCount$ = 12					; size = 4
_ppBlock$ = 16						; size = 4
_pdwSize$ = 20						; size = 4
?ScanBones@@YA_NPAUsBone@@KPAPADPAK@Z PROC		; ScanBones, COMDAT

; 621  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 622  : 	// No bones
; 623  : 	if ( pBoneArray )

	cmp	DWORD PTR _pBoneArray$[ebp], 0
	je	$LN10@ScanBones

; 624  : 	{
; 625  : 		// for each texture in the array
; 626  : 		for ( DWORD bi=0; bi<dwBoneCount; bi++ )

	mov	DWORD PTR _bi$57093[ebp], 0
	jmp	SHORT $LN9@ScanBones
$LN8@ScanBones:
	mov	eax, DWORD PTR _bi$57093[ebp]
	add	eax, 1
	mov	DWORD PTR _bi$57093[ebp], eax
$LN9@ScanBones:
	mov	eax, DWORD PTR _bi$57093[ebp]
	cmp	eax, DWORD PTR _dwBoneCount$[ebp]
	jae	$LN10@ScanBones

; 627  : 		{
; 628  : 			// bone in question
; 629  : 			sBone* pBone = &(pBoneArray [ bi ]);

	mov	eax, DWORD PTR _bi$57093[ebp]
	imul	eax, 344				; 00000158H
	add	eax, DWORD PTR _pBoneArray$[ebp]
	mov	DWORD PTR _pBone$57097[ebp], eax

; 630  : 
; 631  : 			// bone name
; 632  : 			LPSTR pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57098[ebp], 0

; 633  : 			if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN6@ScanBones
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57098[ebp], ecx
$LN6@ScanBones:

; 634  : 			WriteCODE ( DBOBLOCK_BONES_NAME, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	301					; 0000012dH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 635  : 			WriteString ( pBone->szName, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pBone$57097[ebp]
	push	edx
	call	?WriteString@@YA_NPADPAPADPAK@Z		; WriteString
	add	esp, 12					; 0000000cH

; 636  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 637  : 			if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57098[ebp], 0
	je	SHORT $LN5@ScanBones
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57098[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57098[ebp]
	mov	DWORD PTR [edx], ecx
$LN5@ScanBones:

; 638  : 
; 639  : 			// bone num influences
; 640  : 			WriteCODE ( DBOBLOCK_BONES_NUMINFLUENCES, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	302					; 0000012eH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 641  : 			WriteDWORD ( pBone->dwNumInfluences, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pBone$57097[ebp]
	mov	eax, DWORD PTR [edx+256]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 642  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 643  : 
; 644  : 			// bone vertices
; 645  : 			DWORD dwMemorySize = sizeof(DWORD) * pBone->dwNumInfluences;

	mov	eax, DWORD PTR _pBone$57097[ebp]
	mov	ecx, DWORD PTR [eax+256]
	shl	ecx, 2
	mov	DWORD PTR _dwMemorySize$57102[ebp], ecx

; 646  : 			if ( dwMemorySize > 0 )

	cmp	DWORD PTR _dwMemorySize$57102[ebp], 0
	jbe	SHORT $LN4@ScanBones

; 647  : 			{
; 648  : 				WriteCODE	( DBOBLOCK_BONES_VERTICES, dwMemorySize, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwMemorySize$57102[ebp]
	push	edx
	push	303					; 0000012fH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 649  : 				WriteMEMORY ( (BYTE*)pBone->pVertices, dwMemorySize, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwMemorySize$57102[ebp]
	push	edx
	mov	eax, DWORD PTR _pBone$57097[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	?WriteMEMORY@@YA_NPAEKPAPADPAK@Z	; WriteMEMORY
	add	esp, 16					; 00000010H
$LN4@ScanBones:

; 650  : 			}
; 651  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 652  : 
; 653  : 			// bone weights
; 654  : 			dwMemorySize = sizeof(float) * pBone->dwNumInfluences;

	mov	eax, DWORD PTR _pBone$57097[ebp]
	mov	ecx, DWORD PTR [eax+256]
	shl	ecx, 2
	mov	DWORD PTR _dwMemorySize$57102[ebp], ecx

; 655  : 			if ( dwMemorySize > 0 )

	cmp	DWORD PTR _dwMemorySize$57102[ebp], 0
	jbe	SHORT $LN3@ScanBones

; 656  : 			{
; 657  : 				WriteCODE	( DBOBLOCK_BONES_WEIGHTS, dwMemorySize, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwMemorySize$57102[ebp]
	push	edx
	push	304					; 00000130H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 658  : 				WriteMEMORY ( (BYTE*)pBone->pWeights, dwMemorySize, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwMemorySize$57102[ebp]
	push	edx
	mov	eax, DWORD PTR _pBone$57097[ebp]
	mov	ecx, DWORD PTR [eax+264]
	push	ecx
	call	?WriteMEMORY@@YA_NPAEKPAPADPAK@Z	; WriteMEMORY
	add	esp, 16					; 00000010H
$LN3@ScanBones:

; 659  : 			}
; 660  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 661  : 
; 662  : 			// bone matrix translation
; 663  : 			pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57098[ebp], 0

; 664  : 			if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN2@ScanBones
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57098[ebp], ecx
$LN2@ScanBones:

; 665  : 			WriteCODE ( DBOBLOCK_BONES_TRANSLATIONMATRIX, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	305					; 00000131H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 666  : 			WriteMATRIX ( pBone->matTranslation, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	esi, DWORD PTR _pBone$57097[ebp]
	add	esi, 268				; 0000010cH
	sub	esp, 64					; 00000040H
	mov	ecx, 16					; 00000010H
	mov	edi, esp
	rep movsd
	call	?WriteMATRIX@@YA_NUD3DXMATRIX@@PAPADPAK@Z ; WriteMATRIX
	add	esp, 72					; 00000048H

; 667  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 668  : 			if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57098[ebp], 0
	je	SHORT $LN1@ScanBones
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57098[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57098[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@ScanBones:

; 669  : 
; 670  : 			// end of this bone
; 671  : 			WriteCODE ( 0, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	0
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 672  : 		}

	jmp	$LN8@ScanBones
$LN10@ScanBones:

; 673  : 	}
; 674  : 
; 675  : 	// zero code
; 676  : 	WriteCODE ( 0, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	0
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 677  : 
; 678  : 	// okay
; 679  : 	return true;

	mov	al, 1

; 680  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ScanBones@@YA_NPAUsBone@@KPAPADPAK@Z ENDP		; ScanBones
_TEXT	ENDS
PUBLIC	?ScanTextures@@YA_NPAUsTexture@@KPAPADPAK@Z	; ScanTextures
; Function compile flags: /Odtp /ZI
;	COMDAT ?ScanTextures@@YA_NPAUsTexture@@KPAPADPAK@Z
_TEXT	SEGMENT
_pCodeSizePtr$57124 = -12				; size = 4
_pTexture$57123 = -8					; size = 4
_ti$57119 = -4						; size = 4
_pTextureArray$ = 8					; size = 4
_dwTextureCount$ = 12					; size = 4
_ppBlock$ = 16						; size = 4
_pdwSize$ = 20						; size = 4
?ScanTextures@@YA_NPAUsTexture@@KPAPADPAK@Z PROC	; ScanTextures, COMDAT

; 683  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 684  : 	// No textures
; 685  : 	if ( pTextureArray )

	cmp	DWORD PTR _pTextureArray$[ebp], 0
	je	$LN6@ScanTextur

; 686  : 	{
; 687  : 		// for each texture in the array
; 688  : 		for ( DWORD ti=0; ti<dwTextureCount; ti++ )

	mov	DWORD PTR _ti$57119[ebp], 0
	jmp	SHORT $LN5@ScanTextur
$LN4@ScanTextur:
	mov	eax, DWORD PTR _ti$57119[ebp]
	add	eax, 1
	mov	DWORD PTR _ti$57119[ebp], eax
$LN5@ScanTextur:
	mov	eax, DWORD PTR _ti$57119[ebp]
	cmp	eax, DWORD PTR _dwTextureCount$[ebp]
	jae	$LN6@ScanTextur

; 689  : 		{
; 690  : 			// texture in question
; 691  : 			sTexture* pTexture = &(pTextureArray [ ti ]);

	mov	eax, DWORD PTR _ti$57119[ebp]
	imul	eax, 328				; 00000148H
	add	eax, DWORD PTR _pTextureArray$[ebp]
	mov	DWORD PTR _pTexture$57123[ebp], eax

; 692  : 
; 693  : 			// texture name
; 694  : 			LPSTR pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57124[ebp], 0

; 695  : 			if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN2@ScanTextur
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57124[ebp], ecx
$LN2@ScanTextur:

; 696  : 			WriteCODE ( DBOBLOCK_TEXTURE_NAME, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	141					; 0000008dH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 697  : 			WriteString ( pTexture->pName, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTexture$57123[ebp]
	push	edx
	call	?WriteString@@YA_NPADPAPADPAK@Z		; WriteString
	add	esp, 12					; 0000000cH

; 698  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 699  : 			if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57124[ebp], 0
	je	SHORT $LN1@ScanTextur
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57124[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57124[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@ScanTextur:

; 700  : 
; 701  : 			// texture settings
; 702  : 			WriteCODE ( DBOBLOCK_TEXTURE_STAGE, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	142					; 0000008eH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 703  : 			WriteDWORD ( pTexture->dwStage, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTexture$57123[ebp]
	mov	eax, DWORD PTR [edx+268]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 704  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 705  : 
; 706  : 			WriteCODE ( DBOBLOCK_TEXTURE_BMODE, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	143					; 0000008fH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 707  : 			WriteDWORD ( pTexture->dwBlendMode, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTexture$57123[ebp]
	mov	eax, DWORD PTR [edx+272]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 708  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 709  : 
; 710  : 			WriteCODE ( DBOBLOCK_TEXTURE_BARG1, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	144					; 00000090H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 711  : 			WriteDWORD ( pTexture->dwBlendArg1, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTexture$57123[ebp]
	mov	eax, DWORD PTR [edx+276]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 712  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 713  : 
; 714  : 			WriteCODE ( DBOBLOCK_TEXTURE_BARG2, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	145					; 00000091H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 715  : 			WriteDWORD ( pTexture->dwBlendArg2, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTexture$57123[ebp]
	mov	eax, DWORD PTR [edx+280]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 716  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 717  : 
; 718  : 			WriteCODE ( DBOBLOCK_TEXTURE_ADDRU, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	146					; 00000092H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 719  : 			WriteDWORD ( pTexture->dwAddressU, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTexture$57123[ebp]
	mov	eax, DWORD PTR [edx+284]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 720  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 721  : 
; 722  : 			WriteCODE ( DBOBLOCK_TEXTURE_ADDRV, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	147					; 00000093H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 723  : 			WriteDWORD ( pTexture->dwAddressV, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTexture$57123[ebp]
	mov	eax, DWORD PTR [edx+288]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 724  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 725  : 
; 726  : 			WriteCODE ( DBOBLOCK_TEXTURE_MAG, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	148					; 00000094H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 727  : 			WriteDWORD ( pTexture->dwMagState, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTexture$57123[ebp]
	mov	eax, DWORD PTR [edx+292]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 728  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 729  : 
; 730  : 			WriteCODE ( DBOBLOCK_TEXTURE_MIN, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	149					; 00000095H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 731  : 			WriteDWORD ( pTexture->dwMinState, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTexture$57123[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 732  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 733  : 
; 734  : 			WriteCODE ( DBOBLOCK_TEXTURE_MIP, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	150					; 00000096H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 735  : 			WriteDWORD ( pTexture->dwMipState, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTexture$57123[ebp]
	mov	eax, DWORD PTR [edx+300]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 736  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 737  : 
; 738  : 			WriteCODE ( DBOBLOCK_TEXTURE_TCMODE, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	151					; 00000097H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 739  : 			WriteDWORD ( pTexture->dwTexCoordMode, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTexture$57123[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 740  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 741  : 
; 742  : 			WriteCODE ( DBOBLOCK_TEXTURE_PRIMST, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	152					; 00000098H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 743  : 			WriteDWORD ( (DWORD) pTexture->iStartIndex, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTexture$57123[ebp]
	mov	eax, DWORD PTR [edx+308]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 744  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 745  : 
; 746  : 			WriteCODE ( DBOBLOCK_TEXTURE_PRIMCN, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	153					; 00000099H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 747  : 			WriteDWORD ( (DWORD) pTexture->iPrimitiveCount, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTexture$57123[ebp]
	mov	eax, DWORD PTR [edx+312]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 748  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 749  : 
; 750  : 			// end of this texture
; 751  : 			WriteCODE ( 0, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	0
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 752  : 		}

	jmp	$LN4@ScanTextur
$LN6@ScanTextur:

; 753  : 	}
; 754  : 
; 755  : 	// zero code
; 756  : 	WriteCODE ( 0, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	0
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 757  : 
; 758  : 	// okay
; 759  : 	return true;

	mov	al, 1

; 760  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ScanTextures@@YA_NPAUsTexture@@KPAPADPAK@Z ENDP	; ScanTextures
_TEXT	ENDS
PUBLIC	?ScanMultiMaterial@@YA_NPAUsMultiMaterial@@KPAPADPAK@Z ; ScanMultiMaterial
; Function compile flags: /Odtp /ZI
;	COMDAT ?ScanMultiMaterial@@YA_NPAUsMultiMaterial@@KPAPADPAK@Z
_TEXT	SEGMENT
_pCodeSizePtr$57142 = -12				; size = 4
_pMultiMat$57141 = -8					; size = 4
_ti$57137 = -4						; size = 4
_pMultiMaterialArray$ = 8				; size = 4
_dwMultiMatCount$ = 12					; size = 4
_ppBlock$ = 16						; size = 4
_pdwSize$ = 20						; size = 4
?ScanMultiMaterial@@YA_NPAUsMultiMaterial@@KPAPADPAK@Z PROC ; ScanMultiMaterial, COMDAT

; 763  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 764  : 	// No multimaterial array
; 765  : 	if ( pMultiMaterialArray )

	cmp	DWORD PTR _pMultiMaterialArray$[ebp], 0
	je	$LN6@ScanMultiM

; 766  : 	{
; 767  : 		// for each in the array
; 768  : 		for ( DWORD ti=0; ti<dwMultiMatCount; ti++ )

	mov	DWORD PTR _ti$57137[ebp], 0
	jmp	SHORT $LN5@ScanMultiM
$LN4@ScanMultiM:
	mov	eax, DWORD PTR _ti$57137[ebp]
	add	eax, 1
	mov	DWORD PTR _ti$57137[ebp], eax
$LN5@ScanMultiM:
	mov	eax, DWORD PTR _ti$57137[ebp]
	cmp	eax, DWORD PTR _dwMultiMatCount$[ebp]
	jae	$LN6@ScanMultiM

; 769  : 		{
; 770  : 			// multimaterial in question
; 771  : 			sMultiMaterial* pMultiMat = &(pMultiMaterialArray [ ti ]);

	mov	eax, DWORD PTR _ti$57137[ebp]
	imul	eax, 340				; 00000154H
	add	eax, DWORD PTR _pMultiMaterialArray$[ebp]
	mov	DWORD PTR _pMultiMat$57141[ebp], eax

; 772  : 
; 773  : 			// write multimaterial name
; 774  : 			LPSTR pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57142[ebp], 0

; 775  : 			if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN2@ScanMultiM
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57142[ebp], ecx
$LN2@ScanMultiM:

; 776  : 			WriteCODE ( DBOBLOCK_MULTIMAT_NAME, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	161					; 000000a1H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 777  : 			WriteString ( pMultiMat->pName, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMultiMat$57141[ebp]
	push	edx
	call	?WriteString@@YA_NPADPAPADPAK@Z		; WriteString
	add	esp, 12					; 0000000cH

; 778  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 779  : 			if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57142[ebp], 0
	je	SHORT $LN1@ScanMultiM
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57142[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57142[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@ScanMultiM:

; 780  : 
; 781  : 			// write multimaterial material information
; 782  : 			WriteCODE	( DBOBLOCK_MULTIMAT_MATERIAL, sizeof(pMultiMat->mMaterial), ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	68					; 00000044H
	push	162					; 000000a2H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 783  : 			WriteMATERIAL ( pMultiMat->mMaterial,			ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	esi, DWORD PTR _pMultiMat$57141[ebp]
	add	esi, 260				; 00000104H
	sub	esp, 68					; 00000044H
	mov	ecx, 17					; 00000011H
	mov	edi, esp
	rep movsd
	call	?WriteMATERIAL@@YA_NU_D3DMATERIAL9@@PAPADPAK@Z ; WriteMATERIAL
	add	esp, 76					; 0000004cH

; 784  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 785  : 
; 786  : 			// write multimaterial start
; 787  : 			WriteCODE ( DBOBLOCK_MULTIMAT_START, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	163					; 000000a3H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 788  : 			WriteDWORD ( pMultiMat->dwIndexStart, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMultiMat$57141[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 789  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 790  : 
; 791  : 			// write multimaterial end
; 792  : 			WriteCODE ( DBOBLOCK_MULTIMAT_COUNT, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	164					; 000000a4H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 793  : 			WriteDWORD ( pMultiMat->dwIndexCount, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMultiMat$57141[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 794  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 795  : 
; 796  : 			// write multimaterial poly
; 797  : 			WriteCODE ( DBOBLOCK_MULTIMAT_POLY, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	165					; 000000a5H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 798  : 			WriteDWORD ( pMultiMat->dwPolyCount, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMultiMat$57141[ebp]
	mov	eax, DWORD PTR [edx+336]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 799  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 800  : 
; 801  : 			// end of this
; 802  : 			WriteCODE ( 0, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	0
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 803  : 		}

	jmp	$LN4@ScanMultiM
$LN6@ScanMultiM:

; 804  : 	}
; 805  : 
; 806  : 	// zero code
; 807  : 	WriteCODE ( 0, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	0
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 808  : 
; 809  : 	// okay
; 810  : 	return true;

	mov	al, 1

; 811  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ScanMultiMaterial@@YA_NPAUsMultiMaterial@@KPAPADPAK@Z ENDP ; ScanMultiMaterial
_TEXT	ENDS
PUBLIC	?ScanFrame@@YA_NPAUsFrame@@PAPADPAK@Z		; ScanFrame
PUBLIC	?ScanMesh@@YA_NPAUsMesh@@PAPADPAK@Z		; ScanMesh
; Function compile flags: /Odtp /ZI
;	COMDAT ?ScanMesh@@YA_NPAUsMesh@@PAPADPAK@Z
_TEXT	SEGMENT
_dwDWORD$57176 = -16					; size = 4
_pCodeSizePtr$57172 = -12				; size = 4
_pCodeSizePtr$57161 = -8				; size = 4
_dwSubMesh$57154 = -4					; size = 4
_pMesh$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
_pdwSize$ = 16						; size = 4
?ScanMesh@@YA_NPAUsMesh@@PAPADPAK@Z PROC		; ScanMesh, COMDAT

; 814  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 815  : 	// No mesh
; 816  : 	if ( pMesh )

	cmp	DWORD PTR _pMesh$[ebp], 0
	je	$LN15@ScanMesh

; 817  : 	{
; 818  : 		// Write vertex information
; 819  : 		WriteCODE ( DBOBLOCK_MESH_FVF, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	111					; 0000006fH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 820  : 		WriteDWORD ( pMesh->dwFVF, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 821  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 822  : 
; 823  : 		WriteCODE ( DBOBLOCK_MESH_FVFSIZE, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	112					; 00000070H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 824  : 		WriteDWORD ( pMesh->dwFVFSize, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 825  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 826  : 
; 827  : 		WriteCODE ( DBOBLOCK_MESH_VERTEXCOUNT, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	113					; 00000071H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 828  : 		WriteDWORD ( pMesh->dwVertexCount, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 829  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 830  : 
; 831  : 		WriteCODE ( DBOBLOCK_MESH_INDEXCOUNT, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	114					; 00000072H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 832  : 		WriteDWORD ( pMesh->dwIndexCount, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 833  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 834  : 
; 835  : 		// If non-standard vertex declaration, write it
; 836  : 		if ( pMesh->dwFVF==0 )

	mov	eax, DWORD PTR _pMesh$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN14@ScanMesh

; 837  : 		{
; 838  : 			WriteCODE ( DBOBLOCK_MESH_VERTEXDEC, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	120					; 00000078H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 839  : 			WriteMEMORY ( (BYTE*)pMesh->pVertexDeclaration, sizeof(pMesh->pVertexDeclaration), ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	520					; 00000208H
	mov	edx, DWORD PTR _pMesh$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	call	?WriteMEMORY@@YA_NPAEKPAPADPAK@Z	; WriteMEMORY
	add	esp, 16					; 00000010H

; 840  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8
$LN14@ScanMesh:

; 841  : 		}
; 842  : 
; 843  : 		// MIKE 130503 - changed the way in which sub frames were saved
; 844  : 		WriteCODE ( DBOBLOCK_MESH_SUBFRAMES, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	138					; 0000008aH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 845  : 		WriteDWORD ( pMesh->dwSubMeshListCount, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+1104]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 846  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 847  : 		for ( DWORD dwSubMesh = 0; dwSubMesh < pMesh->dwSubMeshListCount; dwSubMesh++ )

	mov	DWORD PTR _dwSubMesh$57154[ebp], 0
	jmp	SHORT $LN13@ScanMesh
$LN12@ScanMesh:
	mov	eax, DWORD PTR _dwSubMesh$57154[ebp]
	add	eax, 1
	mov	DWORD PTR _dwSubMesh$57154[ebp], eax
$LN13@ScanMesh:
	mov	eax, DWORD PTR _pMesh$[ebp]
	mov	ecx, DWORD PTR _dwSubMesh$57154[ebp]
	cmp	ecx, DWORD PTR [eax+1104]
	jae	SHORT $LN11@ScanMesh

; 848  : 		{
; 849  : 			ScanFrame ( &pMesh->pSubFrameList [ dwSubMesh ], ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwSubMesh$57154[ebp]
	imul	edx, 804				; 00000324H
	mov	eax, DWORD PTR _pMesh$[ebp]
	add	edx, DWORD PTR [eax+1100]
	push	edx
	call	?ScanFrame@@YA_NPAUsFrame@@PAPADPAK@Z	; ScanFrame
	add	esp, 12					; 0000000cH

; 850  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 851  : 		}

	jmp	SHORT $LN12@ScanMesh
$LN11@ScanMesh:

; 852  : 		
; 853  : 		// Write vertex data
; 854  : 		WriteCODE	( DBOBLOCK_MESH_VERTEXDATA,	pMesh->dwFVFSize*pMesh->dwVertexCount, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR _pMesh$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	imul	ecx, DWORD PTR [eax+28]
	push	ecx
	push	115					; 00000073H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 855  : 		WriteVertexData ( pMesh->pVertexData, pMesh->dwFVFSize, pMesh->dwVertexCount, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _pMesh$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _pMesh$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	?WriteVertexData@@YA_NPAEKKPAPADPAK@Z	; WriteVertexData
	add	esp, 20					; 00000014H

; 856  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 857  : 
; 858  : 		// Write index data
; 859  : 		if ( pMesh->dwIndexCount )

	mov	eax, DWORD PTR _pMesh$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN10@ScanMesh

; 860  : 		{
; 861  : 			WriteCODE	( DBOBLOCK_MESH_INDEXDATA, pMesh->dwIndexCount*sizeof(WORD), ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+32]
	shl	eax, 1
	push	eax
	push	116					; 00000074H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 862  : 			WriteIndices ( pMesh->pIndices, pMesh->dwIndexCount, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _pMesh$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	?WriteIndices@@YA_NPAGKPAPADPAK@Z	; WriteIndices
	add	esp, 16					; 00000010H

; 863  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8
$LN10@ScanMesh:

; 864  : 		}
; 865  : 
; 866  : 		// Write primitive type
; 867  : // leefix - 060306 - huge size specified, when only 4 bytes are written
; 868  : //		WriteCODE	( DBOBLOCK_MESH_PRIMTYPE, pMesh->dwIndexCount*sizeof(WORD), ppBlock, pdwSize );
; 869  : 		WriteCODE	( DBOBLOCK_MESH_PRIMTYPE, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	117					; 00000075H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 870  : 		WriteDWORD ( (DWORD)pMesh->iPrimitiveType, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 871  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 872  : 		
; 873  : 		// Write draw vertex count
; 874  : // leefix - 060306 - huge size specified, when only 4 bytes are written
; 875  : //		WriteCODE	( DBOBLOCK_MESH_DRAWVERTCOUNT, pMesh->dwIndexCount*sizeof(WORD), ppBlock, pdwSize );
; 876  : 		WriteCODE	( DBOBLOCK_MESH_DRAWVERTCOUNT, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	118					; 00000076H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 877  : 		WriteDWORD ( pMesh->iDrawVertexCount, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 878  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 879  : 
; 880  : 		// Write draw primitive count
; 881  : // leefix - 060306 - huge size specified, when only 4 bytes are written
; 882  : //		WriteCODE	( DBOBLOCK_MESH_DRAWPRIMCOUNT, pMesh->dwIndexCount*sizeof(WORD), ppBlock, pdwSize );
; 883  : 		WriteCODE	( DBOBLOCK_MESH_DRAWPRIMCOUNT, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	119					; 00000077H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 884  : 		WriteDWORD ( pMesh->iDrawPrimitives, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 885  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 886  : 
; 887  : 		// Write bone information
; 888  : 		WriteCODE	( DBOBLOCK_MESH_BONECOUNT,	4,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	121					; 00000079H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 889  : 		WriteDWORD	( pMesh->dwBoneCount,			ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+876]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 890  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 891  : 
; 892  : 		LPSTR pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57161[ebp], 0

; 893  : 		if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN9@ScanMesh
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57161[ebp], ecx
$LN9@ScanMesh:

; 894  : 		WriteCODE	( DBOBLOCK_MESH_BONESDATA,	0,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	122					; 0000007aH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 895  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 896  : 		ScanBones	( pMesh->pBones, pMesh->dwBoneCount, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+876]
	push	eax
	mov	ecx, DWORD PTR _pMesh$[ebp]
	mov	edx, DWORD PTR [ecx+872]
	push	edx
	call	?ScanBones@@YA_NPAUsBone@@KPAPADPAK@Z	; ScanBones
	add	esp, 16					; 00000010H

; 897  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 898  : 		if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57161[ebp], 0
	je	SHORT $LN8@ScanMesh
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57161[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57161[ebp]
	mov	DWORD PTR [edx], ecx
$LN8@ScanMesh:

; 899  : 
; 900  : 		// Write material information
; 901  : 		WriteCODE	( DBOBLOCK_MESH_USEMATERIAL, 1,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	1
	push	125					; 0000007dH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 902  : 		WriteBYTE	( pMesh->bUsesMaterial, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	movzx	eax, BYTE PTR [edx+888]
	push	eax
	call	?WriteBYTE@@YA_NEPAPADPAK@Z		; WriteBYTE
	add	esp, 12					; 0000000cH

; 903  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 904  : 		WriteCODE	( DBOBLOCK_MESH_MATERIAL, sizeof(pMesh->mMaterial), ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	68					; 00000044H
	push	126					; 0000007eH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 905  : 		WriteMATERIAL ( pMesh->mMaterial,			ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	esi, DWORD PTR _pMesh$[ebp]
	add	esi, 916				; 00000394H
	sub	esp, 68					; 00000044H
	mov	ecx, 17					; 00000011H
	mov	edi, esp
	rep movsd
	call	?WriteMATERIAL@@YA_NU_D3DMATERIAL9@@PAPADPAK@Z ; WriteMATERIAL
	add	esp, 76					; 0000004cH

; 906  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 907  : 
; 908  : 		// Write texture information
; 909  : 		WriteCODE	( DBOBLOCK_MESH_TEXTURECOUNT, 4,ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	127					; 0000007fH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 910  : 		WriteDWORD	( pMesh->dwTextureCount,		ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+892]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 911  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 912  : 
; 913  : 		pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57161[ebp], 0

; 914  : 		if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN7@ScanMesh
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57161[ebp], ecx
$LN7@ScanMesh:

; 915  : 		WriteCODE	( DBOBLOCK_MESH_TEXTURES, 0,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	128					; 00000080H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 916  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 917  : 		ScanTextures ( pMesh->pTextures, pMesh->dwTextureCount, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+892]
	push	eax
	mov	ecx, DWORD PTR _pMesh$[ebp]
	mov	edx, DWORD PTR [ecx+904]
	push	edx
	call	?ScanTextures@@YA_NPAUsTexture@@KPAPADPAK@Z ; ScanTextures
	add	esp, 16					; 00000010H

; 918  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 919  : 		if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57161[ebp], 0
	je	SHORT $LN6@ScanMesh
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57161[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57161[ebp]
	mov	DWORD PTR [edx], ecx
$LN6@ScanMesh:

; 920  : 
; 921  : 		// Write multi material information
; 922  : 		WriteCODE	( DBOBLOCK_MESH_USEMULTIMAT, 1,		ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	1
	push	123					; 0000007bH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 923  : 		WriteBYTE	( pMesh->bUseMultiMaterial,			ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	movzx	eax, BYTE PTR [edx+890]
	push	eax
	call	?WriteBYTE@@YA_NEPAPADPAK@Z		; WriteBYTE
	add	esp, 12					; 0000000cH

; 924  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 925  : 		WriteCODE	( DBOBLOCK_MESH_MULTIMATCOUNT, 4,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	124					; 0000007cH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 926  : 		WriteDWORD	( pMesh->dwMultiMaterialCount,		ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+896]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 927  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 928  : 		pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57161[ebp], 0

; 929  : 		if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN5@ScanMesh
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57161[ebp], ecx
$LN5@ScanMesh:

; 930  : 		WriteCODE	( DBOBLOCK_MESH_MULTIMAT, 0,		ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	139					; 0000008bH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 931  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 932  : 		ScanMultiMaterial ( pMesh->pMultiMaterial, pMesh->dwMultiMaterialCount, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+896]
	push	eax
	mov	ecx, DWORD PTR _pMesh$[ebp]
	mov	edx, DWORD PTR [ecx+908]
	push	edx
	call	?ScanMultiMaterial@@YA_NPAUsMultiMaterial@@KPAPADPAK@Z ; ScanMultiMaterial
	add	esp, 16					; 00000010H

; 933  : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 934  : 		if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57161[ebp], 0
	je	SHORT $LN4@ScanMesh
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57161[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57161[ebp]
	mov	DWORD PTR [edx], ecx
$LN4@ScanMesh:

; 935  : 
; 936  : 		// Write render states
; 937  : 		WriteCODE	( DBOBLOCK_MESH_WIREFRAME,	1,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	1
	push	129					; 00000081H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 938  : 		WriteBYTE	( pMesh->bWireframe,			ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	movzx	eax, BYTE PTR [edx+1036]
	push	eax
	call	?WriteBYTE@@YA_NEPAPADPAK@Z		; WriteBYTE
	add	esp, 12					; 0000000cH

; 939  : 		WriteCR	( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 940  : 		WriteCODE	( DBOBLOCK_MESH_LIGHT,		1,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	1
	push	130					; 00000082H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 941  : 		WriteBYTE	( pMesh->bLight,				ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	movzx	eax, BYTE PTR [edx+1037]
	push	eax
	call	?WriteBYTE@@YA_NEPAPADPAK@Z		; WriteBYTE
	add	esp, 12					; 0000000cH

; 942  : 		WriteCR	( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 943  : 		WriteCODE	( DBOBLOCK_MESH_CULL,		1,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	1
	push	131					; 00000083H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 944  : 		WriteBYTE	( pMesh->bCull,					ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	movzx	eax, BYTE PTR [edx+1038]
	push	eax
	call	?WriteBYTE@@YA_NEPAPADPAK@Z		; WriteBYTE
	add	esp, 12					; 0000000cH

; 945  : 		WriteCR	( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 946  : 		WriteCODE	( DBOBLOCK_MESH_FOG,		1,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	1
	push	132					; 00000084H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 947  : 		WriteBYTE	( pMesh->bFog,					ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	movzx	eax, BYTE PTR [edx+1039]
	push	eax
	call	?WriteBYTE@@YA_NEPAPADPAK@Z		; WriteBYTE
	add	esp, 12					; 0000000cH

; 948  : 		WriteCR	( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 949  : 		WriteCODE	( DBOBLOCK_MESH_AMBIENT,	1,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	1
	push	133					; 00000085H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 950  : 		WriteBYTE	( pMesh->bAmbient,				ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	movzx	eax, BYTE PTR [edx+1040]
	push	eax
	call	?WriteBYTE@@YA_NEPAPADPAK@Z		; WriteBYTE
	add	esp, 12					; 0000000cH

; 951  : 		WriteCR	( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 952  : 		WriteCODE	( DBOBLOCK_MESH_TRANSPARENCY,1,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	1
	push	134					; 00000086H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 953  : 		WriteBYTE	( pMesh->bTransparency,			ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	movzx	eax, BYTE PTR [edx+1041]
	push	eax
	call	?WriteBYTE@@YA_NEPAPADPAK@Z		; WriteBYTE
	add	esp, 12					; 0000000cH

; 954  : 		WriteCR	( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 955  : 		WriteCODE	( DBOBLOCK_MESH_GHOST,		1,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	1
	push	135					; 00000087H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 956  : 		WriteBYTE	( pMesh->bGhost,				ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	movzx	eax, BYTE PTR [edx+1048]
	push	eax
	call	?WriteBYTE@@YA_NEPAPADPAK@Z		; WriteBYTE
	add	esp, 12					; 0000000cH

; 957  : 		WriteCR	( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 958  : 		WriteCODE	( DBOBLOCK_MESH_GHOSTMODE,	4,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	136					; 00000088H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 959  : 		WriteDWORD	( pMesh->iGhostMode,			ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+1052]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 960  : 		WriteCR	( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 961  : 		WriteCODE	( DBOBLOCK_MESH_VISIBLE,	1,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	1
	push	140					; 0000008cH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 962  : 		WriteBYTE	( pMesh->bVisible,				ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	movzx	eax, BYTE PTR [edx+1049]
	push	eax
	call	?WriteBYTE@@YA_NEPAPADPAK@Z		; WriteBYTE
	add	esp, 12					; 0000000cH

; 963  : 		WriteCR	( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 964  : 		WriteCODE	( DBOBLOCK_MESH_LINKED,		1,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	1
	push	137					; 00000089H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 965  : 		WriteBYTE	( pMesh->bLinked,				ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	movzx	eax, BYTE PTR [edx+1136]
	push	eax
	call	?WriteBYTE@@YA_NEPAPADPAK@Z		; WriteBYTE
	add	esp, 12					; 0000000cH

; 966  : 		WriteCR	( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 967  : 
; 968  : 		// 250704 - Write FX effect file name (if any)
; 969  : 		if ( pMesh->bUseVertexShader )

	mov	eax, DWORD PTR _pMesh$[ebp]
	movzx	ecx, BYTE PTR [eax+64]
	test	ecx, ecx
	je	SHORT $LN3@ScanMesh

; 970  : 		{
; 971  : 			LPSTR pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57172[ebp], 0

; 972  : 			if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN2@ScanMesh
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57172[ebp], ecx
$LN2@ScanMesh:

; 973  : 			WriteCODE ( DBOBLOCK_MESH_FXEFFECTNAME, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	154					; 0000009aH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 974  : 			WriteString ( pMesh->pEffectName, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	add	edx, 604				; 0000025cH
	push	edx
	call	?WriteString@@YA_NPADPAPADPAK@Z		; WriteString
	add	esp, 12					; 0000000cH

; 975  : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 976  : 			if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57172[ebp], 0
	je	SHORT $LN3@ScanMesh
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57172[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57172[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@ScanMesh:

; 977  : 		}
; 978  : 
; 979  : 		// 190804 - Write dwArbitaryValue to meshdata
; 980  : 		WriteCODE	( DBOBLOCK_MESH_ARBITARYVALUE, 4,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	155					; 0000009bH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 981  : 		WriteDWORD	( pMesh->Collision.dwArbitaryValue,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+1240]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 982  : 		WriteCR		( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 983  : 
; 984  : 		// 230904 - Write ZBIAS info
; 985  : 		WriteCODE	( DBOBLOCK_MESH_ZBIASFLAG,	1,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	1
	push	156					; 0000009cH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 986  : 		WriteBYTE	( pMesh->bZBiasActive,				ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	movzx	eax, BYTE PTR [edx+1056]
	push	eax
	call	?WriteBYTE@@YA_NEPAPADPAK@Z		; WriteBYTE
	add	esp, 12					; 0000000cH

; 987  : 		WriteCR	( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 988  : 		DWORD dwDWORD = *(DWORD*)&pMesh->fZBiasSlopeScale;

	mov	eax, DWORD PTR _pMesh$[ebp]
	mov	ecx, DWORD PTR [eax+1060]
	mov	DWORD PTR _dwDWORD$57176[ebp], ecx

; 989  : 		WriteCODE	( DBOBLOCK_MESH_ZBIASSLOPE, 4,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	157					; 0000009dH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 990  : 		WriteDWORD	( dwDWORD,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwDWORD$57176[ebp]
	push	edx
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 991  : 		WriteCR		( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 992  : 		dwDWORD = *(DWORD*)&pMesh->fZBiasDepth;

	mov	eax, DWORD PTR _pMesh$[ebp]
	mov	ecx, DWORD PTR [eax+1064]
	mov	DWORD PTR _dwDWORD$57176[ebp], ecx

; 993  : 		WriteCODE	( DBOBLOCK_MESH_ZBIASDEPTH, 4,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	158					; 0000009eH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 994  : 		WriteDWORD	( dwDWORD,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwDWORD$57176[ebp]
	push	edx
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 995  : 		WriteCR		( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 996  : 		WriteCODE	( DBOBLOCK_MESH_ZREAD,	1,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	1
	push	159					; 0000009fH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 997  : 		WriteBYTE	( pMesh->bZRead,				ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	movzx	eax, BYTE PTR [edx+1050]
	push	eax
	call	?WriteBYTE@@YA_NEPAPADPAK@Z		; WriteBYTE
	add	esp, 12					; 0000000cH

; 998  : 		WriteCR	( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 999  : 		WriteCODE	( DBOBLOCK_MESH_ZWRITE,	1,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	1
	push	160					; 000000a0H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1000 : 		WriteBYTE	( pMesh->bZWrite,				ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	movzx	eax, BYTE PTR [edx+1051]
	push	eax
	call	?WriteBYTE@@YA_NEPAPADPAK@Z		; WriteBYTE
	add	esp, 12					; 0000000cH

; 1001 : 		WriteCR	( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1002 : 
; 1003 : 		// 061204 - Needed to retain alpha-test-depth-draw-system(universe)
; 1004 : 		WriteCODE	( DBOBLOCK_MESH_ALPHATESTVALUE, 4,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	166					; 000000a6H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1005 : 		WriteDWORD	( pMesh->dwAlphaTestValue,	ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	eax, DWORD PTR [edx+1044]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 1006 : 		WriteCR		( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8
$LN15@ScanMesh:

; 1007 : 	}
; 1008 : 
; 1009 : 	// No more mesh codes
; 1010 : 	WriteCODE ( 0, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	0
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1011 : 
; 1012 : 	// okay
; 1013 : 	return true;

	mov	al, 1

; 1014 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ScanMesh@@YA_NPAUsMesh@@PAPADPAK@Z ENDP		; ScanMesh
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?ScanFrame@@YA_NPAUsFrame@@PAPADPAK@Z
_TEXT	SEGMENT
_pCodeSizePtr$57185 = -4				; size = 4
_pFrame$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
_pdwSize$ = 16						; size = 4
?ScanFrame@@YA_NPAUsFrame@@PAPADPAK@Z PROC		; ScanFrame, COMDAT

; 1017 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1018 : 	// No frame
; 1019 : 	if ( pFrame )

	cmp	DWORD PTR _pFrame$[ebp], 0
	je	$LN17@ScanFrame

; 1020 : 	{
; 1021 : 		// Write name
; 1022 : 		LPSTR pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57185[ebp], 0

; 1023 : 		if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN16@ScanFrame
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57185[ebp], ecx
$LN16@ScanFrame:

; 1024 : 		WriteCODE ( DBOBLOCK_FRAME_NAME, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	101					; 00000065H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1025 : 		WriteString ( pFrame->szName, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFrame$[ebp]
	push	edx
	call	?WriteString@@YA_NPADPAPADPAK@Z		; WriteString
	add	esp, 12					; 0000000cH

; 1026 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1027 : 		if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57185[ebp], 0
	je	SHORT $LN15@ScanFrame
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57185[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57185[ebp]
	mov	DWORD PTR [edx], ecx
$LN15@ScanFrame:

; 1028 : 	
; 1029 : 		// Write original matrix
; 1030 : 		pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57185[ebp], 0

; 1031 : 		if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN14@ScanFrame
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57185[ebp], ecx
$LN14@ScanFrame:

; 1032 : 		WriteCODE ( DBOBLOCK_FRAME_MATRIX, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	102					; 00000066H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1033 : 		WriteMATRIX ( pFrame->matOriginal, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	esi, DWORD PTR _pFrame$[ebp]
	add	esi, 272				; 00000110H
	sub	esp, 64					; 00000040H
	mov	ecx, 16					; 00000010H
	mov	edi, esp
	rep movsd
	call	?WriteMATRIX@@YA_NUD3DXMATRIX@@PAPADPAK@Z ; WriteMATRIX
	add	esp, 72					; 00000048H

; 1034 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1035 : 		if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57185[ebp], 0
	je	SHORT $LN13@ScanFrame
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57185[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57185[ebp]
	mov	DWORD PTR [edx], ecx
$LN13@ScanFrame:

; 1036 : 
; 1037 : 		// Write mesh
; 1038 : 		pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57185[ebp], 0

; 1039 : 		if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN12@ScanFrame
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57185[ebp], ecx
$LN12@ScanFrame:

; 1040 : 		WriteCODE ( DBOBLOCK_FRAME_MESH, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	103					; 00000067H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1041 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1042 : 		ScanMesh ( pFrame->pMesh, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFrame$[ebp]
	mov	eax, DWORD PTR [edx+760]
	push	eax
	call	?ScanMesh@@YA_NPAUsMesh@@PAPADPAK@Z	; ScanMesh
	add	esp, 12					; 0000000cH

; 1043 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1044 : 		if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57185[ebp], 0
	je	SHORT $LN11@ScanFrame
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57185[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57185[ebp]
	mov	DWORD PTR [edx], ecx
$LN11@ScanFrame:

; 1045 : 
; 1046 : 		// Write child
; 1047 : 		pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57185[ebp], 0

; 1048 : 		if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN10@ScanFrame
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57185[ebp], ecx
$LN10@ScanFrame:

; 1049 : 		WriteCODE ( DBOBLOCK_FRAME_CHILD, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	104					; 00000068H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1050 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1051 : 		ScanFrame ( pFrame->pChild, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFrame$[ebp]
	mov	eax, DWORD PTR [edx+264]
	push	eax
	call	?ScanFrame@@YA_NPAUsFrame@@PAPADPAK@Z	; ScanFrame
	add	esp, 12					; 0000000cH

; 1052 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1053 : 		if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57185[ebp], 0
	je	SHORT $LN9@ScanFrame
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57185[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57185[ebp]
	mov	DWORD PTR [edx], ecx
$LN9@ScanFrame:

; 1054 : 
; 1055 : 		// Write sibling
; 1056 : 		pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57185[ebp], 0

; 1057 : 		if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN8@ScanFrame
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57185[ebp], ecx
$LN8@ScanFrame:

; 1058 : 		WriteCODE ( DBOBLOCK_FRAME_SIBLING, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	105					; 00000069H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1059 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1060 : 		ScanFrame ( pFrame->pSibling, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFrame$[ebp]
	mov	eax, DWORD PTR [edx+268]
	push	eax
	call	?ScanFrame@@YA_NPAUsFrame@@PAPADPAK@Z	; ScanFrame
	add	esp, 12					; 0000000cH

; 1061 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1062 : 		if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57185[ebp], 0
	je	SHORT $LN7@ScanFrame
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57185[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57185[ebp]
	mov	DWORD PTR [edx], ecx
$LN7@ScanFrame:

; 1063 : 
; 1064 : 		// Write vector offset
; 1065 : 		pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57185[ebp], 0

; 1066 : 		if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN6@ScanFrame
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57185[ebp], ecx
$LN6@ScanFrame:

; 1067 : 		WriteCODE ( DBOBLOCK_FRAME_OFFSET, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	106					; 0000006aH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1068 : 		WriteVECTOR ( pFrame->vecOffset, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFrame$[ebp]
	add	edx, 672				; 000002a0H
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	call	?WriteVECTOR@@YA_NUD3DXVECTOR3@@PAPADPAK@Z ; WriteVECTOR
	add	esp, 20					; 00000014H

; 1069 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1070 : 		if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57185[ebp], 0
	je	SHORT $LN5@ScanFrame
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57185[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57185[ebp]
	mov	DWORD PTR [edx], ecx
$LN5@ScanFrame:

; 1071 : 
; 1072 : 		// Write vector rotation
; 1073 : 		pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57185[ebp], 0

; 1074 : 		if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN4@ScanFrame
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57185[ebp], ecx
$LN4@ScanFrame:

; 1075 : 		WriteCODE ( DBOBLOCK_FRAME_ROTATION, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	107					; 0000006bH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1076 : 		WriteVECTOR ( pFrame->vecRotation, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFrame$[ebp]
	add	edx, 696				; 000002b8H
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	call	?WriteVECTOR@@YA_NUD3DXVECTOR3@@PAPADPAK@Z ; WriteVECTOR
	add	esp, 20					; 00000014H

; 1077 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1078 : 		if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57185[ebp], 0
	je	SHORT $LN3@ScanFrame
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57185[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57185[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@ScanFrame:

; 1079 : 
; 1080 : 		// Write vector scale
; 1081 : 		pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57185[ebp], 0

; 1082 : 		if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN2@ScanFrame
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57185[ebp], ecx
$LN2@ScanFrame:

; 1083 : 		WriteCODE ( DBOBLOCK_FRAME_SCALE, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	108					; 0000006cH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1084 : 		WriteVECTOR ( pFrame->vecScale, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFrame$[ebp]
	add	edx, 684				; 000002acH
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	call	?WriteVECTOR@@YA_NUD3DXVECTOR3@@PAPADPAK@Z ; WriteVECTOR
	add	esp, 20					; 00000014H

; 1085 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1086 : 		if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57185[ebp], 0
	je	SHORT $LN17@ScanFrame
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57185[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57185[ebp]
	mov	DWORD PTR [edx], ecx
$LN17@ScanFrame:

; 1087 : 	}
; 1088 : 
; 1089 : 	// No more frame codes
; 1090 : 	WriteCODE ( 0, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	0
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1091 : 
; 1092 : 	// okay
; 1093 : 	return true;

	mov	al, 1

; 1094 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ScanFrame@@YA_NPAUsFrame@@PAPADPAK@Z ENDP		; ScanFrame
_TEXT	ENDS
PUBLIC	?WriteBoneMatrices@@YA_NPAUsAnimation@@PAPADPAK@Z ; WriteBoneMatrices
; Function compile flags: /Odtp /ZI
;	COMDAT ?WriteBoneMatrices@@YA_NPAUsAnimation@@PAPADPAK@Z
_TEXT	SEGMENT
_iB$57221 = -12						; size = 4
_iA$57217 = -8						; size = 4
_pCodeSizePtr$ = -4					; size = 4
_pAnim$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
_pdwSize$ = 16						; size = 4
?WriteBoneMatrices@@YA_NPAUsAnimation@@PAPADPAK@Z PROC	; WriteBoneMatrices, COMDAT

; 1097 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1098 : 	LPSTR pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$[ebp], 0

; 1099 : 	if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN8@WriteBoneM
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$[ebp], ecx
$LN8@WriteBoneM:

; 1100 : 
; 1101 : 	for ( int iA = 0; iA < pAnim->iBoneFrameA; iA++ )

	mov	DWORD PTR _iA$57217[ebp], 0
	jmp	SHORT $LN7@WriteBoneM
$LN6@WriteBoneM:
	mov	eax, DWORD PTR _iA$57217[ebp]
	add	eax, 1
	mov	DWORD PTR _iA$57217[ebp], eax
$LN7@WriteBoneM:
	mov	eax, DWORD PTR _pAnim$[ebp]
	mov	ecx, DWORD PTR _iA$57217[ebp]
	cmp	ecx, DWORD PTR [eax+332]
	jge	SHORT $LN5@WriteBoneM

; 1102 : 	{
; 1103 : 		for ( int iB = 0; iB < pAnim->iBoneFrameB; iB++ )

	mov	DWORD PTR _iB$57221[ebp], 0
	jmp	SHORT $LN4@WriteBoneM
$LN3@WriteBoneM:
	mov	eax, DWORD PTR _iB$57221[ebp]
	add	eax, 1
	mov	DWORD PTR _iB$57221[ebp], eax
$LN4@WriteBoneM:
	mov	eax, DWORD PTR _pAnim$[ebp]
	mov	ecx, DWORD PTR _iB$57221[ebp]
	cmp	ecx, DWORD PTR [eax+336]
	jge	SHORT $LN2@WriteBoneM

; 1104 : 		{
; 1105 : 			WriteMATRIX ( pAnim->ppBoneFrames [ iA ] [ iB ], ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnim$[ebp]
	mov	eax, DWORD PTR [edx+328]
	mov	ecx, DWORD PTR _iB$57221[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _iA$57217[ebp]
	mov	esi, DWORD PTR [eax+edx*4]
	add	esi, ecx
	sub	esp, 64					; 00000040H
	mov	ecx, 16					; 00000010H
	mov	edi, esp
	rep movsd
	call	?WriteMATRIX@@YA_NUD3DXMATRIX@@PAPADPAK@Z ; WriteMATRIX
	add	esp, 72					; 00000048H

; 1106 : 			
; 1107 : 		}

	jmp	SHORT $LN3@WriteBoneM
$LN2@WriteBoneM:

; 1108 : 	}

	jmp	SHORT $LN6@WriteBoneM
$LN5@WriteBoneM:

; 1109 : 
; 1110 : 	WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1111 : 	if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$[ebp], 0
	je	SHORT $LN1@WriteBoneM
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@WriteBoneM:

; 1112 : 	
; 1113 : 	return true;

	mov	al, 1

; 1114 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteBoneMatrices@@YA_NPAUsAnimation@@PAPADPAK@Z ENDP	; WriteBoneMatrices
_TEXT	ENDS
PUBLIC	??BD3DXMATRIX@@QAEPAMXZ				; D3DXMATRIX::operator float *
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	?ReadBoneMatrices@@YA_NPAPAUD3DXMATRIX@@KKPAPAD@Z ; ReadBoneMatrices
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ReadBoneMatrices@@YA_NPAPAUD3DXMATRIX@@KKPAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadBoneMatrices@@YA_NPAPAUD3DXMATRIX@@KKPAPAD@Z$0
__ehfuncinfo$?ReadBoneMatrices@@YA_NPAPAUD3DXMATRIX@@KKPAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ReadBoneMatrices@@YA_NPAPAUD3DXMATRIX@@KKPAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?ReadBoneMatrices@@YA_NPAPAUD3DXMATRIX@@KKPAPAD@Z
_TEXT	SEGMENT
tv82 = -108						; size = 4
$T58022 = -104						; size = 4
$T58023 = -100						; size = 4
$T58024 = -96						; size = 4
_iB$57251 = -28						; size = 4
_iA$57246 = -24						; size = 4
_iFrame$57235 = -20					; size = 4
_dwLength$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_ppMatrix$ = 8						; size = 4
_dwA$ = 12						; size = 4
_dwB$ = 16						; size = 4
_ppBlock$ = 20						; size = 4
?ReadBoneMatrices@@YA_NPAPAUD3DXMATRIX@@KKPAPAD@Z PROC	; ReadBoneMatrices, COMDAT

; 1117 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ReadBoneMatrices@@YA_NPAPAUD3DXMATRIX@@KKPAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1118 : 	DWORD dwLength = sizeof ( D3DXMATRIX );

	mov	DWORD PTR _dwLength$[ebp], 64		; 00000040H

; 1119 : 
; 1120 : 	for ( int iFrame = 0; iFrame < (int)dwA; iFrame++ )

	mov	DWORD PTR _iFrame$57235[ebp], 0
	jmp	SHORT $LN9@ReadBoneMa
$LN8@ReadBoneMa:
	mov	eax, DWORD PTR _iFrame$57235[ebp]
	add	eax, 1
	mov	DWORD PTR _iFrame$57235[ebp], eax
$LN9@ReadBoneMa:
	mov	eax, DWORD PTR _iFrame$57235[ebp]
	cmp	eax, DWORD PTR _dwA$[ebp]
	jge	SHORT $LN7@ReadBoneMa

; 1121 : 	{
; 1122 : 		ppMatrix [ iFrame ] = new D3DXMATRIX [ dwB ];

	mov	eax, DWORD PTR _dwB$[ebp]
	mov	DWORD PTR $T58022[ebp], eax
	xor	ecx, ecx
	mov	eax, DWORD PTR $T58022[ebp]
	mov	edx, 64					; 00000040H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58024[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T58024[ebp], 0
	je	SHORT $LN12@ReadBoneMa
	push	OFFSET ??0D3DXMATRIX@@QAE@XZ		; D3DXMATRIX::D3DXMATRIX
	mov	eax, DWORD PTR $T58022[ebp]
	push	eax
	push	64					; 00000040H
	mov	ecx, DWORD PTR $T58024[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EPAX0@Z@Z
	mov	edx, DWORD PTR $T58024[ebp]
	mov	DWORD PTR tv82[ebp], edx
	jmp	SHORT $LN13@ReadBoneMa
$LN12@ReadBoneMa:
	mov	DWORD PTR tv82[ebp], 0
$LN13@ReadBoneMa:
	mov	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR $T58023[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _iFrame$57235[ebp]
	mov	edx, DWORD PTR _ppMatrix$[ebp]
	mov	eax, DWORD PTR $T58023[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 1123 : 	}

	jmp	$LN8@ReadBoneMa
$LN7@ReadBoneMa:

; 1124 : 
; 1125 : 	for ( int iA = 0; iA < (int)dwA; iA++ )

	mov	DWORD PTR _iA$57246[ebp], 0
	jmp	SHORT $LN6@ReadBoneMa
$LN5@ReadBoneMa:
	mov	eax, DWORD PTR _iA$57246[ebp]
	add	eax, 1
	mov	DWORD PTR _iA$57246[ebp], eax
$LN6@ReadBoneMa:
	mov	eax, DWORD PTR _iA$57246[ebp]
	cmp	eax, DWORD PTR _dwA$[ebp]
	jge	SHORT $LN4@ReadBoneMa

; 1126 : 	{
; 1127 : 		for ( int iB = 0; iB < (int)dwB; iB++ )

	mov	DWORD PTR _iB$57251[ebp], 0
	jmp	SHORT $LN3@ReadBoneMa
$LN2@ReadBoneMa:
	mov	eax, DWORD PTR _iB$57251[ebp]
	add	eax, 1
	mov	DWORD PTR _iB$57251[ebp], eax
$LN3@ReadBoneMa:
	mov	eax, DWORD PTR _iB$57251[ebp]
	cmp	eax, DWORD PTR _dwB$[ebp]
	jge	SHORT $LN1@ReadBoneMa

; 1128 : 		{
; 1129 : 			memcpy ( ppMatrix [ iA ] [ iB ], *ppBlock, dwLength );

	mov	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _iB$57251[ebp]
	shl	ecx, 6
	mov	eax, DWORD PTR _iA$57246[ebp]
	mov	edx, DWORD PTR _ppMatrix$[ebp]
	add	ecx, DWORD PTR [edx+eax*4]
	call	??BD3DXMATRIX@@QAEPAMXZ			; D3DXMATRIX::operator float *
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1130 : 			*ppBlock += dwLength;		

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwLength$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx

; 1131 : 		}

	jmp	SHORT $LN2@ReadBoneMa
$LN1@ReadBoneMa:

; 1132 : 	}

	jmp	SHORT $LN5@ReadBoneMa
$LN4@ReadBoneMa:

; 1133 : 
; 1134 : 	return true;

	mov	al, 1

; 1135 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReadBoneMatrices@@YA_NPAPAUD3DXMATRIX@@KKPAPAD@Z$0:
	mov	eax, DWORD PTR $T58024[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ReadBoneMatrices@@YA_NPAPAUD3DXMATRIX@@KKPAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ReadBoneMatrices@@YA_NPAPAUD3DXMATRIX@@KKPAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ReadBoneMatrices@@YA_NPAPAUD3DXMATRIX@@KKPAPAD@Z ENDP	; ReadBoneMatrices
; Function compile flags: /Odtp /ZI
; File c:\program files\microsoft directx sdk (august 2007)\include\d3dx9math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0D3DXMATRIX@@QAE@XZ PROC				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 315  :     D3DXMATRIX() {};

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
; Function compile flags: /Odtp /ZI
; File c:\program files\microsoft directx sdk (august 2007)\include\d3dx9math.inl
_TEXT	ENDS
;	COMDAT ??BD3DXMATRIX@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BD3DXMATRIX@@QAEPAMXZ PROC				; D3DXMATRIX::operator float *, COMDAT
; _this$ = ecx

; 802  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 803  :     return (FLOAT *) &_11;

	mov	eax, DWORD PTR _this$[ebp]

; 804  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BD3DXMATRIX@@QAEPAMXZ ENDP				; D3DXMATRIX::operator float *
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?ScanAnimation@@YA_NPAUsAnimation@@PAPADPAK@Z	; ScanAnimation
; Function compile flags: /Odtp /ZI
; File c:\program files\the game creators\dark gdk\include\dbo format\dboblock.cpp
;	COMDAT ?ScanAnimation@@YA_NPAUsAnimation@@PAPADPAK@Z
_TEXT	SEGMENT
_dwMemorySize$57277 = -8				; size = 4
_pCodeSizePtr$57273 = -4				; size = 4
_pAnim$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
_pdwSize$ = 16						; size = 4
?ScanAnimation@@YA_NPAUsAnimation@@PAPADPAK@Z PROC	; ScanAnimation, COMDAT

; 1138 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1139 : 	// No animation
; 1140 : 	if ( pAnim )

	cmp	DWORD PTR _pAnim$[ebp], 0
	je	$LN24@ScanAnimat

; 1141 : 	{
; 1142 : 		// Write name
; 1143 : 		LPSTR pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57273[ebp], 0

; 1144 : 		if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN23@ScanAnimat
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57273[ebp], ecx
$LN23@ScanAnimat:

; 1145 : 		WriteCODE ( DBOBLOCK_ANIM_NAME, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	211					; 000000d3H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1146 : 		WriteString ( pAnim->szName, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnim$[ebp]
	push	edx
	call	?WriteString@@YA_NPADPAPADPAK@Z		; WriteString
	add	esp, 12					; 0000000cH

; 1147 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1148 : 		if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57273[ebp], 0
	je	SHORT $LN22@ScanAnimat
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57273[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57273[ebp]
	mov	DWORD PTR [edx], ecx
$LN22@ScanAnimat:

; 1149 : 
; 1150 : 		// Write num pos keys
; 1151 : 		WriteCODE	( DBOBLOCK_ANIM_NUMPOSKEYS, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	212					; 000000d4H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1152 : 		WriteDWORD ( pAnim->dwNumPositionKeys, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnim$[ebp]
	mov	eax, DWORD PTR [edx+268]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 1153 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1154 : 
; 1155 : 		// Write pos data
; 1156 : 		DWORD dwMemorySize = sizeof(sPositionKey) * pAnim->dwNumPositionKeys;

	mov	eax, DWORD PTR _pAnim$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	imul	ecx, 28					; 0000001cH
	mov	DWORD PTR _dwMemorySize$57277[ebp], ecx

; 1157 : 		if ( dwMemorySize > 0 )

	cmp	DWORD PTR _dwMemorySize$57277[ebp], 0
	jbe	SHORT $LN21@ScanAnimat

; 1158 : 		{
; 1159 : 			WriteCODE	( DBOBLOCK_ANIM_POSDATA, dwMemorySize, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwMemorySize$57277[ebp]
	push	edx
	push	213					; 000000d5H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1160 : 			WriteMEMORY ( (BYTE*)pAnim->pPositionKeys, dwMemorySize, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwMemorySize$57277[ebp]
	push	edx
	mov	eax, DWORD PTR _pAnim$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	push	ecx
	call	?WriteMEMORY@@YA_NPAEKPAPADPAK@Z	; WriteMEMORY
	add	esp, 16					; 00000010H
$LN21@ScanAnimat:

; 1161 : 		}
; 1162 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1163 : 
; 1164 : 		// Write num rot keys
; 1165 : 		WriteCODE	( DBOBLOCK_ANIM_NUMROTKEYS, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	214					; 000000d6H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1166 : 		WriteDWORD ( pAnim->dwNumRotateKeys, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnim$[ebp]
	mov	eax, DWORD PTR [edx+272]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 1167 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1168 : 
; 1169 : 		// Write rot data
; 1170 : 		dwMemorySize = sizeof(sRotateKey) * pAnim->dwNumRotateKeys;

	mov	eax, DWORD PTR _pAnim$[ebp]
	mov	ecx, DWORD PTR [eax+272]
	imul	ecx, 20					; 00000014H
	mov	DWORD PTR _dwMemorySize$57277[ebp], ecx

; 1171 : 		if ( dwMemorySize > 0 )

	cmp	DWORD PTR _dwMemorySize$57277[ebp], 0
	jbe	SHORT $LN20@ScanAnimat

; 1172 : 		{
; 1173 : 			WriteCODE	( DBOBLOCK_ANIM_ROTDATA, dwMemorySize, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwMemorySize$57277[ebp]
	push	edx
	push	215					; 000000d7H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1174 : 			WriteMEMORY ( (BYTE*)pAnim->pRotateKeys, dwMemorySize, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwMemorySize$57277[ebp]
	push	edx
	mov	eax, DWORD PTR _pAnim$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	push	ecx
	call	?WriteMEMORY@@YA_NPAEKPAPADPAK@Z	; WriteMEMORY
	add	esp, 16					; 00000010H
$LN20@ScanAnimat:

; 1175 : 		}
; 1176 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1177 : 
; 1178 : 		// Write num scale keys
; 1179 : 		WriteCODE	( DBOBLOCK_ANIM_NUMSCALEKEYS, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	216					; 000000d8H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1180 : 		WriteDWORD ( pAnim->dwNumScaleKeys, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnim$[ebp]
	mov	eax, DWORD PTR [edx+276]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 1181 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1182 : 
; 1183 : 		// Write scale data
; 1184 : 		dwMemorySize = sizeof(sScaleKey) * pAnim->dwNumScaleKeys;

	mov	eax, DWORD PTR _pAnim$[ebp]
	mov	ecx, DWORD PTR [eax+276]
	imul	ecx, 28					; 0000001cH
	mov	DWORD PTR _dwMemorySize$57277[ebp], ecx

; 1185 : 		if ( dwMemorySize > 0 )

	cmp	DWORD PTR _dwMemorySize$57277[ebp], 0
	jbe	SHORT $LN19@ScanAnimat

; 1186 : 		{
; 1187 : 			WriteCODE	( DBOBLOCK_ANIM_SCALEDATA, dwMemorySize, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwMemorySize$57277[ebp]
	push	edx
	push	217					; 000000d9H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1188 : 			WriteMEMORY ( (BYTE*)pAnim->pScaleKeys, dwMemorySize, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwMemorySize$57277[ebp]
	push	edx
	mov	eax, DWORD PTR _pAnim$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	push	ecx
	call	?WriteMEMORY@@YA_NPAEKPAPADPAK@Z	; WriteMEMORY
	add	esp, 16					; 00000010H
$LN19@ScanAnimat:

; 1189 : 		}
; 1190 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1191 : 
; 1192 : 		// Write num matrix keys
; 1193 : 		WriteCODE	( DBOBLOCK_ANIM_NUMMATRIXKEYS, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	218					; 000000daH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1194 : 		WriteDWORD ( pAnim->dwNumMatrixKeys, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnim$[ebp]
	mov	eax, DWORD PTR [edx+280]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 1195 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1196 : 
; 1197 : 		// Write matrix data
; 1198 : 		dwMemorySize = sizeof(sMatrixKey) * pAnim->dwNumMatrixKeys;

	mov	eax, DWORD PTR _pAnim$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	imul	ecx, 132				; 00000084H
	mov	DWORD PTR _dwMemorySize$57277[ebp], ecx

; 1199 : 		if ( dwMemorySize > 0 )

	cmp	DWORD PTR _dwMemorySize$57277[ebp], 0
	jbe	SHORT $LN18@ScanAnimat

; 1200 : 		{
; 1201 : 			WriteCODE	( DBOBLOCK_ANIM_MATRIXDATA, dwMemorySize, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwMemorySize$57277[ebp]
	push	edx
	push	219					; 000000dbH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1202 : 			WriteMEMORY ( (BYTE*)pAnim->pMatrixKeys, dwMemorySize, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwMemorySize$57277[ebp]
	push	edx
	mov	eax, DWORD PTR _pAnim$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	push	ecx
	call	?WriteMEMORY@@YA_NPAEKPAPADPAK@Z	; WriteMEMORY
	add	esp, 16					; 00000010H
$LN18@ScanAnimat:

; 1203 : 		}
; 1204 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1205 : 
; 1206 : 		if ( !pAnim->bBoneType )

	mov	eax, DWORD PTR _pAnim$[ebp]
	cmp	DWORD PTR [eax+316], 0
	jne	$LN17@ScanAnimat

; 1207 : 		{
; 1208 : 			pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57273[ebp], 0

; 1209 : 			if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN16@ScanAnimat
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57273[ebp], ecx
$LN16@ScanAnimat:

; 1210 : 			WriteCODE ( DBOBLOCK_FRAME_BONETYPE, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	400					; 00000190H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1211 : 			WriteDWORD ( pAnim->bBoneType, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnim$[ebp]
	mov	eax, DWORD PTR [edx+316]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 1212 : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1213 : 			if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57273[ebp], 0
	je	SHORT $LN15@ScanAnimat
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57273[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57273[ebp]
	mov	DWORD PTR [edx], ecx
$LN15@ScanAnimat:

; 1214 : 
; 1215 : 			pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57273[ebp], 0

; 1216 : 			if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN14@ScanAnimat
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57273[ebp], ecx
$LN14@ScanAnimat:

; 1217 : 			WriteCODE ( DBOBLOCK_FRAME_BONEOFFSETLISTSIZE, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	402					; 00000192H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1218 : 			WriteDWORD ( pAnim->iBoneOffsetListCount, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnim$[ebp]
	mov	eax, DWORD PTR [edx+324]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 1219 : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1220 : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1221 : 			if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57273[ebp], 0
	je	SHORT $LN13@ScanAnimat
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57273[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57273[ebp]
	mov	DWORD PTR [edx], ecx
$LN13@ScanAnimat:

; 1222 : 			
; 1223 : 			pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57273[ebp], 0

; 1224 : 			if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN12@ScanAnimat
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57273[ebp], ecx
$LN12@ScanAnimat:

; 1225 : 			WriteCODE	( DBOBLOCK_FRAME_BONEOFFSETLIST, pAnim->iBoneOffsetListCount * sizeof ( int ), ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnim$[ebp]
	mov	eax, DWORD PTR [edx+324]
	shl	eax, 2
	push	eax
	push	401					; 00000191H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1226 : 			WriteOffsetList ( pAnim->piBoneOffsetList, pAnim->iBoneOffsetListCount, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnim$[ebp]
	mov	eax, DWORD PTR [edx+324]
	push	eax
	mov	ecx, DWORD PTR _pAnim$[ebp]
	mov	edx, DWORD PTR [ecx+320]
	push	edx
	call	?WriteOffsetList@@YA_NPAHKPAPADPAK@Z	; WriteOffsetList
	add	esp, 16					; 00000010H

; 1227 : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1228 : 			if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57273[ebp], 0
	je	SHORT $LN11@ScanAnimat
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57273[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57273[ebp]
	mov	DWORD PTR [edx], ecx
$LN11@ScanAnimat:

; 1229 : 
; 1230 : 			pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57273[ebp], 0

; 1231 : 			if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN10@ScanAnimat
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57273[ebp], ecx
$LN10@ScanAnimat:

; 1232 : 			WriteCODE ( DBOBLOCK_FRAME_BONEMATRIXSIZEA, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	403					; 00000193H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1233 : 			WriteDWORD ( pAnim->iBoneFrameA, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnim$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 1234 : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1235 : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1236 : 			if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57273[ebp], 0
	je	SHORT $LN9@ScanAnimat
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57273[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57273[ebp]
	mov	DWORD PTR [edx], ecx
$LN9@ScanAnimat:

; 1237 : 
; 1238 : 			pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57273[ebp], 0

; 1239 : 			if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN8@ScanAnimat
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57273[ebp], ecx
$LN8@ScanAnimat:

; 1240 : 			WriteCODE ( DBOBLOCK_FRAME_BONEMATRIXSIZEB, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	404					; 00000194H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1241 : 			WriteDWORD ( pAnim->iBoneFrameB, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnim$[ebp]
	mov	eax, DWORD PTR [edx+336]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 1242 : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1243 : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1244 : 			if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57273[ebp], 0
	je	SHORT $LN7@ScanAnimat
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57273[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57273[ebp]
	mov	DWORD PTR [edx], ecx
$LN7@ScanAnimat:

; 1245 : 
; 1246 : 			pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57273[ebp], 0

; 1247 : 			if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN6@ScanAnimat
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57273[ebp], ecx
$LN6@ScanAnimat:

; 1248 : 			WriteCODE	( DBOBLOCK_FRAME_BONEMATRIXLIST, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	405					; 00000195H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1249 : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1250 : 			WriteBoneMatrices ( pAnim, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnim$[ebp]
	push	edx
	call	?WriteBoneMatrices@@YA_NPAUsAnimation@@PAPADPAK@Z ; WriteBoneMatrices
	add	esp, 12					; 0000000cH

; 1251 : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1252 : 			if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57273[ebp], 0
	je	SHORT $LN17@ScanAnimat
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57273[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57273[ebp]
	mov	DWORD PTR [edx], ecx
$LN17@ScanAnimat:

; 1253 : 		}
; 1254 : 		
; 1255 : 		// Write NEXT animdata (if present)
; 1256 : 		if ( pAnim->pNext )

	mov	eax, DWORD PTR _pAnim$[ebp]
	cmp	DWORD PTR [eax+344], 0
	je	$LN24@ScanAnimat

; 1257 : 		{
; 1258 : 			pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57273[ebp], 0

; 1259 : 			if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN3@ScanAnimat
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57273[ebp], ecx
$LN3@ScanAnimat:

; 1260 : 			WriteCODE	( DBOBLOCK_ANIM_NEXT, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	220					; 000000dcH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1261 : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1262 : 			if ( pAnim->pNext ) ScanAnimation ( pAnim->pNext, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pAnim$[ebp]
	cmp	DWORD PTR [eax+344], 0
	je	SHORT $LN2@ScanAnimat
	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnim$[ebp]
	mov	eax, DWORD PTR [edx+344]
	push	eax
	call	?ScanAnimation@@YA_NPAUsAnimation@@PAPADPAK@Z ; ScanAnimation
	add	esp, 12					; 0000000cH
$LN2@ScanAnimat:

; 1263 : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1264 : 			if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57273[ebp], 0
	je	SHORT $LN24@ScanAnimat
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57273[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57273[ebp]
	mov	DWORD PTR [edx], ecx
$LN24@ScanAnimat:

; 1265 : 		}
; 1266 : 	}
; 1267 : 
; 1268 : 	// No more anim codes
; 1269 : 	WriteCODE ( 0, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	0
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1270 : 
; 1271 : 	// okay
; 1272 : 	return true;

	mov	al, 1

; 1273 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ScanAnimation@@YA_NPAUsAnimation@@PAPADPAK@Z ENDP	; ScanAnimation
_TEXT	ENDS
PUBLIC	?ScanAnimationSet@@YA_NPAUsAnimationSet@@PAPADPAK@Z ; ScanAnimationSet
; Function compile flags: /Odtp /ZI
;	COMDAT ?ScanAnimationSet@@YA_NPAUsAnimationSet@@PAPADPAK@Z
_TEXT	SEGMENT
_pCodeSizePtr$57321 = -4				; size = 4
_pAnimSet$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
_pdwSize$ = 16						; size = 4
?ScanAnimationSet@@YA_NPAUsAnimationSet@@PAPADPAK@Z PROC ; ScanAnimationSet, COMDAT

; 1276 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1277 : 	// No animation set
; 1278 : 	if ( pAnimSet )

	cmp	DWORD PTR _pAnimSet$[ebp], 0
	je	$LN6@ScanAnimat@2

; 1279 : 	{
; 1280 : 		// Write name
; 1281 : 		LPSTR pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57321[ebp], 0

; 1282 : 		if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN5@ScanAnimat@2
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57321[ebp], ecx
$LN5@ScanAnimat@2:

; 1283 : 		WriteCODE ( DBOBLOCK_ANIMSET_NAME, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	201					; 000000c9H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1284 : 		WriteString ( pAnimSet->szName, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnimSet$[ebp]
	push	edx
	call	?WriteString@@YA_NPADPAPADPAK@Z		; WriteString
	add	esp, 12					; 0000000cH

; 1285 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1286 : 		if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57321[ebp], 0
	je	SHORT $LN4@ScanAnimat@2
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57321[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57321[ebp]
	mov	DWORD PTR [edx], ecx
$LN4@ScanAnimat@2:

; 1287 : 
; 1288 : 		// Write length
; 1289 : 		WriteCODE	( DBOBLOCK_ANIMSET_LENGTH, 4, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	4
	push	202					; 000000caH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1290 : 		WriteDWORD ( (DWORD)pAnimSet->ulLength, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnimSet$[ebp]
	mov	eax, DWORD PTR [edx+260]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 1291 : 		WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1292 : 
; 1293 : 		// Write animation data
; 1294 : 		if ( pAnimSet->pAnimation )

	mov	eax, DWORD PTR _pAnimSet$[ebp]
	cmp	DWORD PTR [eax+256], 0
	je	SHORT $LN6@ScanAnimat@2

; 1295 : 		{
; 1296 : 			pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$57321[ebp], 0

; 1297 : 			if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN2@ScanAnimat@2
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$57321[ebp], ecx
$LN2@ScanAnimat@2:

; 1298 : 			WriteCODE ( DBOBLOCK_ANIMSET_DATA, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	203					; 000000cbH
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1299 : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1300 : 			ScanAnimation ( pAnimSet->pAnimation, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAnimSet$[ebp]
	mov	eax, DWORD PTR [edx+256]
	push	eax
	call	?ScanAnimation@@YA_NPAUsAnimation@@PAPADPAK@Z ; ScanAnimation
	add	esp, 12					; 0000000cH

; 1301 : 			WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1302 : 			if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$57321[ebp], 0
	je	SHORT $LN6@ScanAnimat@2
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$57321[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$57321[ebp]
	mov	DWORD PTR [edx], ecx
$LN6@ScanAnimat@2:

; 1303 : 		}
; 1304 : 	}
; 1305 : 
; 1306 : 	// No more animationset codes
; 1307 : 	WriteCODE ( 0, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	0
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1308 : 
; 1309 : 	// okay
; 1310 : 	return true;

	mov	al, 1

; 1311 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ScanAnimationSet@@YA_NPAUsAnimationSet@@PAPADPAK@Z ENDP ; ScanAnimationSet
_TEXT	ENDS
PUBLIC	??_C@_08HFDNDKLG@MAGICDBO?$AA@			; `string'
PUBLIC	?ScanObject@@YA_NPAUsObject@@PAPADPAK@Z		; ScanObject
;	COMDAT ??_C@_08HFDNDKLG@MAGICDBO?$AA@
CONST	SEGMENT
??_C@_08HFDNDKLG@MAGICDBO?$AA@ DB 'MAGICDBO', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?ScanObject@@YA_NPAUsObject@@PAPADPAK@Z
_TEXT	SEGMENT
_pCodeSizePtr$ = -4					; size = 4
_pObject$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
_pdwSize$ = 16						; size = 4
?ScanObject@@YA_NPAUsObject@@PAPADPAK@Z PROC		; ScanObject, COMDAT

; 1314 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1315 : 	// write header [magic, version, res, res]
; 1316 : 	WriteString	( "MAGICDBO", ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	OFFSET ??_C@_08HFDNDKLG@MAGICDBO?$AA@
	call	?WriteString@@YA_NPADPAPADPAK@Z		; WriteString
	add	esp, 12					; 0000000cH

; 1317 : 	WriteDWORD	(  DBO_VERSION_NUMBER, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	1062					; 00000426H
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 1318 : 	WriteDWORD	(  0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 1319 : 	WriteDWORD	(  0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 1320 : 	WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1321 : 
; 1322 : 	// scan frame data
; 1323 : 	LPSTR pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$[ebp], 0

; 1324 : 	if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN8@ScanObject
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$[ebp], ecx
$LN8@ScanObject:

; 1325 : 	WriteCODE ( DBOBLOCK_ROOT_FRAME, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	1
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1326 : 	WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1327 : 	if ( !ScanFrame ( pObject->pFrame, ppBlock, pdwSize ) ) return false;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pObject$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	?ScanFrame@@YA_NPAUsFrame@@PAPADPAK@Z	; ScanFrame
	add	esp, 12					; 0000000cH
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@ScanObject
	xor	al, al
	jmp	$LN9@ScanObject
$LN7@ScanObject:

; 1328 : 	WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1329 : 	if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$[ebp], 0
	je	SHORT $LN6@ScanObject
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$[ebp]
	mov	DWORD PTR [edx], ecx
$LN6@ScanObject:

; 1330 : 
; 1331 : 	// scan animation data
; 1332 : 	pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$[ebp], 0

; 1333 : 	if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN5@ScanObject
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$[ebp], ecx
$LN5@ScanObject:

; 1334 : 	WriteCODE ( DBOBLOCK_ROOT_ANIMATIONSET, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	2
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1335 : 	WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1336 : 	if ( !ScanAnimationSet ( pObject->pAnimationSet, ppBlock, pdwSize ) ) return false;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pObject$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	?ScanAnimationSet@@YA_NPAUsAnimationSet@@PAPADPAK@Z ; ScanAnimationSet
	add	esp, 12					; 0000000cH
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@ScanObject
	xor	al, al
	jmp	$LN9@ScanObject
$LN4@ScanObject:

; 1337 : 	WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1338 : 	if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$[ebp], 0
	je	SHORT $LN3@ScanObject
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@ScanObject:

; 1339 : 
; 1340 : 	// 280305 - used when objects want to store custom data for example when they save and want to save out this data
; 1341 : 	pCodeSizePtr = NULL;

	mov	DWORD PTR _pCodeSizePtr$[ebp], 0

; 1342 : 	if ( ppBlock ) pCodeSizePtr = *ppBlock+4;

	cmp	DWORD PTR _ppBlock$[ebp], 0
	je	SHORT $LN2@ScanObject
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR _pCodeSizePtr$[ebp], ecx
$LN2@ScanObject:

; 1343 : 	WriteCODE ( DBOBLOCK_OBJECT_CUSTOMDATA, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	406					; 00000196H
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1344 : 	WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1345 : 	WriteDWORD ( pObject->dwCustomSize, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pObject$[ebp]
	mov	eax, DWORD PTR [edx+1316]
	push	eax
	call	?WriteDWORD@@YA_NKPAPADPAK@Z		; WriteDWORD
	add	esp, 12					; 0000000cH

; 1346 : 	WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1347 : 	WriteMEMORY ( (BYTE*)pObject->pCustomData, pObject->dwCustomSize, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pObject$[ebp]
	mov	eax, DWORD PTR [edx+1316]
	push	eax
	mov	ecx, DWORD PTR _pObject$[ebp]
	mov	edx, DWORD PTR [ecx+1320]
	push	edx
	call	?WriteMEMORY@@YA_NPAEKPAPADPAK@Z	; WriteMEMORY
	add	esp, 16					; 00000010H

; 1348 : 	WriteCR ( ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	call	?WriteCR@@YA_NPAPADPAK@Z		; WriteCR
	add	esp, 8

; 1349 : 	if ( pCodeSizePtr ) *(DWORD*)pCodeSizePtr=(*ppBlock-4)-pCodeSizePtr;

	cmp	DWORD PTR _pCodeSizePtr$[ebp], 0
	je	SHORT $LN1@ScanObject
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	sub	ecx, DWORD PTR _pCodeSizePtr$[ebp]
	mov	edx, DWORD PTR _pCodeSizePtr$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@ScanObject:

; 1350 : 
; 1351 : 	// leefix - 070405 - No more tokens to parse (scan functions do this at end!)
; 1352 : 	WriteCODE ( 0, 0, ppBlock, pdwSize );

	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBlock$[ebp]
	push	ecx
	push	0
	push	0
	call	?WriteCODE@@YA_NKKPAPADPAK@Z		; WriteCODE
	add	esp, 16					; 00000010H

; 1353 : 
; 1354 : 	// okay
; 1355 : 	return true;

	mov	al, 1
$LN9@ScanObject:

; 1356 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ScanObject@@YA_NPAUsObject@@PAPADPAK@Z ENDP		; ScanObject
_TEXT	ENDS
PUBLIC	?ConstructBones@@YA_NPAPAUsBone@@KPAPAD@Z	; ConstructBones
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??0sBone@@QAE@XZ:PROC				; sBone::sBone
EXTRN	??1sBone@@QAE@XZ:PROC				; sBone::~sBone
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ConstructBones@@YA_NPAPAUsBone@@KPAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ConstructBones@@YA_NPAPAUsBone@@KPAPAD@Z$0
__ehfuncinfo$?ConstructBones@@YA_NPAPAUsBone@@KPAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ConstructBones@@YA_NPAPAUsBone@@KPAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?ConstructBones@@YA_NPAPAUsBone@@KPAPAD@Z
_TEXT	SEGMENT
tv95 = -108						; size = 4
tv90 = -108						; size = 4
$T58051 = -104						; size = 4
$T58052 = -100						; size = 4
$T58053 = -96						; size = 4
_pBone$57368 = -28					; size = 4
_bi$57364 = -24						; size = 4
_dwCodeSize$ = -20					; size = 4
_dwCode$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ppBone$ = 8						; size = 4
_dwBoneCount$ = 12					; size = 4
_ppBlock$ = 16						; size = 4
?ConstructBones@@YA_NPAPAUsBone@@KPAPAD@Z PROC		; ConstructBones, COMDAT

; 1363 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ConstructBones@@YA_NPAPAUsBone@@KPAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1364 : 	// get code
; 1365 : 	DWORD dwCode = 0;

	mov	DWORD PTR _dwCode$[ebp], 0

; 1366 : 	DWORD dwCodeSize = 0;

	mov	DWORD PTR _dwCodeSize$[ebp], 0

; 1367 : 	ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1368 : 	if ( dwCode > 0 )

	cmp	DWORD PTR _dwCode$[ebp], 0
	jbe	$LN14@ConstructB

; 1369 : 	{
; 1370 : 		// create bone
; 1371 : 		(*ppBone) = new sBone [ dwBoneCount ];

	mov	eax, DWORD PTR _dwBoneCount$[ebp]
	mov	DWORD PTR $T58051[ebp], eax
	xor	ecx, ecx
	mov	eax, DWORD PTR $T58051[ebp]
	mov	edx, 344				; 00000158H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58053[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T58053[ebp], 0
	je	SHORT $LN17@ConstructB
	mov	ecx, DWORD PTR $T58053[ebp]
	mov	edx, DWORD PTR $T58051[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1sBone@@QAE@XZ			; sBone::~sBone
	push	OFFSET ??0sBone@@QAE@XZ			; sBone::sBone
	mov	eax, DWORD PTR $T58051[ebp]
	push	eax
	push	344					; 00000158H
	mov	ecx, DWORD PTR $T58053[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T58053[ebp]
	add	edx, 4
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN18@ConstructB
$LN17@ConstructB:
	mov	DWORD PTR tv90[ebp], 0
$LN18@ConstructB:
	mov	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR $T58052[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _ppBone$[ebp]
	mov	edx, DWORD PTR $T58052[ebp]
	mov	DWORD PTR [ecx], edx
$LN14@ConstructB:

; 1372 : 	}
; 1373 : 
; 1374 : 	// V110 BETA6 - 100608 - why was this so, it scews up models with no bones!!
; 1375 : 	// dwBoneCount=dwBoneCount-1;
; 1376 : 
; 1377 : 	for ( DWORD bi=0; bi<dwBoneCount; bi++ )

	mov	DWORD PTR _bi$57364[ebp], 0
	jmp	SHORT $LN13@ConstructB
$LN12@ConstructB:
	mov	eax, DWORD PTR _bi$57364[ebp]
	add	eax, 1
	mov	DWORD PTR _bi$57364[ebp], eax
$LN13@ConstructB:
	mov	eax, DWORD PTR _bi$57364[ebp]
	cmp	eax, DWORD PTR _dwBoneCount$[ebp]
	jae	$LN11@ConstructB

; 1378 : 	{
; 1379 : 		// bone in question
; 1380 : 		sBone* pBone = &((*ppBone) [ bi ]);

	mov	eax, DWORD PTR _bi$57364[ebp]
	imul	eax, 344				; 00000158H
	mov	ecx, DWORD PTR _ppBone$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pBone$57368[ebp], eax
$LN10@ConstructB:

; 1381 : 
; 1382 : 		while ( dwCode > 0 )

	cmp	DWORD PTR _dwCode$[ebp], 0
	jbe	$LN9@ConstructB

; 1383 : 		{
; 1384 : 			switch ( dwCode )

	mov	eax, DWORD PTR _dwCode$[ebp]
	mov	DWORD PTR tv95[ebp], eax
	mov	ecx, DWORD PTR tv95[ebp]
	sub	ecx, 301				; 0000012dH
	mov	DWORD PTR tv95[ebp], ecx
	cmp	DWORD PTR tv95[ebp], 4
	ja	$LN1@ConstructB
	mov	edx, DWORD PTR tv95[ebp]
	jmp	DWORD PTR $LN21@ConstructB[edx*4]
$LN6@ConstructB:

; 1385 : 			{
; 1386 : 				case DBOBLOCK_BONES_NAME :				ReadString ( (*pBone).szName,				ppBlock );	break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBone$57368[ebp]
	push	ecx
	call	?ReadString@@YA_NPADPAPAD@Z		; ReadString
	add	esp, 8
	jmp	$LN7@ConstructB
$LN5@ConstructB:

; 1387 : 				case DBOBLOCK_BONES_NUMINFLUENCES :		ReadDWORD ( &(*pBone).dwNumInfluences,		ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBone$57368[ebp]
	add	ecx, 256				; 00000100H
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	SHORT $LN7@ConstructB
$LN4@ConstructB:

; 1388 : 				case DBOBLOCK_BONES_VERTICES :			ReadMemory ( (BYTE**)&(*pBone).pVertices,	sizeof(DWORD) * (*pBone).dwNumInfluences,	ppBlock );	break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBone$57368[ebp]
	mov	edx, DWORD PTR [ecx+256]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _pBone$57368[ebp]
	add	eax, 260				; 00000104H
	push	eax
	call	?ReadMemory@@YA_NPAPAEKPAPAD@Z		; ReadMemory
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN7@ConstructB
$LN3@ConstructB:

; 1389 : 				case DBOBLOCK_BONES_WEIGHTS :			ReadMemory ( (BYTE**)&(*pBone).pWeights,	sizeof(float) * (*pBone).dwNumInfluences,	ppBlock );	break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBone$57368[ebp]
	mov	edx, DWORD PTR [ecx+256]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _pBone$57368[ebp]
	add	eax, 264				; 00000108H
	push	eax
	call	?ReadMemory@@YA_NPAPAEKPAPAD@Z		; ReadMemory
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN7@ConstructB
$LN2@ConstructB:

; 1390 : 				case DBOBLOCK_BONES_TRANSLATIONMATRIX :	ReadMatrix ( &(*pBone).matTranslation,		ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBone$57368[ebp]
	add	ecx, 268				; 0000010cH
	push	ecx
	call	?ReadMatrix@@YA_NPAUD3DXMATRIX@@PAPAD@Z	; ReadMatrix
	add	esp, 8
	jmp	SHORT $LN7@ConstructB
$LN1@ConstructB:

; 1391 : 
; 1392 : 				default : 
; 1393 : 					*ppBlock += dwCodeSize;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwCodeSize$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN7@ConstructB:

; 1394 : 					break;
; 1395 : 			}
; 1396 : 
; 1397 : 			// get next code
; 1398 : 			ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1399 : 		}

	jmp	$LN10@ConstructB
$LN9@ConstructB:

; 1400 : 
; 1401 : 		// get next code
; 1402 : 		ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1403 : 	}

	jmp	$LN12@ConstructB
$LN11@ConstructB:

; 1404 : 
; 1405 : 	// okay
; 1406 : 	return true;

	mov	al, 1

; 1407 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN21@ConstructB:
	DD	$LN6@ConstructB
	DD	$LN5@ConstructB
	DD	$LN4@ConstructB
	DD	$LN3@ConstructB
	DD	$LN2@ConstructB
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ConstructBones@@YA_NPAPAUsBone@@KPAPAD@Z$0:
	mov	eax, DWORD PTR $T58053[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ConstructBones@@YA_NPAPAUsBone@@KPAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ConstructBones@@YA_NPAPAUsBone@@KPAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ConstructBones@@YA_NPAPAUsBone@@KPAPAD@Z ENDP		; ConstructBones
PUBLIC	??_EsBone@@QAEPAXI@Z				; sBone::`vector deleting destructor'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_EsBone@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EsBone@@QAEPAXI@Z PROC				; sBone::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@2
	push	OFFSET ??1sBone@@QAE@XZ			; sBone::~sBone
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	push	ecx
	push	344					; 00000158H
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@vector@2
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@2
$LN3@vector@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1sBone@@QAE@XZ			; sBone::~sBone
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_EsBone@@QAEPAXI@Z ENDP				; sBone::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?ConstructTexture@@YA_NPAPAUsTexture@@KPAPAD@Z	; ConstructTexture
EXTRN	??0sTexture@@QAE@XZ:PROC			; sTexture::sTexture
EXTRN	??1sTexture@@QAE@XZ:PROC			; sTexture::~sTexture
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ConstructTexture@@YA_NPAPAUsTexture@@KPAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ConstructTexture@@YA_NPAPAUsTexture@@KPAPAD@Z$0
__ehfuncinfo$?ConstructTexture@@YA_NPAPAUsTexture@@KPAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ConstructTexture@@YA_NPAPAUsTexture@@KPAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?ConstructTexture@@YA_NPAPAUsTexture@@KPAPAD@Z
_TEXT	SEGMENT
tv95 = -108						; size = 4
tv90 = -108						; size = 4
$T58068 = -104						; size = 4
$T58069 = -100						; size = 4
$T58070 = -96						; size = 4
_pTexture$57412 = -28					; size = 4
_ti$57408 = -24						; size = 4
_dwCodeSize$ = -20					; size = 4
_dwCode$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ppTexture$ = 8						; size = 4
_dwTextureCount$ = 12					; size = 4
_ppBlock$ = 16						; size = 4
?ConstructTexture@@YA_NPAPAUsTexture@@KPAPAD@Z PROC	; ConstructTexture, COMDAT

; 1410 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ConstructTexture@@YA_NPAPAUsTexture@@KPAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1411 : 	// get code
; 1412 : 	DWORD dwCode = 0;

	mov	DWORD PTR _dwCode$[ebp], 0

; 1413 : 	DWORD dwCodeSize = 0;

	mov	DWORD PTR _dwCodeSize$[ebp], 0

; 1414 : 	ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1415 : 	if ( dwCode > 0 )

	cmp	DWORD PTR _dwCode$[ebp], 0
	jbe	$LN22@ConstructT

; 1416 : 	{
; 1417 : 		// create texture
; 1418 : 		(*ppTexture) = new sTexture [ dwTextureCount ];

	mov	eax, DWORD PTR _dwTextureCount$[ebp]
	mov	DWORD PTR $T58068[ebp], eax
	xor	ecx, ecx
	mov	eax, DWORD PTR $T58068[ebp]
	mov	edx, 328				; 00000148H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58070[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T58070[ebp], 0
	je	SHORT $LN25@ConstructT
	mov	ecx, DWORD PTR $T58070[ebp]
	mov	edx, DWORD PTR $T58068[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1sTexture@@QAE@XZ		; sTexture::~sTexture
	push	OFFSET ??0sTexture@@QAE@XZ		; sTexture::sTexture
	mov	eax, DWORD PTR $T58068[ebp]
	push	eax
	push	328					; 00000148H
	mov	ecx, DWORD PTR $T58070[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T58070[ebp]
	add	edx, 4
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN26@ConstructT
$LN25@ConstructT:
	mov	DWORD PTR tv90[ebp], 0
$LN26@ConstructT:
	mov	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR $T58069[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _ppTexture$[ebp]
	mov	edx, DWORD PTR $T58069[ebp]
	mov	DWORD PTR [ecx], edx
$LN22@ConstructT:

; 1419 : 	}
; 1420 : 	for ( DWORD ti=0; ti<dwTextureCount; ti++ )

	mov	DWORD PTR _ti$57408[ebp], 0
	jmp	SHORT $LN21@ConstructT
$LN20@ConstructT:
	mov	eax, DWORD PTR _ti$57408[ebp]
	add	eax, 1
	mov	DWORD PTR _ti$57408[ebp], eax
$LN21@ConstructT:
	mov	eax, DWORD PTR _ti$57408[ebp]
	cmp	eax, DWORD PTR _dwTextureCount$[ebp]
	jae	$LN19@ConstructT

; 1421 : 	{
; 1422 : 		// texture in question
; 1423 : 		sTexture* pTexture = &((*ppTexture) [ ti ]);

	mov	eax, DWORD PTR _ti$57408[ebp]
	imul	eax, 328				; 00000148H
	mov	ecx, DWORD PTR _ppTexture$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pTexture$57412[ebp], eax
$LN18@ConstructT:

; 1424 : 
; 1425 : 		while ( dwCode > 0 )

	cmp	DWORD PTR _dwCode$[ebp], 0
	jbe	$LN17@ConstructT

; 1426 : 		{
; 1427 : 			switch ( dwCode )

	mov	eax, DWORD PTR _dwCode$[ebp]
	mov	DWORD PTR tv95[ebp], eax
	mov	ecx, DWORD PTR tv95[ebp]
	sub	ecx, 141				; 0000008dH
	mov	DWORD PTR tv95[ebp], ecx
	cmp	DWORD PTR tv95[ebp], 12			; 0000000cH
	ja	$LN1@ConstructT
	mov	edx, DWORD PTR tv95[ebp]
	jmp	DWORD PTR $LN29@ConstructT[edx*4]
$LN14@ConstructT:

; 1428 : 			{
; 1429 : 				case DBOBLOCK_TEXTURE_NAME :	ReadString ( (pTexture)->pName,						ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTexture$57412[ebp]
	push	ecx
	call	?ReadString@@YA_NPADPAPAD@Z		; ReadString
	add	esp, 8
	jmp	$LN15@ConstructT
$LN13@ConstructT:

; 1430 : 				case DBOBLOCK_TEXTURE_STAGE :	ReadDWORD  ( &(pTexture)->dwStage,					ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTexture$57412[ebp]
	add	ecx, 268				; 0000010cH
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN15@ConstructT
$LN12@ConstructT:

; 1431 : 				case DBOBLOCK_TEXTURE_BMODE :	ReadDWORD  ( &(pTexture)->dwBlendMode,				ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTexture$57412[ebp]
	add	ecx, 272				; 00000110H
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN15@ConstructT
$LN11@ConstructT:

; 1432 : 				case DBOBLOCK_TEXTURE_BARG1 :	ReadDWORD  ( &(pTexture)->dwBlendArg1,				ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTexture$57412[ebp]
	add	ecx, 276				; 00000114H
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN15@ConstructT
$LN10@ConstructT:

; 1433 : 				case DBOBLOCK_TEXTURE_BARG2 :	ReadDWORD  ( &(pTexture)->dwBlendArg2,				ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTexture$57412[ebp]
	add	ecx, 280				; 00000118H
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN15@ConstructT
$LN9@ConstructT:

; 1434 : 				case DBOBLOCK_TEXTURE_ADDRU :	ReadDWORD  ( &(pTexture)->dwAddressU,				ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTexture$57412[ebp]
	add	ecx, 284				; 0000011cH
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN15@ConstructT
$LN8@ConstructT:

; 1435 : 				case DBOBLOCK_TEXTURE_ADDRV :	ReadDWORD  ( &(pTexture)->dwAddressV,				ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTexture$57412[ebp]
	add	ecx, 288				; 00000120H
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN15@ConstructT
$LN7@ConstructT:

; 1436 : 				case DBOBLOCK_TEXTURE_MAG :		ReadDWORD  ( &(pTexture)->dwMagState,				ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTexture$57412[ebp]
	add	ecx, 292				; 00000124H
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN15@ConstructT
$LN6@ConstructT:

; 1437 : 				case DBOBLOCK_TEXTURE_MIN :		ReadDWORD  ( &(pTexture)->dwMinState,				ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTexture$57412[ebp]
	add	ecx, 296				; 00000128H
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	SHORT $LN15@ConstructT
$LN5@ConstructT:

; 1438 : 				case DBOBLOCK_TEXTURE_MIP :		ReadDWORD  ( &(pTexture)->dwMipState,				ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTexture$57412[ebp]
	add	ecx, 300				; 0000012cH
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	SHORT $LN15@ConstructT
$LN4@ConstructT:

; 1439 : 				case DBOBLOCK_TEXTURE_TCMODE :	ReadDWORD  ( &(pTexture)->dwTexCoordMode,			ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTexture$57412[ebp]
	add	ecx, 304				; 00000130H
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	SHORT $LN15@ConstructT
$LN3@ConstructT:

; 1440 : 				case DBOBLOCK_TEXTURE_PRIMST :	ReadDWORD  ( (DWORD*)&(pTexture)->iStartIndex,		ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTexture$57412[ebp]
	add	ecx, 308				; 00000134H
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	SHORT $LN15@ConstructT
$LN2@ConstructT:

; 1441 : 				case DBOBLOCK_TEXTURE_PRIMCN :	ReadDWORD  ( (DWORD*)&(pTexture)->iPrimitiveCount,	ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTexture$57412[ebp]
	add	ecx, 312				; 00000138H
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	SHORT $LN15@ConstructT
$LN1@ConstructT:

; 1442 : 
; 1443 : 				default : 
; 1444 : 					*ppBlock += dwCodeSize;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwCodeSize$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN15@ConstructT:

; 1445 : 					break;
; 1446 : 			}
; 1447 : 
; 1448 : 			// get next code
; 1449 : 			ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1450 : 		}

	jmp	$LN18@ConstructT
$LN17@ConstructT:

; 1451 : 
; 1452 : 		// get next code
; 1453 : 		ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1454 : 	}

	jmp	$LN20@ConstructT
$LN19@ConstructT:

; 1455 : 
; 1456 : 	// okay
; 1457 : 	return true;

	mov	al, 1

; 1458 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@ConstructT:
	DD	$LN14@ConstructT
	DD	$LN13@ConstructT
	DD	$LN12@ConstructT
	DD	$LN11@ConstructT
	DD	$LN10@ConstructT
	DD	$LN9@ConstructT
	DD	$LN8@ConstructT
	DD	$LN7@ConstructT
	DD	$LN6@ConstructT
	DD	$LN5@ConstructT
	DD	$LN4@ConstructT
	DD	$LN3@ConstructT
	DD	$LN2@ConstructT
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ConstructTexture@@YA_NPAPAUsTexture@@KPAPAD@Z$0:
	mov	eax, DWORD PTR $T58070[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ConstructTexture@@YA_NPAPAUsTexture@@KPAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ConstructTexture@@YA_NPAPAUsTexture@@KPAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ConstructTexture@@YA_NPAPAUsTexture@@KPAPAD@Z ENDP	; ConstructTexture
PUBLIC	??_EsTexture@@QAEPAXI@Z				; sTexture::`vector deleting destructor'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_EsTexture@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EsTexture@@QAEPAXI@Z PROC				; sTexture::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@3
	push	OFFSET ??1sTexture@@QAE@XZ		; sTexture::~sTexture
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	push	ecx
	push	328					; 00000148H
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@vector@3
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@3
$LN3@vector@3:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1sTexture@@QAE@XZ			; sTexture::~sTexture
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@3:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_EsTexture@@QAEPAXI@Z ENDP				; sTexture::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?ConstructMultiMaterial@@YA_NPAPAUsMultiMaterial@@KPAPAD@Z ; ConstructMultiMaterial
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ?ConstructMultiMaterial@@YA_NPAPAUsMultiMaterial@@KPAPAD@Z
_TEXT	SEGMENT
tv84 = -88						; size = 4
$T58085 = -84						; size = 4
_pMultiMat$57458 = -16					; size = 4
_ti$57454 = -12						; size = 4
_dwCodeSize$ = -8					; size = 4
_dwCode$ = -4						; size = 4
_ppMultiMaterial$ = 8					; size = 4
_dwMultiMatCount$ = 12					; size = 4
_ppBlock$ = 16						; size = 4
?ConstructMultiMaterial@@YA_NPAPAUsMultiMaterial@@KPAPAD@Z PROC ; ConstructMultiMaterial, COMDAT

; 1461 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1462 : 	// get code
; 1463 : 	DWORD dwCode = 0;

	mov	DWORD PTR _dwCode$[ebp], 0

; 1464 : 	DWORD dwCodeSize = 0;

	mov	DWORD PTR _dwCodeSize$[ebp], 0

; 1465 : 	ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1466 : 	if ( dwCode > 0 )

	cmp	DWORD PTR _dwCode$[ebp], 0
	jbe	SHORT $LN14@ConstructM

; 1467 : 	{
; 1468 : 		// create multi material
; 1469 : 		(*ppMultiMaterial) = new sMultiMaterial [ dwMultiMatCount ];

	xor	ecx, ecx
	mov	eax, DWORD PTR _dwMultiMatCount$[ebp]
	mov	edx, 340				; 00000154H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58085[ebp], eax
	mov	eax, DWORD PTR _ppMultiMaterial$[ebp]
	mov	ecx, DWORD PTR $T58085[ebp]
	mov	DWORD PTR [eax], ecx

; 1470 : 
; 1471 : 		// clear multi material data array
; 1472 : 		memset ( (*ppMultiMaterial), 0, sizeof(sMultiMaterial) * dwMultiMatCount );

	mov	eax, DWORD PTR _dwMultiMatCount$[ebp]
	imul	eax, 340				; 00000154H
	push	eax
	push	0
	mov	ecx, DWORD PTR _ppMultiMaterial$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN14@ConstructM:

; 1473 : 	}
; 1474 : 	for ( DWORD ti=0; ti<dwMultiMatCount; ti++ )

	mov	DWORD PTR _ti$57454[ebp], 0
	jmp	SHORT $LN13@ConstructM
$LN12@ConstructM:
	mov	eax, DWORD PTR _ti$57454[ebp]
	add	eax, 1
	mov	DWORD PTR _ti$57454[ebp], eax
$LN13@ConstructM:
	mov	eax, DWORD PTR _ti$57454[ebp]
	cmp	eax, DWORD PTR _dwMultiMatCount$[ebp]
	jae	$LN11@ConstructM

; 1475 : 	{
; 1476 : 		// multi material in question
; 1477 : 		sMultiMaterial* pMultiMat = &((*ppMultiMaterial) [ ti ]);

	mov	eax, DWORD PTR _ti$57454[ebp]
	imul	eax, 340				; 00000154H
	mov	ecx, DWORD PTR _ppMultiMaterial$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pMultiMat$57458[ebp], eax
$LN10@ConstructM:

; 1478 : 
; 1479 : 		while ( dwCode > 0 )

	cmp	DWORD PTR _dwCode$[ebp], 0
	jbe	$LN9@ConstructM

; 1480 : 		{
; 1481 : 			switch ( dwCode )

	mov	eax, DWORD PTR _dwCode$[ebp]
	mov	DWORD PTR tv84[ebp], eax
	mov	ecx, DWORD PTR tv84[ebp]
	sub	ecx, 161				; 000000a1H
	mov	DWORD PTR tv84[ebp], ecx
	cmp	DWORD PTR tv84[ebp], 4
	ja	SHORT $LN1@ConstructM
	mov	edx, DWORD PTR tv84[ebp]
	jmp	DWORD PTR $LN17@ConstructM[edx*4]
$LN6@ConstructM:

; 1482 : 			{
; 1483 : 				case DBOBLOCK_MULTIMAT_NAME :		ReadString   ( (pMultiMat)->pName,			ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMultiMat$57458[ebp]
	push	ecx
	call	?ReadString@@YA_NPADPAPAD@Z		; ReadString
	add	esp, 8
	jmp	SHORT $LN7@ConstructM
$LN5@ConstructM:

; 1484 : 				case DBOBLOCK_MULTIMAT_MATERIAL :	ReadMaterial ( &(pMultiMat)->mMaterial,		ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMultiMat$57458[ebp]
	add	ecx, 260				; 00000104H
	push	ecx
	call	?ReadMaterial@@YA_NPAU_D3DMATERIAL9@@PAPAD@Z ; ReadMaterial
	add	esp, 8
	jmp	SHORT $LN7@ConstructM
$LN4@ConstructM:

; 1485 : 				case DBOBLOCK_MULTIMAT_START :		ReadDWORD    ( &(pMultiMat)->dwIndexStart,	ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMultiMat$57458[ebp]
	add	ecx, 328				; 00000148H
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	SHORT $LN7@ConstructM
$LN3@ConstructM:

; 1486 : 				case DBOBLOCK_MULTIMAT_COUNT :		ReadDWORD    ( &(pMultiMat)->dwIndexCount,	ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMultiMat$57458[ebp]
	add	ecx, 332				; 0000014cH
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	SHORT $LN7@ConstructM
$LN2@ConstructM:

; 1487 : 				case DBOBLOCK_MULTIMAT_POLY :		ReadDWORD    ( &(pMultiMat)->dwPolyCount,	ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMultiMat$57458[ebp]
	add	ecx, 336				; 00000150H
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	SHORT $LN7@ConstructM
$LN1@ConstructM:

; 1488 : 
; 1489 : 				default : 
; 1490 : 					*ppBlock += dwCodeSize;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwCodeSize$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN7@ConstructM:

; 1491 : 					break;
; 1492 : 			}
; 1493 : 
; 1494 : 			// get next code
; 1495 : 			ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1496 : 		}

	jmp	$LN10@ConstructM
$LN9@ConstructM:

; 1497 : 
; 1498 : 		// get next code
; 1499 : 		ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1500 : 	}

	jmp	$LN12@ConstructM
$LN11@ConstructM:

; 1501 : 
; 1502 : 	// okay
; 1503 : 	return true;

	mov	al, 1

; 1504 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN17@ConstructM:
	DD	$LN6@ConstructM
	DD	$LN5@ConstructM
	DD	$LN4@ConstructM
	DD	$LN3@ConstructM
	DD	$LN2@ConstructM
?ConstructMultiMaterial@@YA_NPAPAUsMultiMaterial@@KPAPAD@Z ENDP ; ConstructMultiMaterial
_TEXT	ENDS
PUBLIC	?ConstructFrame@@YA_NPAPAUsFrame@@PAPAD@Z	; ConstructFrame
PUBLIC	?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z		; ConstructMesh
EXTRN	??0sFrame@@QAE@XZ:PROC				; sFrame::sFrame
EXTRN	??1sFrame@@QAE@XZ:PROC				; sFrame::~sFrame
EXTRN	??0sMesh@@QAE@XZ:PROC				; sMesh::sMesh
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z$2
__ehfuncinfo$?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z
_TEXT	SEGMENT
tv204 = -124						; size = 4
tv190 = -124						; size = 4
tv76 = -124						; size = 4
tv75 = -124						; size = 4
$T58089 = -120						; size = 4
$T58090 = -116						; size = 4
$T58093 = -112						; size = 4
$T58094 = -108						; size = 4
$T58095 = -104						; size = 4
$T58098 = -100						; size = 4
$T58099 = -96						; size = 4
_pFrames$57510 = -28					; size = 4
_dwSubMesh$57506 = -24					; size = 4
_dwCodeSize$ = -20					; size = 4
_dwCode$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ppMesh$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z PROC		; ConstructMesh, COMDAT

; 1507 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1508 : 	// get code
; 1509 : 	DWORD dwCode = 0;

	mov	DWORD PTR _dwCode$[ebp], 0

; 1510 : 	DWORD dwCodeSize = 0;

	mov	DWORD PTR _dwCodeSize$[ebp], 0

; 1511 : 	ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1512 : 	if ( dwCode > 0 )

	cmp	DWORD PTR _dwCode$[ebp], 0
	jbe	SHORT $LN48@ConstructM@2

; 1513 : 	{
; 1514 : 		// create mesh
; 1515 : 		(*ppMesh) = new sMesh;

	push	1272					; 000004f8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58090[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T58090[ebp], 0
	je	SHORT $LN52@ConstructM@2
	mov	ecx, DWORD PTR $T58090[ebp]
	call	??0sMesh@@QAE@XZ			; sMesh::sMesh
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN53@ConstructM@2
$LN52@ConstructM@2:
	mov	DWORD PTR tv75[ebp], 0
$LN53@ConstructM@2:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T58089[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR $T58089[ebp]
	mov	DWORD PTR [ecx], edx
$LN48@ConstructM@2:

; 1516 : 	}
; 1517 : 	while ( dwCode > 0 )

	cmp	DWORD PTR _dwCode$[ebp], 0
	jbe	$LN47@ConstructM@2

; 1518 : 	{
; 1519 : 		switch ( dwCode )

	mov	eax, DWORD PTR _dwCode$[ebp]
	mov	DWORD PTR tv76[ebp], eax
	mov	ecx, DWORD PTR tv76[ebp]
	sub	ecx, 111				; 0000006fH
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 55			; 00000037H
	ja	$LN1@ConstructM@2
	mov	edx, DWORD PTR tv76[ebp]
	movzx	eax, BYTE PTR $LN61@ConstructM@2[edx]
	jmp	DWORD PTR $LN63@ConstructM@2[eax*4]
$LN44@ConstructM@2:

; 1520 : 		{
; 1521 : 			// Read vertex information
; 1522 : 			case DBOBLOCK_MESH_FVF :			ReadDWORD      ( &(*ppMesh)->dwFVF,				ppBlock );													break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 4
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN43@ConstructM@2:

; 1523 : 			case DBOBLOCK_MESH_FVFSIZE :		ReadDWORD      ( &(*ppMesh)->dwFVFSize,			ppBlock );													break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 8
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN42@ConstructM@2:

; 1524 : 			case DBOBLOCK_MESH_VERTEXCOUNT :	ReadDWORD      ( &(*ppMesh)->dwVertexCount,		ppBlock );													break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 28					; 0000001cH
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN41@ConstructM@2:

; 1525 : 			case DBOBLOCK_MESH_INDEXCOUNT :		ReadDWORD      ( &(*ppMesh)->dwIndexCount,		ppBlock );													break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 32					; 00000020H
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN40@ConstructM@2:

; 1526 : 			case DBOBLOCK_MESH_VERTEXDEC :		ReadIntoMemory ( (BYTE*)(*ppMesh)->pVertexDeclaration, sizeof((*ppMesh)->pVertexDeclaration), ppBlock );	break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	push	520					; 00000208H
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 68					; 00000044H
	push	edx
	call	?ReadIntoMemory@@YA_NPAEKPAPAD@Z	; ReadIntoMemory
	add	esp, 12					; 0000000cH
	jmp	$LN45@ConstructM@2
$LN39@ConstructM@2:

; 1527 : 
; 1528 : 			case DBOBLOCK_MESH_SUBFRAMES :
; 1529 : 			{
; 1530 : 				ReadDWORD ( (DWORD*)&(*ppMesh)->dwSubMeshListCount,	ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1104				; 00000450H
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8

; 1531 : 
; 1532 : 				if ( ( *ppMesh )->dwSubMeshListCount > 0 )

	mov	eax, DWORD PTR _ppMesh$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+1104], 0
	jbe	$LN38@ConstructM@2

; 1533 : 				{
; 1534 : 					( *ppMesh )->pSubFrameList = new sFrame [ ( *ppMesh )->dwSubMeshListCount ];

	mov	eax, DWORD PTR _ppMesh$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+1104]
	mov	DWORD PTR $T58093[ebp], edx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T58093[ebp]
	mov	edx, 804				; 00000324H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58095[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T58095[ebp], 0
	je	SHORT $LN54@ConstructM@2
	mov	ecx, DWORD PTR $T58095[ebp]
	mov	edx, DWORD PTR $T58093[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1sFrame@@QAE@XZ		; sFrame::~sFrame
	push	OFFSET ??0sFrame@@QAE@XZ		; sFrame::sFrame
	mov	eax, DWORD PTR $T58093[ebp]
	push	eax
	push	804					; 00000324H
	mov	ecx, DWORD PTR $T58095[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T58095[ebp]
	add	edx, 4
	mov	DWORD PTR tv190[ebp], edx
	jmp	SHORT $LN55@ConstructM@2
$LN54@ConstructM@2:
	mov	DWORD PTR tv190[ebp], 0
$LN55@ConstructM@2:
	mov	eax, DWORD PTR tv190[ebp]
	mov	DWORD PTR $T58094[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR $T58094[ebp]
	mov	DWORD PTR [edx+1100], eax

; 1535 : 
; 1536 : 					for ( DWORD dwSubMesh = 0; dwSubMesh < ( *ppMesh )->dwSubMeshListCount; dwSubMesh++ )

	mov	DWORD PTR _dwSubMesh$57506[ebp], 0
	jmp	SHORT $LN37@ConstructM@2
$LN36@ConstructM@2:
	mov	eax, DWORD PTR _dwSubMesh$57506[ebp]
	add	eax, 1
	mov	DWORD PTR _dwSubMesh$57506[ebp], eax
$LN37@ConstructM@2:
	mov	eax, DWORD PTR _ppMesh$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _dwSubMesh$57506[ebp]
	cmp	edx, DWORD PTR [ecx+1104]
	jae	SHORT $LN38@ConstructM@2

; 1537 : 					{
; 1538 : 						sFrame* pFrames = new sFrame;

	push	804					; 00000324H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58099[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T58099[ebp], 0
	je	SHORT $LN56@ConstructM@2
	mov	ecx, DWORD PTR $T58099[ebp]
	call	??0sFrame@@QAE@XZ			; sFrame::sFrame
	mov	DWORD PTR tv204[ebp], eax
	jmp	SHORT $LN57@ConstructM@2
$LN56@ConstructM@2:
	mov	DWORD PTR tv204[ebp], 0
$LN57@ConstructM@2:
	mov	eax, DWORD PTR tv204[ebp]
	mov	DWORD PTR $T58098[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T58098[ebp]
	mov	DWORD PTR _pFrames$57510[ebp], ecx

; 1539 : 
; 1540 : 						ConstructFrame ( &pFrames, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pFrames$57510[ebp]
	push	ecx
	call	?ConstructFrame@@YA_NPAPAUsFrame@@PAPAD@Z ; ConstructFrame
	add	esp, 8

; 1541 : 
; 1542 : 						( *ppMesh )->pSubFrameList [ dwSubMesh ] = *pFrames;

	mov	esi, DWORD PTR _pFrames$57510[ebp]
	mov	eax, DWORD PTR _ppMesh$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _dwSubMesh$57506[ebp]
	imul	edx, 804				; 00000324H
	mov	edi, DWORD PTR [ecx+1100]
	add	edi, edx
	mov	ecx, 201				; 000000c9H
	rep movsd

; 1543 : 					}

	jmp	$LN36@ConstructM@2
$LN38@ConstructM@2:

; 1544 : 				}
; 1545 : 			}
; 1546 : 			break;

	jmp	$LN45@ConstructM@2
$LN34@ConstructM@2:

; 1547 : 			
; 1548 : 			case DBOBLOCK_MESH_VERTEXDATA :		ReadVertexData ( &(*ppMesh)->pVertexData, (*ppMesh)->dwFVFSize, (*ppMesh)->dwVertexCount, ppBlock );	break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 20					; 00000014H
	push	edx
	call	?ReadVertexData@@YA_NPAPAEKKPAPAD@Z	; ReadVertexData
	add	esp, 16					; 00000010H
	jmp	$LN45@ConstructM@2
$LN33@ConstructM@2:

; 1549 : 			
; 1550 : 			case DBOBLOCK_MESH_INDEXDATA :
; 1551 : 			{
; 1552 : 				ReadIndexData ( &(*ppMesh)->pIndices, (*ppMesh)->dwIndexCount, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 24					; 00000018H
	push	edx
	call	?ReadIndexData@@YA_NPAPAGKPAPAD@Z	; ReadIndexData
	add	esp, 12					; 0000000cH

; 1553 : 
; 1554 : 				if ( ( *ppMesh )->dwIndexCount == 0 )

	mov	eax, DWORD PTR _ppMesh$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN32@ConstructM@2

; 1555 : 					*ppBlock += dwCodeSize;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwCodeSize$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN32@ConstructM@2:

; 1556 : 			}
; 1557 : 			break;

	jmp	$LN45@ConstructM@2
$LN31@ConstructM@2:

; 1558 : 
; 1559 : 			case DBOBLOCK_MESH_PRIMTYPE :		ReadDWORD              ( (DWORD*)&(*ppMesh)->iPrimitiveType, ppBlock );								break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 36					; 00000024H
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN30@ConstructM@2:

; 1560 : 			case DBOBLOCK_MESH_DRAWVERTCOUNT :	ReadDWORD              ( (DWORD*)&(*ppMesh)->iDrawVertexCount, ppBlock );							break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 40					; 00000028H
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN29@ConstructM@2:

; 1561 : 			case DBOBLOCK_MESH_DRAWPRIMCOUNT :	ReadDWORD              ( (DWORD*)&(*ppMesh)->iDrawPrimitives, ppBlock );							break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 44					; 0000002cH
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN28@ConstructM@2:

; 1562 : 			case DBOBLOCK_MESH_BONECOUNT :		ReadDWORD              ( &(*ppMesh)->dwBoneCount, ppBlock );										break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 876				; 0000036cH
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN27@ConstructM@2:

; 1563 : 			case DBOBLOCK_MESH_BONESDATA : 		ConstructBones         ( &(*ppMesh)->pBones, (*ppMesh)->dwBoneCount, ppBlock );						break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+876]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 872				; 00000368H
	push	edx
	call	?ConstructBones@@YA_NPAPAUsBone@@KPAPAD@Z ; ConstructBones
	add	esp, 12					; 0000000cH
	jmp	$LN45@ConstructM@2
$LN26@ConstructM@2:

; 1564 : 			case DBOBLOCK_MESH_USEMATERIAL : 	ReadBOOL               ( &(*ppMesh)->bUsesMaterial, ppBlock );										break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 888				; 00000378H
	push	edx
	call	?ReadBOOL@@YA_NPA_NPAPAD@Z		; ReadBOOL
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN25@ConstructM@2:

; 1565 : 			case DBOBLOCK_MESH_MATERIAL : 		ReadMaterial           ( &(*ppMesh)->mMaterial,	ppBlock );											break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 916				; 00000394H
	push	edx
	call	?ReadMaterial@@YA_NPAU_D3DMATERIAL9@@PAPAD@Z ; ReadMaterial
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN24@ConstructM@2:

; 1566 : 			case DBOBLOCK_MESH_TEXTURECOUNT : 	ReadDWORD              ( &(*ppMesh)->dwTextureCount, ppBlock );										break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 892				; 0000037cH
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN23@ConstructM@2:

; 1567 : 			case DBOBLOCK_MESH_TEXTURES :		ConstructTexture       ( &(*ppMesh)->pTextures,	(*ppMesh)->dwTextureCount, ppBlock );				break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+892]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 904				; 00000388H
	push	edx
	call	?ConstructTexture@@YA_NPAPAUsTexture@@KPAPAD@Z ; ConstructTexture
	add	esp, 12					; 0000000cH
	jmp	$LN45@ConstructM@2
$LN22@ConstructM@2:

; 1568 : 			case DBOBLOCK_MESH_USEMULTIMAT : 	ReadBOOL               ( &(*ppMesh)->bUseMultiMaterial,	ppBlock );									break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 890				; 0000037aH
	push	edx
	call	?ReadBOOL@@YA_NPA_NPAPAD@Z		; ReadBOOL
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN21@ConstructM@2:

; 1569 : 			case DBOBLOCK_MESH_MULTIMATCOUNT : 	ReadDWORD              ( &(*ppMesh)->dwMultiMaterialCount, ppBlock );								break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 896				; 00000380H
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN20@ConstructM@2:

; 1570 : 			case DBOBLOCK_MESH_MULTIMAT	: 		ConstructMultiMaterial ( &(*ppMesh)->pMultiMaterial, (*ppMesh)->dwMultiMaterialCount, ppBlock );	break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+896]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 908				; 0000038cH
	push	edx
	call	?ConstructMultiMaterial@@YA_NPAPAUsMultiMaterial@@KPAPAD@Z ; ConstructMultiMaterial
	add	esp, 12					; 0000000cH
	jmp	$LN45@ConstructM@2
$LN19@ConstructM@2:

; 1571 : 			case DBOBLOCK_MESH_WIREFRAME :		ReadBOOL               ( &(*ppMesh)->bWireframe, ppBlock );											break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1036				; 0000040cH
	push	edx
	call	?ReadBOOL@@YA_NPA_NPAPAD@Z		; ReadBOOL
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN18@ConstructM@2:

; 1572 : 			case DBOBLOCK_MESH_LIGHT :			ReadBOOL               ( &(*ppMesh)->bLight, ppBlock );												break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1037				; 0000040dH
	push	edx
	call	?ReadBOOL@@YA_NPA_NPAPAD@Z		; ReadBOOL
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN17@ConstructM@2:

; 1573 : 			case DBOBLOCK_MESH_CULL :			ReadBOOL               ( &(*ppMesh)->bCull,	ppBlock );												break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1038				; 0000040eH
	push	edx
	call	?ReadBOOL@@YA_NPA_NPAPAD@Z		; ReadBOOL
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN16@ConstructM@2:

; 1574 : 			case DBOBLOCK_MESH_FOG :			ReadBOOL               ( &(*ppMesh)->bFog, ppBlock );												break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1039				; 0000040fH
	push	edx
	call	?ReadBOOL@@YA_NPA_NPAPAD@Z		; ReadBOOL
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN15@ConstructM@2:

; 1575 : 			case DBOBLOCK_MESH_AMBIENT :		ReadBOOL               ( &(*ppMesh)->bAmbient, ppBlock );											break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1040				; 00000410H
	push	edx
	call	?ReadBOOL@@YA_NPA_NPAPAD@Z		; ReadBOOL
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN14@ConstructM@2:

; 1576 : 			case DBOBLOCK_MESH_TRANSPARENCY :	ReadBOOL               ( &(*ppMesh)->bTransparency, ppBlock );										break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1041				; 00000411H
	push	edx
	call	?ReadBOOL@@YA_NPA_NPAPAD@Z		; ReadBOOL
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN13@ConstructM@2:

; 1577 : 			case DBOBLOCK_MESH_GHOST :			ReadBOOL               ( &(*ppMesh)->bGhost, ppBlock );												break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1048				; 00000418H
	push	edx
	call	?ReadBOOL@@YA_NPA_NPAPAD@Z		; ReadBOOL
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN12@ConstructM@2:

; 1578 : 			case DBOBLOCK_MESH_GHOSTMODE :		ReadDWORD              ( (DWORD*)&(*ppMesh)->iGhostMode, ppBlock );									break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1052				; 0000041cH
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN11@ConstructM@2:

; 1579 : 			case DBOBLOCK_MESH_VISIBLE :		ReadBOOL               ( &(*ppMesh)->bVisible, ppBlock );											break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1049				; 00000419H
	push	edx
	call	?ReadBOOL@@YA_NPA_NPAPAD@Z		; ReadBOOL
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN10@ConstructM@2:

; 1580 : 			case DBOBLOCK_MESH_LINKED :			ReadBOOL               ( &(*ppMesh)->bLinked, ppBlock );											break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1136				; 00000470H
	push	edx
	call	?ReadBOOL@@YA_NPA_NPAPAD@Z		; ReadBOOL
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN9@ConstructM@2:

; 1581 : 
; 1582 : 			case DBOBLOCK_MESH_FXEFFECTNAME :	
; 1583 : 			{
; 1584 : 				// 250704 - create vertex effect object
; 1585 : 				ReadString ( (*ppMesh)->pEffectName,	ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 604				; 0000025cH
	push	edx
	call	?ReadString@@YA_NPADPAPAD@Z		; ReadString
	add	esp, 8

; 1586 : 				(*ppMesh)->bUseVertexShader = true;

	mov	eax, DWORD PTR _ppMesh$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+64], 1

; 1587 : 				break;

	jmp	$LN45@ConstructM@2
$LN8@ConstructM@2:

; 1588 : 			}
; 1589 : 
; 1590 : 			case DBOBLOCK_MESH_ARBITARYVALUE :	
; 1591 : 			{
; 1592 : 				// 190804 - retain this value
; 1593 : 				ReadDWORD              ( (DWORD*)&(*ppMesh)->Collision.dwArbitaryValue, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1240				; 000004d8H
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8

; 1594 : 				break;

	jmp	$LN45@ConstructM@2
$LN7@ConstructM@2:

; 1595 : 			}
; 1596 : 				
; 1597 : 			case DBOBLOCK_MESH_ZBIASFLAG :		ReadBOOL               ( &(*ppMesh)->bZBiasActive, ppBlock );										break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1056				; 00000420H
	push	edx
	call	?ReadBOOL@@YA_NPA_NPAPAD@Z		; ReadBOOL
	add	esp, 8
	jmp	$LN45@ConstructM@2
$LN6@ConstructM@2:

; 1598 : 			case DBOBLOCK_MESH_ZBIASSLOPE :		ReadDWORD              ( (DWORD*)&(*ppMesh)->fZBiasSlopeScale, ppBlock );							break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1060				; 00000424H
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	SHORT $LN45@ConstructM@2
$LN5@ConstructM@2:

; 1599 : 			case DBOBLOCK_MESH_ZBIASDEPTH :		ReadDWORD              ( (DWORD*)&(*ppMesh)->fZBiasDepth, ppBlock );								break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1064				; 00000428H
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	SHORT $LN45@ConstructM@2
$LN4@ConstructM@2:

; 1600 : 			case DBOBLOCK_MESH_ZREAD :			ReadBOOL               ( &(*ppMesh)->bZRead, ppBlock );												break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1050				; 0000041aH
	push	edx
	call	?ReadBOOL@@YA_NPA_NPAPAD@Z		; ReadBOOL
	add	esp, 8
	jmp	SHORT $LN45@ConstructM@2
$LN3@ConstructM@2:

; 1601 : 			case DBOBLOCK_MESH_ZWRITE :			ReadBOOL               ( &(*ppMesh)->bZWrite, ppBlock );											break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1051				; 0000041bH
	push	edx
	call	?ReadBOOL@@YA_NPA_NPAPAD@Z		; ReadBOOL
	add	esp, 8
	jmp	SHORT $LN45@ConstructM@2
$LN2@ConstructM@2:

; 1602 : 
; 1603 : 			case DBOBLOCK_MESH_ALPHATESTVALUE : ReadDWORD              ( (DWORD*)&(*ppMesh)->dwAlphaTestValue, ppBlock );									break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppMesh$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1044				; 00000414H
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	SHORT $LN45@ConstructM@2
$LN1@ConstructM@2:

; 1604 : 
; 1605 : 			default : 
; 1606 : 				*ppBlock += dwCodeSize;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwCodeSize$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN45@ConstructM@2:

; 1607 : 			break;
; 1608 : 		}
; 1609 : 
; 1610 : 		// get next code
; 1611 : 		ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1612 : 	}

	jmp	$LN48@ConstructM@2
$LN47@ConstructM@2:

; 1613 : 
; 1614 : 	// okay
; 1615 : 	return true;

	mov	al, 1

; 1616 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN63@ConstructM@2:
	DD	$LN44@ConstructM@2
	DD	$LN43@ConstructM@2
	DD	$LN42@ConstructM@2
	DD	$LN41@ConstructM@2
	DD	$LN34@ConstructM@2
	DD	$LN33@ConstructM@2
	DD	$LN31@ConstructM@2
	DD	$LN30@ConstructM@2
	DD	$LN29@ConstructM@2
	DD	$LN40@ConstructM@2
	DD	$LN28@ConstructM@2
	DD	$LN27@ConstructM@2
	DD	$LN22@ConstructM@2
	DD	$LN21@ConstructM@2
	DD	$LN26@ConstructM@2
	DD	$LN25@ConstructM@2
	DD	$LN24@ConstructM@2
	DD	$LN23@ConstructM@2
	DD	$LN19@ConstructM@2
	DD	$LN18@ConstructM@2
	DD	$LN17@ConstructM@2
	DD	$LN16@ConstructM@2
	DD	$LN15@ConstructM@2
	DD	$LN14@ConstructM@2
	DD	$LN13@ConstructM@2
	DD	$LN12@ConstructM@2
	DD	$LN10@ConstructM@2
	DD	$LN39@ConstructM@2
	DD	$LN20@ConstructM@2
	DD	$LN11@ConstructM@2
	DD	$LN9@ConstructM@2
	DD	$LN8@ConstructM@2
	DD	$LN7@ConstructM@2
	DD	$LN6@ConstructM@2
	DD	$LN5@ConstructM@2
	DD	$LN4@ConstructM@2
	DD	$LN3@ConstructM@2
	DD	$LN2@ConstructM@2
	DD	$LN1@ConstructM@2
$LN61@ConstructM@2:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	37					; 00000025H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z$0:
	mov	eax, DWORD PTR $T58090[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z$1:
	mov	eax, DWORD PTR $T58095[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z$2:
	mov	eax, DWORD PTR $T58099[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z ENDP		; ConstructMesh
PUBLIC	??_EsFrame@@QAEPAXI@Z				; sFrame::`vector deleting destructor'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_EsFrame@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EsFrame@@QAEPAXI@Z PROC				; sFrame::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@4
	push	OFFSET ??1sFrame@@QAE@XZ		; sFrame::~sFrame
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	push	ecx
	push	804					; 00000324H
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@vector@4
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@vector@4:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@4
$LN3@vector@4:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1sFrame@@QAE@XZ			; sFrame::~sFrame
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@4:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@4:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_EsFrame@@QAEPAXI@Z ENDP				; sFrame::`vector deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ConstructFrame@@YA_NPAPAUsFrame@@PAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ConstructFrame@@YA_NPAPAUsFrame@@PAPAD@Z$0
__ehfuncinfo$?ConstructFrame@@YA_NPAPAUsFrame@@PAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ConstructFrame@@YA_NPAPAUsFrame@@PAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?ConstructFrame@@YA_NPAPAUsFrame@@PAPAD@Z
_TEXT	SEGMENT
tv76 = -96						; size = 4
tv75 = -96						; size = 4
$T58117 = -92						; size = 4
$T58118 = -88						; size = 4
_dwCodeSize$ = -20					; size = 4
_dwCode$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ppFrame$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
?ConstructFrame@@YA_NPAPAUsFrame@@PAPAD@Z PROC		; ConstructFrame, COMDAT

; 1621 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ConstructFrame@@YA_NPAPAUsFrame@@PAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1622 : 	// get code
; 1623 : 	DWORD dwCode = 0;

	mov	DWORD PTR _dwCode$[ebp], 0

; 1624 : 	DWORD dwCodeSize = 0;

	mov	DWORD PTR _dwCodeSize$[ebp], 0

; 1625 : 	ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1626 : 	if ( dwCode > 0 )

	cmp	DWORD PTR _dwCode$[ebp], 0
	jbe	SHORT $LN13@ConstructF

; 1627 : 	{
; 1628 : 		// create frame
; 1629 : 		(*ppFrame) = new sFrame;

	push	804					; 00000324H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58118[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T58118[ebp], 0
	je	SHORT $LN17@ConstructF
	mov	ecx, DWORD PTR $T58118[ebp]
	call	??0sFrame@@QAE@XZ			; sFrame::sFrame
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN18@ConstructF
$LN17@ConstructF:
	mov	DWORD PTR tv75[ebp], 0
$LN18@ConstructF:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T58117[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _ppFrame$[ebp]
	mov	edx, DWORD PTR $T58117[ebp]
	mov	DWORD PTR [ecx], edx
$LN13@ConstructF:

; 1630 : 	}
; 1631 : 
; 1632 : 	while ( dwCode > 0 )

	cmp	DWORD PTR _dwCode$[ebp], 0
	jbe	$LN12@ConstructF

; 1633 : 	{
; 1634 : 		switch ( dwCode )

	mov	eax, DWORD PTR _dwCode$[ebp]
	mov	DWORD PTR tv76[ebp], eax
	mov	ecx, DWORD PTR tv76[ebp]
	sub	ecx, 101				; 00000065H
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 7
	ja	$LN1@ConstructF
	mov	edx, DWORD PTR tv76[ebp]
	jmp	DWORD PTR $LN21@ConstructF[edx*4]
$LN9@ConstructF:

; 1635 : 		{
; 1636 : 			case DBOBLOCK_FRAME_NAME :     ReadString     ( (*ppFrame)->szName, ppBlock );			break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppFrame$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?ReadString@@YA_NPADPAPAD@Z		; ReadString
	add	esp, 8
	jmp	$LN10@ConstructF
$LN8@ConstructF:

; 1637 : 			case DBOBLOCK_FRAME_MATRIX :   ReadMatrix     ( &(*ppFrame)->matOriginal, ppBlock );	break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppFrame$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 272				; 00000110H
	push	edx
	call	?ReadMatrix@@YA_NPAUD3DXMATRIX@@PAPAD@Z	; ReadMatrix
	add	esp, 8
	jmp	$LN10@ConstructF
$LN7@ConstructF:

; 1638 : 			case DBOBLOCK_FRAME_MESH :     ConstructMesh  ( &(*ppFrame)->pMesh, ppBlock );			break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppFrame$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 760				; 000002f8H
	push	edx
	call	?ConstructMesh@@YA_NPAPAUsMesh@@PAPAD@Z	; ConstructMesh
	add	esp, 8
	jmp	$LN10@ConstructF
$LN6@ConstructF:

; 1639 : 			case DBOBLOCK_FRAME_CHILD :    ConstructFrame ( &(*ppFrame)->pChild, ppBlock );			break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppFrame$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 264				; 00000108H
	push	edx
	call	?ConstructFrame@@YA_NPAPAUsFrame@@PAPAD@Z ; ConstructFrame
	add	esp, 8
	jmp	SHORT $LN10@ConstructF
$LN5@ConstructF:

; 1640 : 			case DBOBLOCK_FRAME_SIBLING :  ConstructFrame ( &(*ppFrame)->pSibling, ppBlock );		break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppFrame$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 268				; 0000010cH
	push	edx
	call	?ConstructFrame@@YA_NPAPAUsFrame@@PAPAD@Z ; ConstructFrame
	add	esp, 8
	jmp	SHORT $LN10@ConstructF
$LN4@ConstructF:

; 1641 : 			case DBOBLOCK_FRAME_OFFSET :   ReadVector     ( &(*ppFrame)->vecOffset, ppBlock );		break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppFrame$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 672				; 000002a0H
	push	edx
	call	?ReadVector@@YA_NPAUD3DXVECTOR3@@PAPAD@Z ; ReadVector
	add	esp, 8
	jmp	SHORT $LN10@ConstructF
$LN3@ConstructF:

; 1642 : 			case DBOBLOCK_FRAME_ROTATION : ReadVector     ( &(*ppFrame)->vecRotation, ppBlock );	break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppFrame$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 696				; 000002b8H
	push	edx
	call	?ReadVector@@YA_NPAUD3DXVECTOR3@@PAPAD@Z ; ReadVector
	add	esp, 8
	jmp	SHORT $LN10@ConstructF
$LN2@ConstructF:

; 1643 : 			case DBOBLOCK_FRAME_SCALE :    ReadVector     ( &(*ppFrame)->vecScale, ppBlock );		break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppFrame$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 684				; 000002acH
	push	edx
	call	?ReadVector@@YA_NPAUD3DXVECTOR3@@PAPAD@Z ; ReadVector
	add	esp, 8
	jmp	SHORT $LN10@ConstructF
$LN1@ConstructF:

; 1644 : 
; 1645 : 			default :
; 1646 : 				*ppBlock += dwCodeSize;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwCodeSize$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN10@ConstructF:

; 1647 : 			break;
; 1648 : 		}
; 1649 : 
; 1650 : 		// get next code
; 1651 : 		ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1652 : 	}

	jmp	$LN13@ConstructF
$LN12@ConstructF:

; 1653 : 
; 1654 : 	// okay
; 1655 : 	return true;

	mov	al, 1

; 1656 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@ConstructF:
	DD	$LN9@ConstructF
	DD	$LN8@ConstructF
	DD	$LN7@ConstructF
	DD	$LN6@ConstructF
	DD	$LN5@ConstructF
	DD	$LN4@ConstructF
	DD	$LN3@ConstructF
	DD	$LN2@ConstructF
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ConstructFrame@@YA_NPAPAUsFrame@@PAPAD@Z$0:
	mov	eax, DWORD PTR $T58118[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ConstructFrame@@YA_NPAPAUsFrame@@PAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ConstructFrame@@YA_NPAPAUsFrame@@PAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ConstructFrame@@YA_NPAPAUsFrame@@PAPAD@Z ENDP		; ConstructFrame
PUBLIC	?ConstructAnimation@@YA_NPAPAUsAnimation@@PAPAD@Z ; ConstructAnimation
EXTRN	??0sAnimation@@QAE@XZ:PROC			; sAnimation::sAnimation
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ConstructAnimation@@YA_NPAPAUsAnimation@@PAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ConstructAnimation@@YA_NPAPAUsAnimation@@PAPAD@Z$0
__ehfuncinfo$?ConstructAnimation@@YA_NPAPAUsAnimation@@PAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ConstructAnimation@@YA_NPAPAUsAnimation@@PAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?ConstructAnimation@@YA_NPAPAUsAnimation@@PAPAD@Z
_TEXT	SEGMENT
tv76 = -100						; size = 4
tv75 = -100						; size = 4
$T58131 = -96						; size = 4
$T58132 = -92						; size = 4
$T58135 = -88						; size = 4
_dwCodeSize$ = -20					; size = 4
_dwCode$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ppAnim$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
?ConstructAnimation@@YA_NPAPAUsAnimation@@PAPAD@Z PROC	; ConstructAnimation, COMDAT

; 1659 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ConstructAnimation@@YA_NPAPAUsAnimation@@PAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1660 : 	// get code
; 1661 : 	DWORD dwCode = 0;

	mov	DWORD PTR _dwCode$[ebp], 0

; 1662 : 	DWORD dwCodeSize = 0;

	mov	DWORD PTR _dwCodeSize$[ebp], 0

; 1663 : 	ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1664 : 	if ( dwCode > 0 )

	cmp	DWORD PTR _dwCode$[ebp], 0
	jbe	SHORT $LN21@ConstructA

; 1665 : 	{
; 1666 : 		// create animset
; 1667 : 		(*ppAnim) = new sAnimation;

	push	360					; 00000168H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58132[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T58132[ebp], 0
	je	SHORT $LN25@ConstructA
	mov	ecx, DWORD PTR $T58132[ebp]
	call	??0sAnimation@@QAE@XZ			; sAnimation::sAnimation
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN26@ConstructA
$LN25@ConstructA:
	mov	DWORD PTR tv75[ebp], 0
$LN26@ConstructA:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T58131[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR $T58131[ebp]
	mov	DWORD PTR [ecx], edx
$LN21@ConstructA:

; 1668 : 	}
; 1669 : 
; 1670 : 	while ( dwCode > 0 )

	cmp	DWORD PTR _dwCode$[ebp], 0
	jbe	$LN20@ConstructA

; 1671 : 	{
; 1672 : 		switch ( dwCode )

	mov	eax, DWORD PTR _dwCode$[ebp]
	mov	DWORD PTR tv76[ebp], eax
	mov	ecx, DWORD PTR tv76[ebp]
	sub	ecx, 211				; 000000d3H
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 194		; 000000c2H
	ja	$LN1@ConstructA
	mov	edx, DWORD PTR tv76[ebp]
	movzx	eax, BYTE PTR $LN28@ConstructA[edx]
	jmp	DWORD PTR $LN30@ConstructA[eax*4]
$LN17@ConstructA:

; 1673 : 		{
; 1674 : 			case DBOBLOCK_ANIM_NAME : 				ReadString         ( (*ppAnim)->szName,	ppBlock );																		break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?ReadString@@YA_NPADPAPAD@Z		; ReadString
	add	esp, 8
	jmp	$LN18@ConstructA
$LN16@ConstructA:

; 1675 : 			case DBOBLOCK_ANIM_NUMPOSKEYS :			ReadDWORD          ( &(*ppAnim)->dwNumPositionKeys,	ppBlock );															break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 268				; 0000010cH
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN18@ConstructA
$LN15@ConstructA:

; 1676 : 			case DBOBLOCK_ANIM_POSDATA :			ReadMemory         ( (BYTE**)&(*ppAnim)->pPositionKeys,	sizeof(sPositionKey) * (*ppAnim)->dwNumPositionKeys, ppBlock );	break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+268]
	imul	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 284				; 0000011cH
	push	edx
	call	?ReadMemory@@YA_NPAPAEKPAPAD@Z		; ReadMemory
	add	esp, 12					; 0000000cH
	jmp	$LN18@ConstructA
$LN14@ConstructA:

; 1677 : 			case DBOBLOCK_ANIM_NUMROTKEYS :			ReadDWORD          ( &(*ppAnim)->dwNumRotateKeys, ppBlock );															break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 272				; 00000110H
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN18@ConstructA
$LN13@ConstructA:

; 1678 : 			case DBOBLOCK_ANIM_ROTDATA :			ReadMemory         ( (BYTE**)&(*ppAnim)->pRotateKeys, sizeof(sRotateKey) * (*ppAnim)->dwNumRotateKeys, ppBlock );		break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+272]
	imul	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 288				; 00000120H
	push	edx
	call	?ReadMemory@@YA_NPAPAEKPAPAD@Z		; ReadMemory
	add	esp, 12					; 0000000cH
	jmp	$LN18@ConstructA
$LN12@ConstructA:

; 1679 : 			case DBOBLOCK_ANIM_NUMSCALEKEYS :		ReadDWORD          ( &(*ppAnim)->dwNumScaleKeys, ppBlock );																break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 276				; 00000114H
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN18@ConstructA
$LN11@ConstructA:

; 1680 : 			case DBOBLOCK_ANIM_SCALEDATA :			ReadMemory         ( (BYTE**)&(*ppAnim)->pScaleKeys, sizeof(sScaleKey) * (*ppAnim)->dwNumScaleKeys,	ppBlock );			break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+276]
	imul	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 292				; 00000124H
	push	edx
	call	?ReadMemory@@YA_NPAPAEKPAPAD@Z		; ReadMemory
	add	esp, 12					; 0000000cH
	jmp	$LN18@ConstructA
$LN10@ConstructA:

; 1681 : 			case DBOBLOCK_ANIM_NUMMATRIXKEYS :		ReadDWORD          ( &(*ppAnim)->dwNumMatrixKeys, ppBlock );															break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 280				; 00000118H
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN18@ConstructA
$LN9@ConstructA:

; 1682 : 			case DBOBLOCK_ANIM_MATRIXDATA :			ReadMemory         ( (BYTE**)&(*ppAnim)->pMatrixKeys, sizeof(sMatrixKey) * (*ppAnim)->dwNumMatrixKeys, ppBlock );		break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+280]
	imul	eax, 132				; 00000084H
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 296				; 00000128H
	push	edx
	call	?ReadMemory@@YA_NPAPAEKPAPAD@Z		; ReadMemory
	add	esp, 12					; 0000000cH
	jmp	$LN18@ConstructA
$LN8@ConstructA:

; 1683 : 			case DBOBLOCK_FRAME_BONETYPE:			ReadDWORD          ( &(*ppAnim)->bBoneType,	ppBlock );																	break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 316				; 0000013cH
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN18@ConstructA
$LN7@ConstructA:

; 1684 : 			case DBOBLOCK_FRAME_BONEOFFSETLISTSIZE: ReadDWORD          ( ( DWORD* ) &(*ppAnim)->iBoneOffsetListCount,	ppBlock );											break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 324				; 00000144H
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN18@ConstructA
$LN6@ConstructA:

; 1685 : 			case DBOBLOCK_FRAME_BONEOFFSETLIST:		ReadOffsetListData ( &(*ppAnim)->piBoneOffsetList, (*ppAnim)->iBoneOffsetListCount, ppBlock );							break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+324]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 320				; 00000140H
	push	edx
	call	?ReadOffsetListData@@YA_NPAPAHKPAPAD@Z	; ReadOffsetListData
	add	esp, 12					; 0000000cH
	jmp	$LN18@ConstructA
$LN5@ConstructA:

; 1686 : 			case DBOBLOCK_FRAME_BONEMATRIXSIZEA:	ReadDWORD		   ( ( DWORD* ) &(*ppAnim)->iBoneFrameA, ppBlock );														break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 332				; 0000014cH
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN18@ConstructA
$LN4@ConstructA:

; 1687 : 			case DBOBLOCK_FRAME_BONEMATRIXSIZEB:	ReadDWORD		   ( ( DWORD* ) &(*ppAnim)->iBoneFrameB, ppBlock );														break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 336				; 00000150H
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	$LN18@ConstructA
$LN3@ConstructA:

; 1688 : 			case DBOBLOCK_ANIM_NEXT :				ConstructAnimation ( &(*ppAnim)->pNext, ppBlock );																		break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 344				; 00000158H
	push	edx
	call	?ConstructAnimation@@YA_NPAPAUsAnimation@@PAPAD@Z ; ConstructAnimation
	add	esp, 8
	jmp	SHORT $LN18@ConstructA
$LN2@ConstructA:

; 1689 : 
; 1690 : 			case DBOBLOCK_FRAME_BONEMATRIXLIST:
; 1691 : 				(*ppAnim)->ppBoneFrames = new D3DXMATRIX* [ (*ppAnim)->iBoneFrameA];

	mov	eax, DWORD PTR _ppAnim$[ebp]
	mov	ecx, DWORD PTR [eax]
	xor	ebx, ebx
	mov	eax, DWORD PTR [ecx+332]
	mov	edx, 4
	mul	edx
	seto	bl
	neg	ebx
	or	ebx, eax
	push	ebx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58135[ebp], eax
	mov	eax, DWORD PTR _ppAnim$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR $T58135[ebp]
	mov	DWORD PTR [ecx+328], edx

; 1692 : 				ReadBoneMatrices ( (*ppAnim)->ppBoneFrames, (*ppAnim)->iBoneFrameA, (*ppAnim)->iBoneFrameA, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	mov	ecx, DWORD PTR _ppAnim$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	call	?ReadBoneMatrices@@YA_NPAPAUD3DXMATRIX@@KKPAPAD@Z ; ReadBoneMatrices
	add	esp, 16					; 00000010H

; 1693 : 			break;

	jmp	SHORT $LN18@ConstructA
$LN1@ConstructA:

; 1694 : 
; 1695 : 			default : 
; 1696 : 				*ppBlock += dwCodeSize;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwCodeSize$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN18@ConstructA:

; 1697 : 			break;
; 1698 : 		}
; 1699 : 
; 1700 : 		// get next code
; 1701 : 		ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1702 : 	}

	jmp	$LN21@ConstructA
$LN20@ConstructA:

; 1703 : 
; 1704 : 	// okay
; 1705 : 	return true;

	mov	al, 1

; 1706 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN30@ConstructA:
	DD	$LN17@ConstructA
	DD	$LN16@ConstructA
	DD	$LN15@ConstructA
	DD	$LN14@ConstructA
	DD	$LN13@ConstructA
	DD	$LN12@ConstructA
	DD	$LN11@ConstructA
	DD	$LN10@ConstructA
	DD	$LN9@ConstructA
	DD	$LN3@ConstructA
	DD	$LN8@ConstructA
	DD	$LN6@ConstructA
	DD	$LN7@ConstructA
	DD	$LN5@ConstructA
	DD	$LN4@ConstructA
	DD	$LN2@ConstructA
	DD	$LN1@ConstructA
$LN28@ConstructA:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ConstructAnimation@@YA_NPAPAUsAnimation@@PAPAD@Z$0:
	mov	eax, DWORD PTR $T58132[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ConstructAnimation@@YA_NPAPAUsAnimation@@PAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ConstructAnimation@@YA_NPAPAUsAnimation@@PAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ConstructAnimation@@YA_NPAPAUsAnimation@@PAPAD@Z ENDP	; ConstructAnimation
PUBLIC	?ConstructAnimationSet@@YA_NPAPAUsAnimationSet@@PAPAD@Z ; ConstructAnimationSet
EXTRN	??0sAnimationSet@@QAE@XZ:PROC			; sAnimationSet::sAnimationSet
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ConstructAnimationSet@@YA_NPAPAUsAnimationSet@@PAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ConstructAnimationSet@@YA_NPAPAUsAnimationSet@@PAPAD@Z$0
__ehfuncinfo$?ConstructAnimationSet@@YA_NPAPAUsAnimationSet@@PAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ConstructAnimationSet@@YA_NPAPAUsAnimationSet@@PAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?ConstructAnimationSet@@YA_NPAPAUsAnimationSet@@PAPAD@Z
_TEXT	SEGMENT
tv76 = -96						; size = 4
tv75 = -96						; size = 4
$T58147 = -92						; size = 4
$T58148 = -88						; size = 4
_dwCodeSize$ = -20					; size = 4
_dwCode$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ppAnimSet$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
?ConstructAnimationSet@@YA_NPAPAUsAnimationSet@@PAPAD@Z PROC ; ConstructAnimationSet, COMDAT

; 1709 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ConstructAnimationSet@@YA_NPAPAUsAnimationSet@@PAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1710 : 	// get code
; 1711 : 	DWORD dwCode = 0;

	mov	DWORD PTR _dwCode$[ebp], 0

; 1712 : 	DWORD dwCodeSize = 0;

	mov	DWORD PTR _dwCodeSize$[ebp], 0

; 1713 : 	
; 1714 : 	ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1715 : 	
; 1716 : 	if ( dwCode > 0 )

	cmp	DWORD PTR _dwCode$[ebp], 0
	jbe	SHORT $LN8@ConstructA@2

; 1717 : 	{
; 1718 : 		// create animset
; 1719 : 		(*ppAnimSet) = new sAnimationSet;

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58148[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T58148[ebp], 0
	je	SHORT $LN12@ConstructA@2
	mov	ecx, DWORD PTR $T58148[ebp]
	call	??0sAnimationSet@@QAE@XZ		; sAnimationSet::sAnimationSet
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN13@ConstructA@2
$LN12@ConstructA@2:
	mov	DWORD PTR tv75[ebp], 0
$LN13@ConstructA@2:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T58147[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _ppAnimSet$[ebp]
	mov	edx, DWORD PTR $T58147[ebp]
	mov	DWORD PTR [ecx], edx
$LN8@ConstructA@2:

; 1720 : 	}
; 1721 : 
; 1722 : 	while ( dwCode > 0 )

	cmp	DWORD PTR _dwCode$[ebp], 0
	jbe	$LN7@ConstructA@2

; 1723 : 	{
; 1724 : 		switch ( dwCode )

	mov	eax, DWORD PTR _dwCode$[ebp]
	mov	DWORD PTR tv76[ebp], eax
	cmp	DWORD PTR tv76[ebp], 201		; 000000c9H
	je	SHORT $LN4@ConstructA@2
	cmp	DWORD PTR tv76[ebp], 202		; 000000caH
	je	SHORT $LN3@ConstructA@2
	cmp	DWORD PTR tv76[ebp], 203		; 000000cbH
	je	SHORT $LN2@ConstructA@2
	jmp	SHORT $LN1@ConstructA@2
$LN4@ConstructA@2:

; 1725 : 		{
; 1726 : 			case DBOBLOCK_ANIMSET_NAME :	ReadString         ( (*ppAnimSet)->szName,		ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnimSet$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?ReadString@@YA_NPADPAPAD@Z		; ReadString
	add	esp, 8
	jmp	SHORT $LN5@ConstructA@2
$LN3@ConstructA@2:

; 1727 : 			case DBOBLOCK_ANIMSET_LENGTH :  ReadDWORD		   ( &(*ppAnimSet)->ulLength,	ppBlock ); break;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnimSet$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 260				; 00000104H
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8
	jmp	SHORT $LN5@ConstructA@2
$LN2@ConstructA@2:

; 1728 : 			case DBOBLOCK_ANIMSET_DATA :	ConstructAnimation ( &(*ppAnimSet)->pAnimation,	ppBlock ); break;				

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppAnimSet$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 256				; 00000100H
	push	edx
	call	?ConstructAnimation@@YA_NPAPAUsAnimation@@PAPAD@Z ; ConstructAnimation
	add	esp, 8
	jmp	SHORT $LN5@ConstructA@2
$LN1@ConstructA@2:

; 1729 : 
; 1730 : 			default :
; 1731 : 				*ppBlock += dwCodeSize;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwCodeSize$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN5@ConstructA@2:

; 1732 : 			break;
; 1733 : 		}
; 1734 : 
; 1735 : 		// get next code
; 1736 : 		ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1737 : 	}

	jmp	$LN8@ConstructA@2
$LN7@ConstructA@2:

; 1738 : 
; 1739 : 	// okay
; 1740 : 	return true;

	mov	al, 1

; 1741 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ConstructAnimationSet@@YA_NPAPAUsAnimationSet@@PAPAD@Z$0:
	mov	eax, DWORD PTR $T58148[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ConstructAnimationSet@@YA_NPAPAUsAnimationSet@@PAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ConstructAnimationSet@@YA_NPAPAUsAnimationSet@@PAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ConstructAnimationSet@@YA_NPAPAUsAnimationSet@@PAPAD@Z ENDP ; ConstructAnimationSet
PUBLIC	?ConstructCustomData@@YA_NPAPAUsObject@@PAPAD@Z	; ConstructCustomData
; Function compile flags: /Odtp /ZI
;	COMDAT ?ConstructCustomData@@YA_NPAPAUsObject@@PAPAD@Z
_TEXT	SEGMENT
tv148 = -88						; size = 4
$T58160 = -84						; size = 4
$T58161 = -80						; size = 4
$T58162 = -76						; size = 4
_dwCodeSize$ = -8					; size = 4
_dwCode$ = -4						; size = 4
_ppObject$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
?ConstructCustomData@@YA_NPAPAUsObject@@PAPAD@Z PROC	; ConstructCustomData, COMDAT

; 1744 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1745 : 	// 280305 - used when objects want to store custom data for example when they save and want to save out this data
; 1746 : 	DWORD dwCode = 0;

	mov	DWORD PTR _dwCode$[ebp], 0

; 1747 : 	DWORD dwCodeSize = 0;

	mov	DWORD PTR _dwCodeSize$[ebp], 0

; 1748 : 	ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1749 : 	SAFE_DELETE ( (*ppObject)->pCustomData );

	mov	eax, DWORD PTR _ppObject$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+1320], 0
	je	SHORT $LN9@ConstructC
	mov	eax, DWORD PTR _ppObject$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+1320]
	mov	DWORD PTR $T58160[ebp], edx
	mov	eax, DWORD PTR $T58160[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, DWORD PTR _ppObject$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+1320], 0
$LN9@ConstructC:

; 1750 : 
; 1751 : 	// LEEFIX - 150508 - the OLD method of custom data would not have 'dwCustomSize' and so cause ppBlock to advance wrongly
; 1752 : 	// and thus the ReadCODE after the case will cause reading invalid memory (loading DBO from UU3D!)
; 1753 : 	if ( g_dwVersion<=1 )

	cmp	DWORD PTR ?g_dwVersion@@3KA, 1		; g_dwVersion
	ja	SHORT $LN6@ConstructC

; 1754 : 	{
; 1755 : 		// leefix - 150508 - allowed for old version to fill custom data too
; 1756 : 		(*ppObject)->dwCustomSize = dwCodeSize;

	mov	eax, DWORD PTR _ppObject$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _dwCodeSize$[ebp]
	mov	DWORD PTR [ecx+1316], edx

; 1757 : 		(*ppObject)->pCustomData = new BYTE [ (*ppObject)->dwCustomSize ];

	mov	eax, DWORD PTR _ppObject$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+1316]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58161[ebp], eax
	mov	eax, DWORD PTR _ppObject$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR $T58161[ebp]
	mov	DWORD PTR [ecx+1320], edx

; 1758 : 		ReadIntoMemory ( (BYTE*)(*ppObject)->pCustomData, (*ppObject)->dwCustomSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppObject$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+1316]
	push	eax
	mov	ecx, DWORD PTR _ppObject$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+1320]
	push	eax
	call	?ReadIntoMemory@@YA_NPAEKPAPAD@Z	; ReadIntoMemory
	add	esp, 12					; 0000000cH

; 1759 : 	}
; 1760 : 	else

	jmp	$LN7@ConstructC
$LN6@ConstructC:

; 1761 : 	{
; 1762 : 		// new versions have extra customsize DWORD - get code
; 1763 : 		while ( dwCode > 0 )

	cmp	DWORD PTR _dwCode$[ebp], 0
	jbe	$LN7@ConstructC

; 1764 : 		{
; 1765 : 			switch ( dwCode )

	mov	eax, DWORD PTR _dwCode$[ebp]
	mov	DWORD PTR tv148[ebp], eax
	cmp	DWORD PTR tv148[ebp], 406		; 00000196H
	je	SHORT $LN2@ConstructC
	jmp	SHORT $LN1@ConstructC
$LN2@ConstructC:

; 1766 : 			{
; 1767 : 				case DBOBLOCK_OBJECT_CUSTOMDATA:
; 1768 : 				{
; 1769 : 					ReadDWORD      ( &(*ppObject)->dwCustomSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppObject$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1316				; 00000524H
	push	edx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8

; 1770 : 					(*ppObject)->pCustomData = new BYTE [ (*ppObject)->dwCustomSize ];

	mov	eax, DWORD PTR _ppObject$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+1316]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58162[ebp], eax
	mov	eax, DWORD PTR _ppObject$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR $T58162[ebp]
	mov	DWORD PTR [ecx+1320], edx

; 1771 : 					ReadIntoMemory ( (BYTE*)(*ppObject)->pCustomData, (*ppObject)->dwCustomSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppObject$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+1316]
	push	eax
	mov	ecx, DWORD PTR _ppObject$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+1320]
	push	eax
	call	?ReadIntoMemory@@YA_NPAEKPAPAD@Z	; ReadIntoMemory
	add	esp, 12					; 0000000cH

; 1772 : 				}
; 1773 : 				break;

	jmp	SHORT $LN3@ConstructC
$LN1@ConstructC:

; 1774 : 
; 1775 : 				// leefix - 070405 - this u58 addition caused saved DBO objects to run through garbage data
; 1776 : 				default :
; 1777 : 					*ppBlock += dwCodeSize;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dwCodeSize$[ebp]
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@ConstructC:

; 1778 : 
; 1779 : 				break;
; 1780 : 			}
; 1781 : 
; 1782 : 			// get next code
; 1783 : 			// leefix - 070405 - also no final terminate code was written (in write part) meaning we are trapped here until random crash!
; 1784 : 			ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1785 : 		}

	jmp	$LN6@ConstructC
$LN7@ConstructC:

; 1786 : 	}
; 1787 : 
; 1788 : 	return true;

	mov	al, 1

; 1789 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ConstructCustomData@@YA_NPAPAUsObject@@PAPAD@Z ENDP	; ConstructCustomData
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ConstructObject@@YA_NPAPAUsObject@@PAPAD@Z	; ConstructObject
EXTRN	??0sObject@@QAE@XZ:PROC				; sObject::sObject
EXTRN	__stricmp:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ConstructObject@@YA_NPAPAUsObject@@PAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ConstructObject@@YA_NPAPAUsObject@@PAPAD@Z$0
__ehfuncinfo$?ConstructObject@@YA_NPAPAUsObject@@PAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ConstructObject@@YA_NPAPAUsObject@@PAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?ConstructObject@@YA_NPAPAUsObject@@PAPAD@Z
_TEXT	SEGMENT
tv83 = -368						; size = 4
$T58166 = -364						; size = 4
$T58167 = -360						; size = 4
_dwCodeSize$57700 = -292				; size = 4
_dwCode$57699 = -288					; size = 4
_dwRes2$57694 = -284					; size = 4
_dwRes1$57693 = -280					; size = 4
_dwVersion$57692 = -276					; size = 4
_pMagicString$ = -272					; size = 256
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_ppObject$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
?ConstructObject@@YA_NPAPAUsObject@@PAPAD@Z PROC	; ConstructObject, COMDAT

; 1792 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ConstructObject@@YA_NPAPAUsObject@@PAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 356				; 00000164H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1793 : 	// ensure is DBO block
; 1794 : 	char pMagicString [ MAX_STRING ];
; 1795 : 
; 1796 : 	ReadString ( pMagicString, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pMagicString$[ebp]
	push	ecx
	call	?ReadString@@YA_NPADPAPAD@Z		; ReadString
	add	esp, 8

; 1797 : 
; 1798 : 	if ( _stricmp ( pMagicString, "MAGICDBO" )==NULL )

	push	OFFSET ??_C@_08HFDNDKLG@MAGICDBO?$AA@
	lea	eax, DWORD PTR _pMagicString$[ebp]
	push	eax
	call	__stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN5@ConstructO

; 1799 : 	{
; 1800 : 		// version information
; 1801 : 		DWORD dwVersion=0;

	mov	DWORD PTR _dwVersion$57692[ebp], 0

; 1802 : 		DWORD dwRes1=0, dwRes2=0;

	mov	DWORD PTR _dwRes1$57693[ebp], 0
	mov	DWORD PTR _dwRes2$57694[ebp], 0

; 1803 : 		ReadDWORD	( &dwVersion,	ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwVersion$57692[ebp]
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8

; 1804 : 		ReadDWORD	( &dwRes1,		ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwRes1$57693[ebp]
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8

; 1805 : 		ReadDWORD	( &dwRes2,		ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwRes2$57694[ebp]
	push	ecx
	call	?ReadDWORD@@YA_NPAKPAPAD@Z		; ReadDWORD
	add	esp, 8

; 1806 : 		g_dwVersion = dwVersion;

	mov	eax, DWORD PTR _dwVersion$57692[ebp]
	mov	DWORD PTR ?g_dwVersion@@3KA, eax	; g_dwVersion

; 1807 : 
; 1808 : 		// create object
; 1809 : 		(*ppObject) = new sObject;

	push	1324					; 0000052cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58167[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T58167[ebp], 0
	je	SHORT $LN8@ConstructO
	mov	ecx, DWORD PTR $T58167[ebp]
	call	??0sObject@@QAE@XZ			; sObject::sObject
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN9@ConstructO
$LN8@ConstructO:
	mov	DWORD PTR tv83[ebp], 0
$LN9@ConstructO:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR $T58166[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _ppObject$[ebp]
	mov	edx, DWORD PTR $T58166[ebp]
	mov	DWORD PTR [ecx], edx

; 1810 : 
; 1811 : 		// construct frame data
; 1812 : 		DWORD dwCode = 0, dwCodeSize = 0;

	mov	DWORD PTR _dwCode$57699[ebp], 0
	mov	DWORD PTR _dwCodeSize$57700[ebp], 0

; 1813 : 		ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$57700[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$57699[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1814 : 		if ( !ConstructFrame ( &(*ppObject)->pFrame, ppBlock ) )

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppObject$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 16					; 00000010H
	push	edx
	call	?ConstructFrame@@YA_NPAPAUsFrame@@PAPAD@Z ; ConstructFrame
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@ConstructO

; 1815 : 		{
; 1816 : 			// cannot construct frame
; 1817 : 			return false;

	xor	al, al
	jmp	SHORT $LN6@ConstructO
$LN4@ConstructO:

; 1818 : 		}
; 1819 : 
; 1820 : 		// construct animation data
; 1821 : 		ReadCODE ( &dwCode, &dwCodeSize, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwCodeSize$57700[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwCode$57699[ebp]
	push	edx
	call	?ReadCODE@@YA_NPAK0PAPAD@Z		; ReadCODE
	add	esp, 12					; 0000000cH

; 1822 : 		if ( !ConstructAnimationSet ( &(*ppObject)->pAnimationSet, ppBlock ) )

	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppObject$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 20					; 00000014H
	push	edx
	call	?ConstructAnimationSet@@YA_NPAPAUsAnimationSet@@PAPAD@Z ; ConstructAnimationSet
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@ConstructO

; 1823 : 		{
; 1824 : 			// cannot construct animation
; 1825 : 			return false;

	xor	al, al
	jmp	SHORT $LN6@ConstructO
$LN3@ConstructO:

; 1826 : 		}
; 1827 : 
; 1828 : 		// 280305 - new custom data
; 1829 : 		// lee - 280306 - u6rc2 - ONLY if there is more block data (older DBO files did not have any more data)
; 1830 : 		if ( *ppBlock < g_pBlockEnd ) ConstructCustomData ( ppObject, ppBlock );

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR ?g_pBlockEnd@@3PADA	; g_pBlockEnd
	jae	SHORT $LN2@ConstructO
	mov	eax, DWORD PTR _ppBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppObject$[ebp]
	push	ecx
	call	?ConstructCustomData@@YA_NPAPAUsObject@@PAPAD@Z ; ConstructCustomData
	add	esp, 8
$LN2@ConstructO:

; 1831 : 	}
; 1832 : 	else

	jmp	SHORT $LN1@ConstructO
$LN5@ConstructO:

; 1833 : 	{
; 1834 : 		// not a DBO file
; 1835 : 		return false;

	xor	al, al
	jmp	SHORT $LN6@ConstructO
$LN1@ConstructO:

; 1836 : 	}
; 1837 : 
; 1838 : 	// return result
; 1839 : 	return true;

	mov	al, 1
$LN6@ConstructO:

; 1840 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ConstructObject@@YA_NPAPAUsObject@@PAPAD@Z$0:
	mov	eax, DWORD PTR $T58167[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ConstructObject@@YA_NPAPAUsObject@@PAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-372]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ConstructObject@@YA_NPAPAUsObject@@PAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ConstructObject@@YA_NPAPAUsObject@@PAPAD@Z ENDP	; ConstructObject
PUBLIC	?DBOConvertObjectToBlock@@YA_NPAUsObject@@PAK1@Z ; DBOConvertObjectToBlock
; Function compile flags: /Odtp /ZI
;	COMDAT ?DBOConvertObjectToBlock@@YA_NPAUsObject@@PAK1@Z
_TEXT	SEGMENT
$T58179 = -88						; size = 4
$T58180 = -84						; size = 4
_pBlock$ = -16						; size = 4
_dwBytePosition$ = -12					; size = 4
_pBlockBase$ = -8					; size = 4
_dwSize$ = -4						; size = 4
_pObject$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
_pdwBlockSize$ = 16					; size = 4
?DBOConvertObjectToBlock@@YA_NPAUsObject@@PAK1@Z PROC	; DBOConvertObjectToBlock, COMDAT

; 1847 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1848 : 	// determine size of block
; 1849 : 	DWORD dwSize = 0;

	mov	DWORD PTR _dwSize$[ebp], 0

; 1850 : 	if ( !ScanObject ( pObject, NULL, &dwSize ) )

	lea	eax, DWORD PTR _dwSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _pObject$[ebp]
	push	ecx
	call	?ScanObject@@YA_NPAUsObject@@PAPADPAK@Z	; ScanObject
	add	esp, 12					; 0000000cH
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@DBOConvert

; 1851 : 	{
; 1852 : 		// could not parse object
; 1853 : 		return false;

	xor	al, al
	jmp	SHORT $LN4@DBOConvert
$LN3@DBOConvert:

; 1854 : 	}
; 1855 : 
; 1856 : 	// create block memory
; 1857 : 	LPSTR pBlockBase = new char[dwSize];

	mov	eax, DWORD PTR _dwSize$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58179[ebp], eax
	mov	ecx, DWORD PTR $T58179[ebp]
	mov	DWORD PTR _pBlockBase$[ebp], ecx

; 1858 : 
; 1859 : 	// generate block data from object
; 1860 : 	DWORD dwBytePosition = 0;

	mov	DWORD PTR _dwBytePosition$[ebp], 0

; 1861 : 	LPSTR pBlock = pBlockBase;

	mov	eax, DWORD PTR _pBlockBase$[ebp]
	mov	DWORD PTR _pBlock$[ebp], eax

; 1862 : 	if ( !ScanObject ( pObject, &pBlock, &dwBytePosition ) )

	lea	eax, DWORD PTR _dwBytePosition$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pObject$[ebp]
	push	edx
	call	?ScanObject@@YA_NPAUsObject@@PAPADPAK@Z	; ScanObject
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@DBOConvert

; 1863 : 	{
; 1864 : 		// could not parse object
; 1865 : 		SAFE_DELETE(pBlock);

	cmp	DWORD PTR _pBlock$[ebp], 0
	je	SHORT $LN1@DBOConvert
	mov	eax, DWORD PTR _pBlock$[ebp]
	mov	DWORD PTR $T58180[ebp], eax
	mov	ecx, DWORD PTR $T58180[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	DWORD PTR _pBlock$[ebp], 0
$LN1@DBOConvert:

; 1866 : 		return false;

	xor	al, al
	jmp	SHORT $LN4@DBOConvert
$LN2@DBOConvert:

; 1867 : 	}
; 1868 : 
; 1869 : 	// store block size
; 1870 : 	*ppBlock = (DWORD)pBlockBase;

	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR _pBlockBase$[ebp]
	mov	DWORD PTR [eax], ecx

; 1871 : 	*pdwBlockSize = dwSize;

	mov	eax, DWORD PTR _pdwBlockSize$[ebp]
	mov	ecx, DWORD PTR _dwSize$[ebp]
	mov	DWORD PTR [eax], ecx

; 1872 : 
; 1873 : 	// return okay
; 1874 : 	return true;

	mov	al, 1
$LN4@DBOConvert:

; 1875 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DBOConvertObjectToBlock@@YA_NPAUsObject@@PAK1@Z ENDP	; DBOConvertObjectToBlock
_TEXT	ENDS
PUBLIC	?DBOConvertBlockToObject@@YA_NKKPAPAUsObject@@@Z ; DBOConvertBlockToObject
; Function compile flags: /Odtp /ZI
;	COMDAT ?DBOConvertBlockToObject@@YA_NKKPAPAUsObject@@@Z
_TEXT	SEGMENT
_pBlock$ = 8						; size = 4
_dwBlockSize$ = 12					; size = 4
_ppObject$ = 16						; size = 4
?DBOConvertBlockToObject@@YA_NKKPAPAUsObject@@@Z PROC	; DBOConvertBlockToObject, COMDAT

; 1878 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1879 : 	// lee - 280306 - u6rc2 - defeat custom-data read crash (from old DBO files), by recording end of block data gloablly
; 1880 : 	g_pBlockEnd = (LPSTR)pBlock + dwBlockSize;

	mov	eax, DWORD PTR _pBlock$[ebp]
	add	eax, DWORD PTR _dwBlockSize$[ebp]
	mov	DWORD PTR ?g_pBlockEnd@@3PADA, eax	; g_pBlockEnd

; 1881 : 
; 1882 : 	// construct object from block
; 1883 : 	if ( !ConstructObject ( ppObject, (LPSTR*)&pBlock ) )

	lea	eax, DWORD PTR _pBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppObject$[ebp]
	push	ecx
	call	?ConstructObject@@YA_NPAPAUsObject@@PAPAD@Z ; ConstructObject
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@DBOConvert@2

; 1884 : 		return false;

	xor	al, al
	jmp	SHORT $LN2@DBOConvert@2
$LN1@DBOConvert@2:

; 1885 : 
; 1886 : 	// return okay
; 1887 : 	return true;

	mov	al, 1
$LN2@DBOConvert@2:

; 1888 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DBOConvertBlockToObject@@YA_NKKPAPAUsObject@@@Z ENDP	; DBOConvertBlockToObject
_TEXT	ENDS
PUBLIC	?DBOLoadBlockFile@@YA_NPADPAK1@Z		; DBOLoadBlockFile
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__imp__GetFileSize@8:PROC
EXTRN	__imp__CreateFileA@28:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ?DBOLoadBlockFile@@YA_NPADPAK1@Z
_TEXT	SEGMENT
$T58185 = -76						; size = 4
_bytesread$57738 = -8					; size = 4
_hfile$ = -4						; size = 4
_pFilename$ = 8						; size = 4
_ppBlock$ = 12						; size = 4
_pdwSize$ = 16						; size = 4
?DBOLoadBlockFile@@YA_NPADPAK1@Z PROC			; DBOLoadBlockFile, COMDAT

; 1891 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1892 : 	// load file
; 1893 : 	HANDLE hfile = CreateFile ( pFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

	push	0
	push	128					; 00000080H
	push	3
	push	0
	push	1
	push	-2147483648				; 80000000H
	mov	eax, DWORD PTR _pFilename$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _hfile$[ebp], eax

; 1894 : 	if ( hfile != INVALID_HANDLE_VALUE )

	cmp	DWORD PTR _hfile$[ebp], -1
	je	SHORT $LN2@DBOLoadBlo

; 1895 : 	{
; 1896 : 		DWORD bytesread=0;

	mov	DWORD PTR _bytesread$57738[ebp], 0

; 1897 : 		*pdwSize = GetFileSize ( hfile, NULL );

	push	0
	mov	eax, DWORD PTR _hfile$[ebp]
	push	eax
	call	DWORD PTR __imp__GetFileSize@8
	mov	ecx, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [ecx], eax

; 1898 : 		*ppBlock = (DWORD)new char[*pdwSize];

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58185[ebp], eax
	mov	edx, DWORD PTR _ppBlock$[ebp]
	mov	eax, DWORD PTR $T58185[ebp]
	mov	DWORD PTR [edx], eax

; 1899 : 		ReadFile( hfile, (LPSTR)(*ppBlock), *pdwSize, &bytesread, NULL ); 

	push	0
	lea	eax, DWORD PTR _bytesread$57738[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdwSize$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _ppBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _hfile$[ebp]
	push	edx
	call	DWORD PTR __imp__ReadFile@20

; 1900 : 		CloseHandle ( hfile );

	mov	eax, DWORD PTR _hfile$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 1901 : 	}
; 1902 : 	else

	jmp	SHORT $LN1@DBOLoadBlo
$LN2@DBOLoadBlo:

; 1903 : 	{
; 1904 : 		// could not load file
; 1905 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@DBOLoadBlo
$LN1@DBOLoadBlo:

; 1906 : 	}
; 1907 : 
; 1908 : 	// okay
; 1909 : 	return true;

	mov	al, 1
$LN3@DBOLoadBlo:

; 1910 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DBOLoadBlockFile@@YA_NPADPAK1@Z ENDP			; DBOLoadBlockFile
_TEXT	ENDS
PUBLIC	?DBOSaveBlockFile@@YA_NPADKK@Z			; DBOSaveBlockFile
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__DeleteFileA@4:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ?DBOSaveBlockFile@@YA_NPADKK@Z
_TEXT	SEGMENT
_byteswritten$57753 = -8				; size = 4
_hfile$ = -4						; size = 4
_pFilename$ = 8						; size = 4
_pBlock$ = 12						; size = 4
_dwSize$ = 16						; size = 4
?DBOSaveBlockFile@@YA_NPADKK@Z PROC			; DBOSaveBlockFile, COMDAT

; 1913 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1914 : 	// save new file
; 1915 : 	DeleteFile ( pFilename );

	mov	eax, DWORD PTR _pFilename$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteFileA@4

; 1916 : 	HANDLE hfile = CreateFile ( pFilename, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

	push	0
	push	128					; 00000080H
	push	2
	push	0
	push	2
	push	1073741824				; 40000000H
	mov	eax, DWORD PTR _pFilename$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _hfile$[ebp], eax

; 1917 : 	if ( hfile != INVALID_HANDLE_VALUE )

	cmp	DWORD PTR _hfile$[ebp], -1
	je	SHORT $LN2@DBOSaveBlo

; 1918 : 	{
; 1919 : 		DWORD byteswritten=0;

	mov	DWORD PTR _byteswritten$57753[ebp], 0

; 1920 : 		WriteFile( hfile, (LPSTR)pBlock, dwSize, &byteswritten, NULL ); 

	push	0
	lea	eax, DWORD PTR _byteswritten$57753[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pBlock$[ebp]
	push	edx
	mov	eax, DWORD PTR _hfile$[ebp]
	push	eax
	call	DWORD PTR __imp__WriteFile@20

; 1921 : 		CloseHandle ( hfile );

	mov	eax, DWORD PTR _hfile$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 1922 : 	}
; 1923 : 	else

	jmp	SHORT $LN1@DBOSaveBlo
$LN2@DBOSaveBlo:

; 1924 : 	{
; 1925 : 		// could not create file
; 1926 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@DBOSaveBlo
$LN1@DBOSaveBlo:

; 1927 : 	}
; 1928 : 
; 1929 : 	// okay
; 1930 : 	return true;

	mov	al, 1
$LN3@DBOSaveBlo:

; 1931 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DBOSaveBlockFile@@YA_NPADKK@Z ENDP			; DBOSaveBlockFile
_TEXT	ENDS
END
